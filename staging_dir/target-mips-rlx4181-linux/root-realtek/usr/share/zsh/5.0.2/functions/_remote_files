#autoload

# Complete files on remote systems using SSH (and other programs). Needs
# key-based authentication with no passwords or a running ssh-agent to work.
#
# Usage:
#   _remote_files [-/] [-g glob] [-h host] -- <cmd> [<cmd options>]
#
# Options:
# - -/: only complete directories
# - -g: specify a pattern to match against files
#       p, = and * glob qualifiers supported
# - -h: specify the remote host, default is ${IPREFIX%:}
#
# Commands:
# - ssh: Additional options for non-interactive use are automatically added
#        (see below).
# - All other commands are used unaltered.
#
# Examples:
# - _remote_files -- ssh
#   Use ssh to retrieve the remote paths. The "--" is not optional!
# - _remote_files --no-files -- ssh -2 -p 42
#   Use ssh with the option -2 and -p 42 to retrieve the remote paths and
#   complete only directories.
# - _remote_files -- rsh
#   Use rsh to retrieve the remote paths.


# There should be coloring based on all the different ls -F classifiers.
local expl rempat remfiles remdispf remdispd args cmd cmd_args suf ret=1
local glob host

if zstyle -T ":completion:${curcontext}:files" remote-access; then

  # Parse options to _remote_files. Stops at the first "--".
  zparseopts -D -E -a args / g:=glob h:=host
  shift
  (( $#host)) && shift host || host="${IPREFIX%:}"

  # Command to run on the remote system.
  cmd="$1"
  shift

  # Handle arguments to ssh.
  if [[ $cmd == ssh ]]; then
    zparseopts -D -E -a cmd_args p: 1 2 4 6 F:
    cmd_args="-o BatchMode=yes $cmd_args -a -x"
  else
    cmd_args="$@"
  fi

  if [[ -z $QIPREFIX ]]
    then rempat="${PREFIX%%[^./][^/]#}\*"
    else rempat="${(q)PREFIX%%[^./][^/]#}\*"
  fi

  remfiles=(${(M)${(f)"$(_call_program files $cmd $cmd_args $host ls -d1FL -- "$rempat" 2>/dev/null)"}%%[^/]#(|/)})

  compset -P '*/'
  compset -S '/*' || (( ${args[(I)-/]} )) || suf='remote file'

  remdispf=(${remfiles:#*/})
  remdispd=(${(M)remfiles:#*/})

  if (( $#glob )); then
    match=( '(|[*=|])' )
    glob[2]="${glob[2]/(#b)\(((|^)[p=\*])\)(#e)/}"
    glob[2]+="${${match[1]/p/\|}/\*/\*}"
    remdispf=( ${(M)remdispf:#${~glob[2]}} )
  fi

  _tags files
  while _tags; do
    while _next_label files expl ${suf:-remote directory}; do
      [[ -n $suf ]] &&
          compadd "$@" "$expl[@]" -d remdispf ${(q)remdispf%[*=|]} && ret=0
      compadd ${suf:+-S/} -r "/ \t\n\-" "$@" "$expl[@]" -d remdispd \
	${(q)remdispd%/} && ret=0
    done
    (( ret )) || return 0
  done
  return ret
else
    _message -e remote-files 'remote file'
fi

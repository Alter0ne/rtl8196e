# pglcmd.lib - shell functions for pglcmd
#
# Copyright (C) 2005 - 2011 jre <jre-phoenix@users.sourceforge.net>
# Parts and ideas from JFM, /meth/usr, lestlest (clessing), Morpheus and
# perhaps others. More Info: http://forums.phoenixlabs.org
# This file is part of pgl.
#
# pgl is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pgl is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


# Following is a modified version of /lib/lsb/init-functions (Debian 3.2-27). If
# that file exists on your system, then the functions in that file will
# overwrite the following functions.
################################################################################
# /lib/lsb/init-functions for Debian -*- shell-script -*-
#
#Copyright (c) 2002-08 Chris Lawrence
#All rights reserved.
#
#Redistribution and use in source and binary forms, with or without
#modification, are permitted provided that the following conditions
#are met:
#1. Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
#2. Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in the
#   documentation and/or other materials provided with the distribution.
#3. Neither the name of the author nor the names of other contributors
#   may be used to endorse or promote products derived from this software
#   without specific prior written permission.
#
#THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
#IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
#LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
#CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
#BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
#WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
#OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
#EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

start_daemon () {
    local force nice pidfile exec args
    force=""
    nice=0
    pidfile=/dev/null

    OPTIND=1
    while getopts fn:p: opt ; do
        case "$opt" in
            f)  force="force";;
            n)  nice="$OPTARG";;
            p)  pidfile="$OPTARG";;
        esac
    done

    shift $(($OPTIND - 1))
    if [ "$1" = '--' ]; then
        shift
    fi

    exec="$1"; shift

    args="--start --nicelevel $nice --quiet --oknodo"
    if [ "$force" ]; then
      if test_external start-stop-daemon ; then
        start-stop-daemon $args \
            --chdir "$PWD" --startas $exec --pidfile /dev/null -- "$@"
      else
        exec $exec $@ &
        # If renice fails somehow just ignore it.
        if test_external renice ; then
            PID="$(pidofproc $PID_OPT $exec)" || {
                sleep 1
                PID="$(pidofproc $exec)"
            } &&
            renice -n "$nice" -p "$PID" >/dev/null 2>&1
        fi
      fi
    elif [ $pidfile ]; then
      if test_external start-stop-daemon ; then
        start-stop-daemon $args \
            --chdir "$PWD" --exec $exec --oknodo --pidfile "$pidfile" -- "$@"
      else
        # If daemon is already running, return 0.
        pidofproc -p $pidfile $exec >/dev/null 2>&1 && return 0
        exec $exec $@ &
        # If renice fails somehow just ignore it.
        if test_external renice ; then
            PID="$(pidofproc -p $pidfile $exec)" || {
                sleep 1
                PID="$(pidofproc -p $pidfile $exec)"
            } &&
            renice -n "$nice" -p "$PID" >/dev/null 2>&1
        fi
      fi
    else
      if test_external start-stop-daemon ; then
        start-stop-daemon $args \
            --chdir "$PWD" --exec $exec -- "$@"
      else
        # If daemon is already running, return 0.
        pidofproc $exec >/dev/null 2>&1 && return 0
        exec $exec $@ &
        # If renice fails somehow just ignore it.
        if test_external renice ; then
            PID="$(pidofproc $exec)" || {
                sleep 1
                PID="$(pidofproc $exec)"
            } &&
            renice -n "$nice" -p "$PID" >/dev/null 2>&1
        fi
      fi
    fi
}

pidofproc () {
    local pidfile line status specified pid
    pidfile=
    specified=

    OPTIND=1
    while getopts p: opt ; do
        case "$opt" in
            p)  pidfile="$OPTARG"
                specified="specified"
                ;;
        esac
    done
    shift $(($OPTIND - 1))

    base=${1##*/}
    if [ ! "$specified" ]; then
        pidfile="/var/run/$base.pid"
    fi

    if [ -n "${pidfile:-}" ] && [ -r "$pidfile" ]; then
        read pid < "$pidfile"
        if [ -n "${pid:-}" ]; then
            if $(kill -0 "${pid:-}" 2> /dev/null); then
                echo "$pid"
                return 0
            elif ps "${pid:-}" >/dev/null 2>&1; then
                echo "$pid"
                return 0 # program is running, but not owned by this user
            else
                return 1 # program is dead and /var/run pid file exists
            fi
        fi
    fi
    if test_external pidof && [ ! "$specified" ]; then
        status="0"
        pidof -o %PPID -x $1 || status="$?"
        # According to http://forums.phoenixlabs.org/showpost.php?p=128365&postcount=18
        # the Synology busybox pidof doesn't recognize the -o and -x options. Then you may take this,
        # but this doesn't work for the watchdog.
        #pidof $1 || status="$?"
        if [ "$status" = 1 ]; then
            return 3 # program is not running
        fi
        return 0
    fi
    if [ "$specified" ]; then
        return 3 # almost certain it's not running
    fi

    if [ -x "$1" ] ; then
        return 3    # daemon is installed, so it is known. But the pidfile
                    # (/var/run/$base.pid) is not existing/empty. So assume
                    # daemon is not running.
    fi

    return 4 # Unable to determine status
}

# start-stop-daemon uses the same algorithm as "pidofproc" above.
killproc () {
    local pidfile sig status base name_param is_term_sig
    pidfile=
    name_param=
    is_term_sig=

    OPTIND=1
    while getopts p: opt ; do
        case "$opt" in
            p)  pidfile="$OPTARG";;
        esac
    done
    shift $(($OPTIND - 1))

    base=${1##*/}
    if [ ! $pidfile ]; then
        name_param="--name $base --pidfile /var/run/$base.pid"
    else
        name_param="--pidfile $pidfile"
        pidfile="/var/run/$base.pid"
    fi

    # Remove leading "-" and "SIG" from sig. If none is given ($2), sig stays empty.
    sig=$(echo ${2:-} | sed -e 's/^-\(.*\)/\1/')
    sig=$(echo $sig | sed -e 's/^SIG\(.*\)/\1/')
    if [ -z "$sig" ] || [ "$sig" = 15 ] || [ "$sig" = TERM ]; then
        is_term_sig="terminate_signal"
    fi
    status=0
    if [ ! "$is_term_sig" ]; then
        if [ -n "$sig" ]; then
          if test_external start-stop-daemon ; then
            start-stop-daemon --stop --signal "$sig" \
                --quiet $name_param || status="$?"
          else
            PID="$(pidofproc $1)" &&
            kill -s $sig $PID ||
            status="$?"
          fi
        else
            # TODO: unnecessary, "if [ -n "$sig" ]" is always true above, because
            # if -z "$sig" then is_term_sig="terminate_signal"
          if test_external start-stop-daemon ; then
            start-stop-daemon --stop \
                --quiet $name_param || status="$?"
          else
            PID="$(pidofproc $1)" &&
            kill $PID ||
            status="$?"
          fi
        fi
    else
      if test_external start-stop-daemon ; then
        start-stop-daemon --stop --quiet \
            --oknodo $name_param || status="$?"
      else
        # send TERM signal
        PID="$(pidofproc $1)" &&
        kill $PID ||
        status="$?"
      fi
    fi
    if [ "$status" = 1 ]; then
        if [ -n "$sig" ]; then
            return 0
        fi
        return 3 # program is not running
    fi

    if [ "$status" = 0 ] && [ "$is_term_sig" ] && [ "$pidfile" ]; then
        pidofproc -p "$pidfile" "$1" >/dev/null || rm -f "$pidfile"
    fi
    return 0
}

# Return LSB status
status_of_proc () {
    local pidfile daemon name status

    pidfile=
    OPTIND=1
    while getopts p: opt ; do
        case "$opt" in
            p)  pidfile="$OPTARG";;
        esac
    done
    shift $(($OPTIND - 1))

    if [ -n "$pidfile" ]; then
        pidfile="-p $pidfile"
    fi
    daemon="$1"
    name="$2"

    status="0"
    pidofproc $pidfile $daemon >/dev/null || status="$?"
    if [ "$status" = 0 ]; then
        log_success_msg "$name is running"
        return 0
    elif [ "$status" = 4 ]; then
        log_failure_msg "could not access PID file for $name"
        return $status
    else
        log_failure_msg "$name is not running"
        return $status
    fi
}

log_use_fancy_output () {
    TPUT=/usr/bin/tput
    EXPR=/usr/bin/expr
    if  [ -t 1 ] &&
    [ "x${TERM:-}" != "x" ] &&
    [ "x${TERM:-}" != "xdumb" ] &&
    [ -x $TPUT ] && [ -x $EXPR ] &&
    $TPUT hpa 60 >/dev/null 2>&1 &&
    $TPUT setaf 1 >/dev/null 2>&1
    then
        [ -z $FANCYTTY ] && FANCYTTY=1 || true
    else
        FANCYTTY=0
    fi
    case "$FANCYTTY" in
        1|Y|yes|true)   true;;
        *)              false;;
    esac
}

log_success_msg () {
    if [ -n "${1:-}" ]; then
        log_begin_msg $@
    fi
    log_end_msg 0
}

log_failure_msg () {
    if [ -n "${1:-}" ]; then
        log_begin_msg $@ "..."
    fi
    log_end_msg 1 || true
}

log_warning_msg () {
    if [ -n "${1:-}" ]; then
        log_begin_msg $@ "..."
    fi
    log_end_msg 255 || true
}

#
# NON-LSB HELPER FUNCTIONS
#
# int get_lsb_header_val (char *scriptpathname, char *key)
get_lsb_header_val () {
        if [ ! -f "$1" ] || [ -z "${2:-}" ]; then
                return 1
        fi
        LSB_S="### BEGIN INIT INFO"
        LSB_E="### END INIT INFO"
        sed -n "/$LSB_S/,/$LSB_E/ s/# $2: \(.*\)/\1/p" $1
}

# int log_begin_message (char *message)
log_begin_msg () {
    if [ -z "${1:-}" ]; then
        return 1
    fi
    /bin/echo -n "$@"
}

# Sample usage:
# log_daemon_msg "Starting GNOME Login Manager" "gdm"
#
# On Debian, would output "Starting GNOME Login Manager: gdm"
# On Ubuntu, would output " * Starting GNOME Login Manager..."
#
# If the second argument is omitted, logging suitable for use with
# log_progress_msg() is used:
#
# log_daemon_msg "Starting remote filesystem services"
#
# On Debian, would output "Starting remote filesystem services:"
# On Ubuntu, would output " * Starting remote filesystem services..."

log_daemon_msg () {
    if [ -z "${1:-}" ]; then
        return 1
    fi
    log_daemon_msg_pre "$@"

    if [ -z "${2:-}" ]; then
        /bin/echo -n "$1:"
        return
    fi

    /bin/echo -n "$1: $2"
    log_daemon_msg_post "$@"
}

# #319739
#
# Per policy docs:
#
#     log_daemon_msg "Starting remote file system services"
#     log_progress_msg "nfsd"; start-stop-daemon --start --quiet nfsd
#     log_progress_msg "mountd"; start-stop-daemon --start --quiet mountd
#     log_progress_msg "ugidd"; start-stop-daemon --start --quiet ugidd
#     log_end_msg 0
#
# You could also do something fancy with log_end_msg here based on the
# return values of start-stop-daemon; this is left as an exercise for
# the reader...
#
# On Ubuntu, one would expect log_progress_msg to be a no-op.
log_progress_msg () {
    if [ -z "${1:-}" ]; then
        return 1
    fi
    /bin/echo -n " $@"
}


# int log_end_message (int exitstatus)
log_end_msg () {
    # If no arguments were passed, return
    if [ -z "${1:-}" ]; then
        return 1
    fi

    local retval
    retval=$1

    log_end_msg_pre "$@"

    # Only do the fancy stuff if we have an appropriate terminal
    # and if /usr is already mounted
    if log_use_fancy_output; then
        RED=$( $TPUT setaf 1)
        YELLOW=$( $TPUT setaf 3)
        NORMAL=$( $TPUT op)
    else
        RED=''
        YELLOW=''
        NORMAL=''
    fi

    if [ $1 -eq 0 ]; then
        echo "."
    elif [ $1 -eq 255 ]; then
        /bin/echo -e " ${YELLOW}(warning).${NORMAL}"
    else
        /bin/echo -e " ${RED}failed!${NORMAL}"
    fi
    log_end_msg_post "$@"
    return $retval
}

log_action_msg () {
    echo "$@."
}

log_action_begin_msg () {
    /bin/echo -n "$@..."
}

log_action_cont_msg () {
    /bin/echo -n "$@..."
}

log_action_end_msg () {
    local end
    log_action_end_msg_pre "$@"
    if [ -z "${2:-}" ]; then
        end="."
    else
        end=" ($2)."
    fi

    if [ $1 -eq 0 ]; then
        echo "done${end}"
    else
        if log_use_fancy_output; then
            RED=$( $TPUT setaf 1)
            NORMAL=$( $TPUT op)
            /bin/echo -e "${RED}failed${end}${NORMAL}"
        else
            echo "failed${end}"
        fi
    fi
    log_action_end_msg_post "$@"
}

# Hooks for /etc/lsb-base-logging.sh
log_daemon_msg_pre () { :; }
log_daemon_msg_post () { :; }
log_end_msg_pre () { :; }
log_end_msg_post () { :; }
log_action_end_msg_pre () { :; }
log_action_end_msg_post () { :; }

FANCYTTY=
[ -e /etc/lsb-base-logging.sh ] && . /etc/lsb-base-logging.sh || true

# End of modified Debian /lib/lsb/init-functions.
################################################################################

# Remember the pglcmd option (necessary for functions that use the original $1)
CMD_OPTION="$1"

# An regular expression for IPv4 addresses
IPv4_REGEX="[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}"

# Function to test if an external application exists.
# Usage: test_external basename_of_the_application
# Returns 0 if base is installed and executable in PATH
# Otherwise returns E_XEXTERNAL
# NOTE 1: "which" should not be used, because it is not available on all
#         systems, e.g. routers.
# NOTE 2: if the application is available externally and as shell builtin,
#         the builtin will be used. This may lead to undefined behaviour.
test_external () {
    IFS=":"
    for PATH_I in $PATH ; do
        [ -x "$PATH_I"/"$1" ] &&
            IFS=$STDIFS &&
            return 0
    done
    IFS=$STDIFS
    return $E_XEXTERNAL
}

test_sendmail () {
    if [ $SENDMAIL ] ; then
        if [ -x "$SENDMAIL" ] || test_external "$SENDMAIL" ; then
            true
        else
            echo "Warning: $SENDMAIL not found."
            echo "Check the SENDMAIL setting."
            return $E_XEXTERNAL
        fi
    fi
}

test_INIT () {
    case "$INIT" in
        '0'|'1')
            true
            ;;
        *)
            log_failure_msg "Error $E_CONFIG: Check the INIT setting."
            exit $E_CONFIG
            ;;
    esac
}

test_CRON () {
    case "$CRON" in
        '0'|'1')
            true
            ;;
        *)
            log_failure_msg "Error $E_CONFIG: Check the CRON setting."
            exit $E_CONFIG
            ;;
    esac
}

test_VERBOSE () {
    case "$VERBOSE" in
        '0'|'1'|'2')
            true
            ;;
        *)
            log_failure_msg "Error $E_CONFIG: Check the VERBOSE setting."
            exit $E_CONFIG
            ;;
    esac
}

test_DAEMON () {
    [ -x "$DAEMON" ] || {
            log_failure_msg "Error $E_XBIN: $DAEMON not installed."
            log_failure_msg "Could not detect $DESC daemon $NAME."
            log_failure_msg "Install it in PATH ($PATH) or specify DAEMON in $CMD_CONF."
            exit $E_XBIN
    }
}

test_CMD_PATHNAME () {
    [ -x "$CMD_PATHNAME" ] || {
        log_failure_msg "$0: $CMD_PATHNAME not installed."
        exit $E_XBIN
    }
}

test_LOG_SYSLOG () {
    case "$LOG_SYSLOG" in
        '0'|'1')
            true
            ;;
        *)
            log_failure_msg "Error $E_CONFIG: Check the LOG_SYSLOG setting."
            exit $E_CONFIG
            ;;
    esac
}

test_IPTABLES_TARGET () {
    case "$IPTABLES_TARGET" in
        'NFQUEUE')
            [ "$NFQUEUE_NUMBER" -ge 0 ] && [ "$NFQUEUE_NUMBER" -le 65535 ] || {
                log_failure_msg "Error $E_CONFIG: Check the NFQUEUE_NUMBER setting."
                exit $E_CONFIG
                }
            ;;
        # although QUEUE is deprecated, it is the same as NFQUEUE 0.
        'QUEUE')
            true
            ;;
        *)
            log_failure_msg "Error $E_CONFIG: Check the IPTABLES_TARGET setting."
            exit $E_CONFIG
            ;;
    esac
}

test_REJECT () {
    case "$REJECT" in
        '0')
            true
            ;;
        '1')
            # No test for REJECT_MARK, yet
            # No test for REJECT_IN. Valid: all iptables targets
            # No test for REJECT_OUT. Valid: all iptables targets
            # No test for REJECT_FWD. Valid: all iptables targets
            # Transition REJECT_FW REJECT_FWD.
            # If old var is not-empty, but new var is empty, then take old value.
            [ -z "$REJECT_FW" ] || {
                REJECT_FWD=${REJECT_FWD:-${REJECT_FWD}}
                log_warning_msg "REJECT_FW is deprecated. Use REJECT_FWD instead."
                }
            true
            ;;
        *)
            log_failure_msg "Error $E_CONFIG: Check the REJECT setting."
            exit $E_CONFIG
            ;;
    esac
}

test_ACCEPT () {
    case "$ACCEPT" in
        '0')
            true
            ;;
        '1')
            # No test for ACCEPT_MARK, yet
            true
            ;;
        *)
            log_failure_msg "Error $E_CONFIG: Check the ACCEPT setting."
            exit $E_CONFIG
            ;;
    esac
}

test_BLOCKLISTS_DIR () {
    [ -d "$BLOCKLISTS_DIR" ] || {
        echo -n "Creating missing directory $BLOCKLISTS_DIR ..."
        mkdir -p $BLOCKLISTS_DIR && echo "."
    } || {
        log_failure_msg "Error $E_XCD: Missing directory $BLOCKLISTS_DIR."
        log_failure_msg "Check the BLOCKLISTS_DIR setting."
        exit $E_XCD
    }
}

test_CMD_LOG () {
    [ -d "$(dirname $CMD_LOG)" ] || {
        echo -n "Creating missing directory $(dirname $CMD_LOG) ..."
        mkdir -p "$(dirname $CMD_LOG)" && echo "."
    } || {
        log_failure_msg "Error $E_XCD: Missing directory $(dirname $CMD_LOG)."
        log_failure_msg "Check the CMD_LOG setting."
        exit $E_XCD
    }
}

test_PIDFILE () {
    [ -d "$(dirname $PIDFILE)" ] || {
        log_failure_msg "Error $E_XCD: Missing directory $(dirname $PIDFILE)."
        log_failure_msg "$NAME needs a directory to write its pidfile to!"
        log_failure_msg "Check the PIDFILE setting."
        exit $E_XCD
    }
}

test_WD_PID () {
    [ -d "$(dirname $WD_PID)" ] || {
        log_failure_msg "Error $E_XCD: Missing directory $(dirname $WD_PID)."
        log_failure_msg "$(basename $WD_PATHNAME) needs a directory to write its pidfile to!"
        log_failure_msg "Check the WD_PID setting."
        exit $E_XCD
    }
}

test_WD_PATHNAME () {
    [ -x "$WD_PATHNAME" ] || {
        log_failure_msg "Error $E_CONFIG: Check the WD_PATHNAME setting."
        log_failure_msg "Not starting $(basename $WD_PATHNAME)."
        exit $E_CONFIG
        }
}

test_IPTABLES_VARS () {
    case "$IPTABLES_SETTINGS" in
        '0')
            true
            ;;
        '1')
            case "$IPTABLES_ACTIVATION" in
                '0'|'1'|'2')
                    true
                    ;;
                *)
                    log_failure_msg "Error $E_CONFIG: Check the IPTABLES_ACTIVATION setting."
                    exit $E_CONFIG
                    ;;
            esac
            case "$WHITE_LOCAL" in
                '0'|'1'|'2')
                    true
                    ;;
                *)
                    log_failure_msg "Error $E_CONFIG: Check the WHITE_LOCAL setting."
                    exit $E_CONFIG
                    ;;
            esac
            # No test for WHITE_TCP_IN. Valid: port number or associated service name
            # No test for WHITE_UDP_IN.
            # No test for WHITE_TCP_OUT.
            # No test for WHITE_UDP_OUT.
            # No test for WHITE_TCP_FWD.
            # Transition WHITE_TCP_FORWARD WHITE_TCP_FWD.
            # If old var is not-empty, but new var is empty, then take old value.
            [ -z "$WHITE_TCP_FORWARD" ] || {
                WHITE_TCP_FWD=${WHITE_TCP_FWD:-${WHITE_TCP_FORWARD}}
                log_warning_msg "WHITE_TCP_FORWARD is deprecated. Use WHITE_TCP_FWD instead."
                }
            # No test for WHITE_UDP_FWD.
            # Transition WHITE_UDP_FORWARD WHITE_UDP_FWD.
            # If old var is not-empty, but new var is empty, then take old value.
            [ -z "$WHITE_UDP_FORWARD" ] || {
                WHITE_UDP_FWD=${WHITE_UDP_FWD:-${WHITE_UDP_FORWARD}}
                log_warning_msg "WHITE_UDP_FORWARD is deprecated. Use WHITE_UDP_FWD instead."
                }
            # No test for WHITE_IP_IN. Valid: network name, a hostname (please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea), a network IP address (with /mask), or a plain IP address.
            # No test for WHITE_IP_OUT.
            # No test for WHITE_IP_FWD.
            # Transition WHITE_IP_FORWARD WHITE_IP_FWD.
            # If old var is not-empty, but new var is empty, then take old value.
            [ -z "$WHITE_IP_FORWARD" ] || {
                WHITE_IP_FWD=${WHITE_IP_FWD:-${WHITE_IP_FORWARD}}
                log_warning_msg "WHITE_IP_FORWARD is deprecated. Use WHITE_IP_FWD instead."
                }

            # No test for INTERFACES.
            # No test for IP_REMOVE. Valid: all regular expressions for grep
            ;;
        '2')
            [ -d "$IPTABLES_CUSTOM_DIR" ] || {
                log_failure_msg "Error $E_XCD: Could not find $IPTABLES_CUSTOM_DIR."
                log_failure_msg "Check the IPTABLES_CUSTOM_DIR setting."
                exit $E_XCD
            }
            ;;
        *)
            log_failure_msg "Error $E_CONFIG: Check the IPTABLES_SETTINGS setting."
            exit $E_CONFIG
            ;;
    esac
}

# Test if user is root
test_root () {
    case "$(id -ru)" in
        '0')
            true
            ;;
        *)
            log_failure_msg "Error $E_NOTROOT: This program must be run as root."
            exit $E_NOTROOT
            ;;
    esac
}

################################################################################
# Functions

# Try to download TESTHOST before blocklist updates.
# If this fails, pglcmd assumes that there is no network available, and thus
# aborts the update. The default configured site is also used to determine the
# user friendly blocklist names for iblocklist.com URLs.
test_net () {
    test_external wget || {
        log_failure_msg "Error $E_XEXTERNAL: wget not installed."
        exit $E_XEXTERNAL
        }
    $WGET_OPTS -O "${BLOCKLISTS_DIR}/lists.xml~" $TESTHOST    # Don't quote WGET_OPTS!
    if [ "$?" -ne 0 ] ; then
        log_failure_msg "Error $E_NETWORK_DOWN: No connection to $TESTHOST. Aborting!"
        exit $E_NETWORK_DOWN
    fi
    if [ "$( wc -l < ${BLOCKLISTS_DIR}/lists.xml~ )" -gt 0 ] ; then
        mv ${BLOCKLISTS_DIR}/lists.xml~ ${BLOCKLISTS_DIR}/lists.xml
    fi
}

# Calculate the routing prefix and its bits length for a given IP and subnetmask
# (convert ifconfig output to iptables output)
# e.g. IP=192.168.178.21 and SUBNETMASK=255.255.255.0 get 192.168.178.0/24
set_NETWORK () {
    local NETIP1 NETIP2 NETIP3 NETIP4 MASK1 MASK2 MASK3 MASK4 BITS
    [ $# -eq 2 ] || { echo "Internal error: Usage set_NETWORK IP SUBNETMASK, arguments were: \"${@}\"." ; exit 1 ; }
    echo $1 | grep -Eq "$IPv4_REGEX" || { echo "Internal error: $1 is not a valid IP!" ; exit 1 ; }
    echo $2 | grep -Eq "$IPv4_REGEX" || { echo "Internal error: $2 is not a valid SUBNETMASK!" ; exit 1 ; }

    IFS=.
    i=1
    for OCTET in $1 ; do
        # Don't know why eval is necessary, but it is.
        eval NETIP${i}="${OCTET}"
        i=$(($i+1))
    done
    i=1
    for OCTET in $2 ; do
        eval MASK${i}="${OCTET}"
        i=$(($i+1))
    done
    IFS=$STDIFS

    # Use bitwise ANDing for the routing prefix
    NET1=$(( $NETIP1 & $MASK1 ))
    NET2=$(( $NETIP2 & $MASK2 ))
    NET3=$(( $NETIP3 & $MASK3 ))
    NET4=$(( $NETIP4 & $MASK4 ))

    # Haven't found a way to calculate this in a shell script. So using this table
    # for the bits length
    case $2 in
        255.0.0.0)        BITS="/8" ;;
        255.128.0.0)      BITS="/9" ;;
        255.192.0.0)      BITS="/10" ;;
        255.224.0.0)      BITS="/11" ;;
        255.240.0.0)      BITS="/12" ;;
        255.248.0.0)      BITS="/13" ;;
        255.252.0.0)      BITS="/14" ;;
        255.254.0.0)      BITS="/15" ;;
        255.255.0.0)      BITS="/16" ;;
        255.255.128.0)    BITS="/17" ;;
        255.255.192.0)    BITS="/18" ;;
        255.255.224.0)    BITS="/19" ;;
        255.255.240.0)    BITS="/20" ;;
        255.255.248.0)    BITS="/21" ;;
        255.255.252.0)    BITS="/22" ;;
        255.255.254.0)    BITS="/23" ;;
        255.255.255.0)    BITS="/24" ;;
        255.255.255.128)  BITS="/25" ;;
        255.255.255.192)  BITS="/26" ;;
        255.255.255.224)  BITS="/27" ;;
        255.255.255.240)  BITS="/28" ;;
        255.255.255.248)  BITS="/29" ;;
        255.255.255.252)  BITS="/30" ;;
        255.255.255.255)  BITS="" ;;
        *) { echo "Internal error: Cannot calculate bits length for ${2}!" ; exit 1 ; } ;;
    esac
    echo ${NET1}.${NET2}.${NET3}.${NET4}${BITS}
}

white_local () {
    # If CHAINS is empty/not set, then set it to "all". Replace all with the single names.
    CHAINS=${CHAINS:-all}
    [ "$CHAINS" != all ] || CHAINS="INPUT OUTPUT FORWARD"

    if [ "$WHITE_LOCAL" -ne 0 ] ; then
        # Whitelist loopback interface
        # TODO: Only do this if checking the loopback interface is enabled
        # (although otherwise just no traffic will ever get to the pgl_ chain were this rule is placed).
        # Do this only once on (re)start
        if [ "$CMD_OPTION" = start ] || [ "$CMD_OPTION" = restart ] ; then
            echo -n "..Allowing loopback traffic:"
            for CHAIN in $CHAINS ; do
                case $CHAIN in
                INPUT)
                    PGL_CHAIN="$IPTABLES_IN"
                    CMD_LOOP="-i lo"
                    ;;
                OUTPUT)
                    PGL_CHAIN="$IPTABLES_OUT"
                    CMD_LOOP="-o lo"
                    ;;
                FORWARD)
                    continue
                    ;;
                *)
                    echo " Unknown CHAIN $CHAIN specified."
                    exit 1
                    ;;
                esac
                echo -n " $CHAIN"
                # Insert whitelisting rules for whole loopback interface
                iptables -I $PGL_CHAIN $CMD_LOOP -j $IPTABLES_TARGET_WHITELISTING || fail_insert_iptables
            done
            log_end_msg 0
        fi

        # Whitelist the DNS server(s).
        # For this /etc/resolv.conf and the output of "iptables -L -nv" is scanned for certain patterns.
        if [ -f /etc/resolv.conf ] ; then
            # Get the DNS server's IP
            DNS_IPS="$( grep nameserver /etc/resolv.conf | grep -Eo "$IPv4_REGEX" )"

            # Insert whitelisting rules for DNS server.
            for CHAIN in $CHAINS ; do
                case $CHAIN in
                INPUT)
                    continue
                    ;;
                OUTPUT)
                    PGL_CHAIN="$IPTABLES_OUT"
                    ;;
                FORWARD)
                    PGL_CHAIN="$IPTABLES_FWD"
                    ;;
                esac

                for IP in $DNS_IPS ; do
                    echo -n "..Allowing $CHAIN traffic to DNS server $IP"
                    # Whitelist DNS server, if we do an inital start/restart (quick
                    # test of $CMD_OPTION) or if the DNS server is not already whitelisted
                    # (time-consuming test of iptables output).
                    # With other words:
                    # pglcmd start/restart: always whitelist DNS server
                    # if-up: first check if DNS server is already whitelisted.
                    if [ "$CMD_OPTION" = start ] || [ "$CMD_OPTION" = restart ] ||
                    ! iptables -nv -L $PGL_CHAIN | grep -F "$IP " | grep $IPTABLES_TARGET_WHITELISTING > /dev/null 2>&1 ; then
                        iptables -I $PGL_CHAIN --destination $IP -j $IPTABLES_TARGET_WHITELISTING
                        RETVAL=$?
                        log_end_msg $RETVAL
                        [ "$RETVAL" = 0 ] || exit $E_IPTABLES
                    else
                        echo ", already done."
                    fi
                done
            done
        fi
    fi

    if [ "$WHITE_LOCAL" -eq 1 ] ; then
        echo "..Allowing LAN traffic ..."
        # Automatically whitelist LAN of all up interfaces
        # TODO: Only do this if checking the corresponding interface is enabled
        # For this the output of "ifconfig" and "iptables -L -nv" is scanned for certain patterns

        # Get IPs of interfaces that are up
        LOCAL_IPS="$(ifconfig |
            grep -Eo "inet addr:$IPv4_REGEX" |
            grep -Eo "$IPv4_REGEX" )"
        for IP in $LOCAL_IPS ; do
            case $IP in
            127.*)
                # IP is a loopback IP. This was already done above.
                ;;
            *)
                # For all other IPs
                # Get the corresponding subnetmask
                # Use grep -F followed by a blank to match exactly a specific IP!
                SUBNETMASK="$(ifconfig |
                    grep -F "inet addr:${IP} " |
                    grep -Eo "Mask:${IPv4_REGEX}" |
                    grep -Eo "$IPv4_REGEX" )"
                # Set NETWORK as it will be shown by iptables
                NETWORK="$(set_NETWORK $IP $SUBNETMASK)"

                # Insert whitelisting rules for LAN with SUBNETMASK.
                for CHAIN in $CHAINS ; do
                    case $CHAIN in
                    INPUT)
                        PGL_CHAIN="$IPTABLES_IN"
                        CMD_WHITE_IP="--source ${IP}/${SUBNETMASK}"
                        DIRECTION="from"
                        ;;
                    OUTPUT)
                        PGL_CHAIN="$IPTABLES_OUT"
                        CMD_WHITE_IP="--destination ${IP}/${SUBNETMASK}"
                        DIRECTION="to"
                        ;;
                    FORWARD)
                        PGL_CHAIN="$IPTABLES_FWD"
                        # To whitelist all local FORWARD traffic add whitelisting rules from every single
                        # interface to every other interface.
                        for IP2 in $LOCAL_IPS ; do
                            # Skip if interface is loopback.
                            [ "$(echo "$IP2" | head -c 4)" = 127. ] && continue
                            # Get the corresponding subnetmask
                            # Use grep -F followed by a blank to match exactly a specific IP!
                            SUBNETMASK2="$(ifconfig |
                                grep -F "inet addr:${IP2} " |
                                grep -Eo "Mask:$IPv4_REGEX" |
                                grep -Eo "$IPv4_REGEX" )"
                            # Set NETWORK2 as it will be shown by iptables
                            NETWORK2="$(set_NETWORK $IP2 $SUBNETMASK2)"

                            echo -n "....$CHAIN from $NETWORK to $NETWORK2"
                            if [ "$CMD_OPTION" = start ] || [ "$CMD_OPTION" = restart ] ||
                            ! iptables -nv -L $PGL_CHAIN | grep "$IPTABLES_TARGET_WHITELISTING .* $NETWORK *$NETWORK2" > /dev/null 2>&1 ; then
                                iptables -I $PGL_CHAIN --source ${IP}/${SUBNETMASK} --destination ${IP2}/${SUBNETMASK2} -j $IPTABLES_TARGET_WHITELISTING
                                RETVAL=$?
                                log_end_msg $RETVAL
                                [ "$RETVAL" = 0 ] || exit $E_IPTABLES
                            else
                                echo ", already done."
                            fi
                        done
                        continue
                        ;;
                    esac
                    echo -n "....$CHAIN $DIRECTION $NETWORK"
                    # Whitelist LAN, if we do an inital start/restart (quick
                    # test of $CMD_OPTION) or if the LAN is not already whitelisted
                    # (time-consuming test of iptables output).
                    # With other words:
                    # pglcmd start/restart: always whitelist LAN
                    # if-up: first check iptables output if LAN is already whitelisted.
                    if [ "$CMD_OPTION" = start ] || [ "$CMD_OPTION" = restart ] ||
                    ! iptables -nv -L $PGL_CHAIN | grep "$IPTABLES_TARGET_WHITELISTING .* $NETWORK" > /dev/null 2>&1 ; then
                        iptables -I $PGL_CHAIN $CMD_WHITE_IP -j $IPTABLES_TARGET_WHITELISTING
                        RETVAL=$?
                        log_end_msg $RETVAL
                        [ "$RETVAL" = 0 ] || exit $E_IPTABLES
                    else
                        echo ", already done."
                    fi
                done
                ;;
            esac
        done
    echo "..LAN traffic allowed."
    fi
}

# Function to be executed if iptables insert command fails:
# removes all iptables rules again and aborts
fail_insert_iptables () {
    log_end_msg $?
    # Try to build the REMOVE_SCRIPT in any case
    cat $REMOVE_SCRIPT >> ${REMOVE_SCRIPT}.tmp &&
    mv ${REMOVE_SCRIPT}.tmp $REMOVE_SCRIPT
    delete_iptables
    exit $E_IPTABLES
}

# Set REMOVE_SCRIPT needed by insert_iptables and delete_iptables
REMOVE_SCRIPT="$MASTER_BLOCKLIST_DIR/.${CMD_NAME}.iptables.remove.sh"

# Function that inserts the iptables rules
insert_iptables () {
    # test_IPTABLES_VARS # Already tested in do_start
    test_external iptables || {
        log_failure_msg "Error $E_XEXTERNAL: iptables not installed."
        exit $E_XEXTERNAL
        }
    if [ -f "$REMOVE_SCRIPT" ] ; then
        echo -n "Old iptables remove script $REMOVE_SCRIPT exists. Strange. Executing now and then removing it"
        sh $REMOVE_SCRIPT
        rm $REMOVE_SCRIPT
        log_end_msg $?
    fi
    case "$IPTABLES_SETTINGS" in
    '0')
        test_VERBOSE
        if [ "$VERBOSE" -eq 1 ] ; then
            log_warning_msg "$(basename $0) is configured not to insert iptables rules."
        fi
        ;;
    # Place iptables rules in separate iptables chains (pgl_in, pgl_out and pgl_fwd).
    '1')
        echo "Inserting iptables ..."

        # Variable tests
        test_IPTABLES_TARGET
        test_REJECT
        test_ACCEPT

        # Set constant variables for iptables commands
        case "$IPTABLES_TARGET" in
        NFQUEUE)
            IPTABLES_TARGET_BLOCK="$IPTABLES_TARGET --queue-num $NFQUEUE_NUMBER"
            ;;
        QUEUE)
            IPTABLES_TARGET_BLOCK="$IPTABLES_TARGET"
            ;;
        esac

        # If CHAINS is empty/not set, then set it to "all". Replace all with the single names.
        CHAINS=${CHAINS:-all}
        [ "$CHAINS" != all ] || CHAINS="INPUT OUTPUT FORWARD"

        # Prepare and issue iptables commands for every chain.
        for CHAIN in $CHAINS ; do
            echo "..Setting up iptables for $CHAIN:"
            case $CHAIN in
            INPUT)
                PGL_CHAIN="$IPTABLES_IN"
                WHITE_TCP="$WHITE_TCP_IN"
                WHITE_UDP="$WHITE_UDP_IN"
                CMD_WHITE_IP="--source"
                WHITE_IP="$WHITE_IP_IN"
                CMD_ALLOW="--src-range"
                ALLOW_FILE="$ALLOW_IN"
                REJECT_TARGET="$REJECT_IN"
                ;;
            OUTPUT)
                PGL_CHAIN="$IPTABLES_OUT"
                WHITE_TCP="$WHITE_TCP_OUT"
                WHITE_UDP="$WHITE_UDP_OUT"
                CMD_WHITE_IP="--destination"
                WHITE_IP="$WHITE_IP_OUT"
                CMD_ALLOW="--dst-range"
                ALLOW_FILE="$ALLOW_OUT"
                REJECT_TARGET="$REJECT_OUT"
                ;;
            FORWARD)
                PGL_CHAIN="$IPTABLES_FWD"
                WHITE_TCP="$WHITE_TCP_FWD"
                WHITE_UDP="$WHITE_UDP_FWD"
                CMD_WHITE_IP="--source --destination"
                WHITE_IP="$WHITE_IP_FWD"
                CMD_ALLOW="--src-range --dst-range"
                ALLOW_FILE="$ALLOW_FWD"
                REJECT_TARGET="$REJECT_FWD"
                ;;
            *)
                echo " Unknown CHAIN $CHAIN specified."
                exit 1
                ;;
            esac

            # Create new pgl_ chain and remember iptables remove rules
            echo -n "....Creating chain" &&
                iptables -N $PGL_CHAIN &&
                echo "iptables -F $PGL_CHAIN" >> $REMOVE_SCRIPT &&
                echo "iptables -X $PGL_CHAIN" >> $REMOVE_SCRIPT ||
                fail_insert_iptables

            # Insert NFQUEUE rule.
            echo -n " and inserting $IPTABLES_TARGET rule" &&
                iptables -I $PGL_CHAIN -j $IPTABLES_TARGET_BLOCK &&
                log_end_msg "$?" ||
                fail_insert_iptables

            # Port Whitelisting
            [ -z "$WHITE_TCP" ] && [ -z "$WHITE_UDP" ] ||
                {
                echo -n "....Whitelisting ports" &&
                for PORT in $WHITE_TCP ; do
                    iptables -I ${PGL_CHAIN} -p tcp --dport $PORT -j $IPTABLES_TARGET_WHITELISTING || fail_insert_iptables
                done &&
                for PORT in $WHITE_UDP ; do
                    iptables -I ${PGL_CHAIN} -p udp --dport $PORT -j $IPTABLES_TARGET_WHITELISTING || fail_insert_iptables
                done &&
                log_end_msg "$?"
                }

            # IP Whitelisting
            [ -n "$WHITE_IP" ] &&
                echo -n "....Whitelisting IPs" &&
                for IP in $WHITE_IP ; do
                    # Add whitelisting rule
                    # (add 2 rules in the FORWARD chain: once for --source, once for --destination)
                    for CMD in $CMD_WHITE_IP ; do
                        iptables -I $PGL_CHAIN $CMD $IP -j $IPTABLES_TARGET_WHITELISTING || fail_insert_iptables
                    done
                done &&
                log_end_msg "$?"

            # IP ranges whitelisting
            if [ -f "$ALLOW_FILE" ] ; then
                echo -n "....Whitelisting IP ranges"
                # Read the non-comment|not-empty lines from the allow file:
                ALLOW="$(grep -Ev "^[[:space:]]*#|^[[:space:]]*$" $ALLOW_FILE)"
                IFS=$'
' # Set IFS to newline only for LINE
                for LINE in $ALLOW ; do
                    IPRANGE_BEGIN="$(echo $LINE | grep -Eo "$IPv4_REGEX" | head -n1)"
                    IPRANGE_END="$(echo $LINE | grep -Eo "$IPv4_REGEX" | tail -n1)"
                    # Reset IFS for CMD
                    IFS=$STDIFS
                    for CMD in $CMD_ALLOW ; do
                        # Add whitelisting rule
                        # (add 2 rules in the FORWARD chain: once for --src-range, once for --dst-range)
                        iptables -I $PGL_CHAIN -m iprange $CMD $IPRANGE_BEGIN-$IPRANGE_END -j $IPTABLES_TARGET_WHITELISTING || {
                            # If iptables insertion failed assume that the line is malformed.
                            # Comment this line out.
                            sed -i "s|^$LINE$|# Malformed line commented out by $(basename $0): &|" $ALLOW_FILE
                            log_failure_msg "Commented out malformed line \"$LINE\" in $ALLOW_FILE."
                            fail_insert_iptables
                            }
                    done
                    IFS=$'
' # Set IFS to newline only again for the next LINE
                done
                # Reset IFS
                IFS=$STDIFS
                log_end_msg "$?"
            fi

            # Block "Marked block" packages: "Marked block" packages are sent back
            # to the head of the chain again (NF_REPEAT repeats the hook function)
            # by pgld. Block them at the head of the pglcmd_* chains.
            # Alternatively they could be blocked at the head of the
            # INPUT/OUTPUT/FORWARD chains, but I decided against that in order to
            # keep those chains cleaner. It has to be made sure that the MARK of the
            # packets is not changed by other iptables rules.
            if [ "$REJECT" -eq 1 ] ; then
                echo -n "....Inserting block rule"
                iptables -I $PGL_CHAIN -m mark --mark $REJECT_MARK -j $REJECT_TARGET || fail_insert_iptables
                # Log "Marked block" packages: The log-iptables-rules should be
                # placed directly before the block-iptables-rules (i.e. Insert them
                # directly after them)
                if [ -n "$LOG_IPTABLES" ] ; then    # string is not empty
                    echo -n " and log rule"
                    iptables -I $PGL_CHAIN -m mark --mark $REJECT_MARK -j $LOG_IPTABLES || fail_insert_iptables
                fi
                log_end_msg "$?"
            fi
        done

        # Automatically whitelist LAN of all up interfaces, loopback interface
        # and DNS server(s) (if configured)
        white_local

        # If custom iptables insertion scripts exist, execute them:
        CUSTOM_INSERT_SCRIPTS="$(find $IPTABLES_CUSTOM_DIR -maxdepth 1 -type f -name "*insert.sh" -print0 | xargs -0r)"
        [ -z "$CUSTOM_INSERT_SCRIPTS" ] || {
            for FILE in $CUSTOM_INSERT_SCRIPTS ; do
                echo -n "..Executing custom iptables insertion script $FILE"
                sh $FILE
                log_end_msg "$?"
            done
            }

        # Chain activation
        case "$IPTABLES_ACTIVATION" in
        '0')
            if [ "$VERBOSE" -eq 1 ] ; then
                echo "..Not activating chains."
            fi
            ;;
        '1'|'2')
            echo "..Activating chains:"
            case "$IPTABLES_ACTIVATION" in
            '1')
                CMD_STATE="-m state --state NEW"
                ;;
            '2')
                CMD_STATE=""
                ;;
            esac
            case "$ACCEPT" in
            '0')
                CMD_MARK_ACCEPT=""
                ;;
            '1')
                # Send all NEW packets, except the "marked accept" packets, to the pglcmd_* chains.
                # From there "marked" packets are sent back to the head of the chain again
                # (NF_REPEAT repeats the hook function). Thus "marked accept" packets traverse to
                # the rest of the iptables setup.
                # Problem: If another rule changes the MARK the packet will loop forever.
                CMD_MARK_ACCEPT="-m mark ! --mark $ACCEPT_MARK"
                ;;
            esac

            # If INTERFACES is empty/not set, then set it to "all".
            INTERFACES=${INTERFACES:-all}

            # Send traffic of the specified interfaces to the pgl chains.
            for INTERFACE in $INTERFACES ; do
                for CHAIN in $CHAINS ; do
                    case $CHAIN in
                    INPUT)
                        PGL_CHAIN="$IPTABLES_IN"
                        ;;
                    OUTPUT)
                        PGL_CHAIN="$IPTABLES_OUT"
                        ;;
                    FORWARD)
                        PGL_CHAIN="$IPTABLES_FWD"
                        ;;
                    esac

                    # Activate iptables chain and remember iptables remove rules
                    if [ "$INTERFACE" = all ] ; then
                        echo  "....$CHAIN"
                        iptables -I $CHAIN $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN &&
                        echo "iptables -D $CHAIN $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN" >> ${REMOVE_SCRIPT}.tmp ||
                        fail_insert_iptables
                    else
                        echo  "....$CHAIN on $INTERFACE"
                        case $CHAIN in
                        INPUT)
                            iptables -I $CHAIN -i $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN &&
                            echo "iptables -D $CHAIN -i $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN" >> ${REMOVE_SCRIPT}.tmp ||
                            fail_insert_iptables
                            ;;
                        OUTPUT)
                            iptables -I $CHAIN -o $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN &&
                            echo "iptables -D $CHAIN -o $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN" >> ${REMOVE_SCRIPT}.tmp ||
                            fail_insert_iptables
                            ;;
                        FORWARD)
                            iptables -I $CHAIN -i $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN &&
                            echo "iptables -D $CHAIN -i $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN" >> ${REMOVE_SCRIPT}.tmp &&
                            iptables -I $CHAIN -o $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN &&
                            echo "iptables -D $CHAIN -o $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN" >> ${REMOVE_SCRIPT}.tmp ||
                            fail_insert_iptables
                            ;;
                        # Valid CHAINs was already tested above. No test needed here.
                        esac
                    fi
                done
            done
            echo "..Chains activated."
            # Build the REMOVE_SCRIPT
            cat $REMOVE_SCRIPT >> ${REMOVE_SCRIPT}.tmp &&
                mv ${REMOVE_SCRIPT}.tmp $REMOVE_SCRIPT ||
                { echo "Error: Could not build the iptables remove script!" ; fail_insert_iptables ; }
            ;;
        esac
        echo "Iptables inserted."
        ;;
    '2')
        CUSTOM_INSERT_SCRIPTS="$(find $IPTABLES_CUSTOM_DIR -maxdepth 1 -type f -name "*insert.sh" -print0 | xargs -0r)"
        [ -z "$CUSTOM_INSERT_SCRIPTS" ] || {
            for FILE in $CUSTOM_INSERT_SCRIPTS ; do
                echo -n "  Executing custom iptables insertion script $FILE ..."
                sh $FILE && log_end_msg $? || fail_insert_iptables
                log_end_msg $?
            done
            }
        ;;
    esac
}

# Function that deletes the iptables rules
# iptables command errors are ignored, because removing an already removed rule
# causes an error, although this is no problem for us.
delete_iptables () {
    test_IPTABLES_VARS
    test_external iptables || {
        log_failure_msg "Error $E_XEXTERNAL: iptables not installed."
        exit $E_XEXTERNAL
        }
    echo "Deleting iptables ..."

    # Execute custom iptables remove scripts if configured
    if [ "$IPTABLES_SETTINGS" -gt 0 ] ; then
        # If custom iptables remove scripts exist, execute them:
        CUSTOM_REMOVE_SCRIPTS="$(find $IPTABLES_CUSTOM_DIR -maxdepth 1 -type f -name "*remove.sh" -print0 | xargs -0r)"
        [ -z "$CUSTOM_REMOVE_SCRIPTS" ] || {
            for FILE in $CUSTOM_REMOVE_SCRIPTS ; do
                echo -n "..Executing custom iptables remove script $FILE"
                sh $FILE
                log_end_msg $?
            done
            }
    fi
    if [ -f "$REMOVE_SCRIPT" ] ; then
        # Delete previously inserted iptables rules in any case. REMOVE_SCRIPT is created in insert_iptables
        echo -n "..Executing iptables remove script $REMOVE_SCRIPT"
        sh $REMOVE_SCRIPT
        log_end_msg $?
        # Remove REMOVE_SCRIPT in any case! It's not meant to be used several times.
        echo -n "..Removing iptables remove script $REMOVE_SCRIPT"
        rm $REMOVE_SCRIPT
        log_end_msg $?
    fi
    echo "Iptables deleted."
}

# md5sum of all relevant parts for building the MASTER_BLOCKLIST
set_md5sum () {
    SUM="$(
        echo $IP_REMOVE
        [ -f "$BLOCKLISTS_LIST" ] && md5sum $BLOCKLISTS_LIST
        [ -f "$MASTER_BLOCKLIST" ] && md5sum $MASTER_BLOCKLIST
        set_BLOCKLISTS_LOCAL
        for LIST in $BLOCKLISTS_LOCAL ; do
            [ -f "$LIST" ] && md5sum $LIST
        done
        )"
    MD5SUM="$(echo $SUM | md5sum | cut -c -32)"
}

# All blocklists in the LOCAL_BLOCKLIST_DIR directory (except those in
# subdirectories, or which end in "~" or start with ".") are merged in the
# MASTER_BLOCKLIST and thus used by pgld.
# Spaces in listnames are not allowed.
set_BLOCKLISTS_LOCAL () {
    BLOCKLISTS_LOCAL=""
    [ -d "$LOCAL_BLOCKLIST_DIR" ] &&
    BLOCKLISTS_LOCAL="$(find -L $LOCAL_BLOCKLIST_DIR -maxdepth 1 -type f \
        ! -name "*~" \
        ! -name ".*" |
        tr "\n" " ")"
}

# Function that starts the watchdog
do_start_wd () {
    # Start pglcmd.wd.
    echo -n "Starting $(basename $WD_PATHNAME)"
    test_WD_PATHNAME
    test_WD_PID

    # Test WD_NICE setting.
    [ "$WD_NICE" -ge -20 ] && [ "$WD_NICE" -le 19 ] || {
        log_failure_msg " Error $E_CONFIG: Check the WD_NICE setting."
        exit $E_CONFIG
        }

    # Start pglcmd.wd in the background. Therefore no real check possible if this succeeded.
    if test_external start-stop-daemon ; then
        # Use start-stop-daemon
        # Start watchdog in the background with "-b"
        # Note: use -N for nice level, not -n as per LSB
        #start-stop-daemon -b -N $WD_NICE -p $WD_PID --exec $WD_PATHNAME --start --
        # Use -x and -S to avoid problems on synology
        start-stop-daemon -b -N $WD_NICE -p $WD_PID -x $WD_PATHNAME -S --
    else
        # LSB, start pglcmd.wd in the background with "&".
        start_daemon -n $WD_NICE -p $WD_PID $WD_PATHNAME &
    fi
    # TODO: kill -0 "$(pidofproc $WD_PATHNAME)" > /dev/null 2>&1
    RETVAL=$?
    log_end_msg $RETVAL
}

# Function that stops the watchdog
do_stop_wd () {
    # Stop pglcmd.wd
    echo -n "Stopping $(basename $WD_PATHNAME)"
    # Watchdog does not react to the TERM signal, while he´s sleeping.
    # Therefore send a KILL. The pidfile has to be removed manually then, see below!
    PID_OPT=""
    [ -z "$WD_PID" ] || PID_OPT="-p $WD_PID"
    killproc "$PID_OPT" "$WD_PATHNAME" -KILL

    # Verify that the watchdog is really not running.
    kill -0 "$(pidof $WD_PATHNAME)" > /dev/null 2>&1
    # If old process is not running, remember success and break.
    if [ "$?" -eq 0 ] ; then
        # Process is still running
        RETVAL=1
    else
        rm -f $WD_PID
        RETVAL=0
    fi

    log_end_msg $RETVAL
}

# Function that starts daemon and watchdog
do_start () {
    test_DAEMON
    # Check if daemon is already running
    status_of_proc $DAEMON $NAME > /dev/null 2>&1
    RETVAL=$?
    case "$RETVAL" in
        0)  # Daemon is running
            log_success_msg "$NAME is already running, doing nothing."
            ;;
        3)  # Daemon is not running.
            # Build blocklist if necessary to make sure pglcmd's settings are taken.
            # Force to build it, if started with force-restart.
            [ ! "$CMD_OPTION" = force-restart ] &&
                [ -f "$MD5SUM_FILE" ] && set_md5sum && [ "$MD5SUM" = "$(cat $MD5SUM_FILE)" ] ||
                build_blocklist
            # TRANSITION 2011-05-28: remove old master blocklists:
            for LIST in guarding.p2p.backup guarding.p2p ${CMD_NAME}_premerged_blocklist.p2p~ ${CMD_NAME}_premerged_blocklist.p2p pglcmd_blocklist.p2p~ pglcmd_blocklist.p2p; do
                [ -f "${MASTER_BLOCKLIST_DIR}/${LIST}" ] &&
                mv "${MASTER_BLOCKLIST_DIR}/${LIST}" ${MASTER_BLOCKLIST}~
            done
            test_IPTABLES_TARGET
            test_REJECT
            test_ACCEPT
            test_IPTABLES_VARS
            test_LOG_SYSLOG
            test_PIDFILE

            # Load kernel modules after checking if they are already loaded / were compiled in the kernel directly.
            # Note 1: I (jre) have not seen documentation how this works. E.g. loading (modprobe) a module does
            #         not give the specified entries in /proc/net. But once pgld was started they are there.
            # Note 2: On a first glance some modules might be loaded conditional on some configuration. I decided
            #         against that to allow for e.g, custom iptables rules.

            # xt_NFQUEUE
            case "$IPTABLES_TARGET" in
                NFQUEUE)
                    [ -f /proc/net/ip_tables_targets ] && grep -q NFQUEUE /proc/net/ip_tables_targets ||
                        modprobe -q xt_NFQUEUE ||
                        modprobe -q ipt_NFQUEUE || {
                        log_failure_msg "Error $E_XEXTERNAL: Could not load kernel module xt_NFQUEUE, not starting $NAME!"
                        exit $E_XEXTERNAL
                        }
                    ;;
                QUEUE)
                    [ -f /proc/net/ip_queue ] ||
                        modprobe -q ip_queue || {
                        log_failure_msg "Error $E_XEXTERNAL: Could not load kernel module ip_queue, not starting $NAME!"
                        exit $E_XEXTERNAL
                        }
                    ;;
            esac
            # TODO: xt_tcpudp
                # /proc/net/ip_tables_matches:
                # udplite
                # udp
                # tcp
            # TODO?: nfnetlink_queue
            # TODO?: nf_conntrack/nf_conntrack_ipv4 depended on by xt_state
            # TODO?: iptable_filter
            # xt_mark
            [ -f /proc/net/ip_tables_matches ] && grep -q mark /proc/net/ip_tables_matches ||
                modprobe -q xt_mark ||
                modprobe -q ipt_mark ||
                if [ "$REJECT" = 1 ] || [ "$ACCEPT" = 1 ] ; then
                    log_failure_msg "Error $E_XEXTERNAL: Could not load kernel module xt_mark, not starting $NAME!"
                    log_failure_msg "Use a kernel with netfilter MARK support or reconfigure $(basename $0)"
                    log_failure_msg "to not use the MARKing feature (options REJECT and ACCEPT)."
                    exit $E_XEXTERNAL
                else
                    log_warning_msg "Warning: Could not load kernel module xt_mark, continuing anyway."
                fi
            # ipt_REJECT
            [ -f /proc/net/ip_tables_targets ] && grep -q REJECT /proc/net/ip_tables_targets ||
                modprobe -q xt_REJECT ||
                modprobe -q ipt_REJECT ||
                if [ "$REJECT_OUT" = REJECT ] || [ "$REJECT_FWD" = REJECT ] || [ "$REJECT_IN" = REJECT ] ; then
                    log_failure_msg "Error $E_XEXTERNAL: Could not load kernel module ipt_REJECT, not starting $NAME!"
                    log_failure_msg "Use a kernel with netfilter REJECT support or reconfigure $(basename $0)"
                    log_failure_msg "to DROP instead of REJECT blocked packets."
                    exit $E_XEXTERNAL
                else
                    log_warning_msg "Warning: Could not load kernel module ipt_REJECT, continuing anyway."
                fi
            # xt_state
            [ -f /proc/net/ip_tables_matches ] && grep -q state /proc/net/ip_tables_matches ||
                modprobe -q xt_state ||
                modprobe -q ipt_state ||
                if [ "$IPTABLES_ACTIVATION" = 1 ] ; then
                    log_failure_msg "Error $E_XEXTERNAL: Could not load kernel module xt_state, not starting $NAME!"
                    log_failure_msg "Use a kernel with netfilter STATE support or reconfigure $(basename $0)"
                    log_failure_msg "to check all traffic (not only NEW) traffic (option IPTABLES_ACTIVATION)."
                    exit $E_XEXTERNAL
                else
                    log_warning_msg "Warning: Could not load kernel module xt_state, continuing anyway."
                fi
            # xt_iprange
            [ -f /proc/net/ip_tables_matches ] && grep -q iprange /proc/net/ip_tables_matches ||
                modprobe -q xt_iprange ||
                modprobe -q ipt_iprange || {
                # If CHAINS is empty/not set, then set it to "all". Replace all with the single names.
                CHAINS=${CHAINS:-all}
                [ "$CHAINS" != all ] || CHAINS="INPUT OUTPUT FORWARD"
                for CHAIN in $CHAINS ; do
                    case $CHAIN in
                    INPUT)
                        ALLOW_FILE="$ALLOW_IN"
                        ;;
                    OUTPUT)
                        ALLOW_FILE="$ALLOW_OUT"
                        ;;
                    FORWARD)
                        ALLOW_FILE="$ALLOW_FWD"
                        ;;
                    *)
                        echo "Unknown CHAIN $CHAIN specified."
                        exit 1
                        ;;
                    esac
                    if [ -n "$ALLOW_FILE" ] && [ -f "$ALLOW_FILE" ] ; then
                        log_failure_msg "Error $E_XEXTERNAL: Could not load kernel module xt_iprange, not starting $NAME!"
                        log_failure_msg "Use a kernel with netfilter IPRANGE support or reconfigure $(basename $0)"
                        log_failure_msg "to not use the allow list $ALLOW_FILE."
                        exit $E_XEXTERNAL
                    fi
                done
                log_warning_msg "Warning: Could not load kernel module xt_iprange, continuing anyway."
                }

            # Execute old REMOVE_SCRIPT if it still exists for any reason, because we may run into troubles
            # if there are still old iptables
            if [ -f "$REMOVE_SCRIPT" ] ; then
                echo -n "Old iptables remove script $REMOVE_SCRIPT still exists! Executing and then removing it"
                sh $REMOVE_SCRIPT
                rm $REMOVE_SCRIPT
                log_end_msg $?
            fi
            insert_iptables
            echo -n "Starting $NAME"

            # Set the log to syslog option
            if [ "$LOG_SYSLOG" -eq 1 ] ; then
                LOG_SYSLOG_OPT="-s"
            else
                LOG_SYSLOG_OPT=""
            fi

            # Set the log to logfile option
            if [ "$LOG_LOGFILE" -eq 1 ] ; then
                LOG_LOGFILE_OPT="-l $DAEMON_LOG"
            else
                LOG_LOGFILE_OPT=""
            fi


            # Set the options for marking matched packets
            if [ "$REJECT" -eq 1 ] ; then
                REJECT_OPT="-r $REJECT_MARK"
            else
                REJECT_OPT=""
            fi
            # Set the options for marking not matched packets
            if [ "$ACCEPT" -eq 1 ] ; then
                ACCEPT_OPT="-a $ACCEPT_MARK"
            else
                ACCEPT_OPT=""
            fi
            # Set the NFQUEUE number only if NFQUEUE and not QUEUE is used
            case "$IPTABLES_TARGET" in
                NFQUEUE)
                    NFQUEUE_NUMBER_OPT="-q $NFQUEUE_NUMBER"
                    ;;
                QUEUE)
                    NFQUEUE_NUMBER_OPT=""
                    ;;
            esac

            # Set D-Bus
            if [ "$DBUS" -eq 1 ]
            then
                DBUS_OPT="-d"
            else
                DBUS_OPT=""
            fi

            # Set the options the daemon is started with
            DAEMON_OPTS="$LOG_SYSLOG_OPT $LOG_LOGFILE_OPT $DBUS_OPT -p $PIDFILE $NFQUEUE_NUMBER_OPT $REJECT_OPT $ACCEPT_OPT $MASTER_BLOCKLIST"

            # Test NICE_LEVEL setting.
            [ "$NICE_LEVEL" -ge -20 ] && [ "$NICE_LEVEL" -le 19 ] || {
                log_failure_msg " Error $E_CONFIG: Check the NICE_LEVEL setting."
                exit $E_CONFIG
                }

            # Start daemon
            start_daemon -n $NICE_LEVEL -p $PIDFILE $DAEMON $DAEMON_OPTS
            RETVAL=$?
            log_end_msg $RETVAL

            if [ "$RETVAL" = 0 ] ; then
                if [ "$WD" = 1 ] ; then
                    # Start pglcmd.wd.
                    do_start_wd
                fi
            else
                # Remove iptables again, since starting failed.
                # Save the retval (although currently delete_iptables doesn't use this variable).
                SAVE_RETVAL=$RETVAL
                delete_iptables
                RETVAL=$SAVE_RETVAL
            fi
            ;;
        # Problematic daemon status. Be verbose and exit!
        *)
            echo "Problematic daemon status: $RETVAL"
            status_of_proc $DAEMON $NAME
            exit $?
            ;;
    esac
}

do_stop_quick () {
    STOP_QUICK=1
    do_stop
}

# Function that stops daemon (but not watchdog)
do_stop () {
    # Email stats, except if we are on system shutdown.
    [ "$STOP_QUICK" ] || email_stats
    # Remove iptables rules/chains
    delete_iptables
    # As per LSB don't test if daemon is installed on stop!
    echo -n "Stopping $NAME"
    PID_OPT=""
    [ -z "$PIDFILE" ] || PID_OPT="-p $PIDFILE"
    killproc "$PID_OPT" "$DAEMON"

    # Verify that the daemon is really not running. This may take some
    # time, even after the killproc ended successfully.
    # Normally killproc should take care of this.
    # Otherwise restarting pgld fails, because it was restarted too early.
    # This also fixes broken lsb init-functions (e.g. Ubuntu hardy), that give
    # the wrong exit code.
    COUNT=0
    # Wait up to 20 seconds
    while [ "$COUNT" -lt 20 ] ; do
        # Verify that the daemon is really not running.
        kill -0 "$(pidof $DAEMON)" > /dev/null 2>&1
        # If old process is not running, remember success and break.
        if [ "$?" -eq 0 ] ; then
            # Process is still running
            RETVAL=1
            sleep 1
            COUNT=$(($COUNT+1))
        else
            rm -f $PIDFILE
            RETVAL=0
            break
        fi
    done
    # If pidfile still exists (stop failed), force pgld to quit.
    [ ! -f "$PIDFILE" ] || { kill -9 "$(pidof $DAEMON)" && rm -f $PIDFILE ; }
    RETVAL=$?

    log_end_msg $RETVAL
}

# Function that restarts daemon
do_restart () {
    do_stop
    do_start
}

# Function that rebuilds master blocklist and reloads daemon
do_reload () {
    test_DAEMON
    # Check if daemon is running
    status_of_proc $DAEMON $NAME > /dev/null 2>&1
    RETVAL=$?
    case "$RETVAL" in
        0)  # Daemon is running
            # Build blocklist if necessary to make sure pglcmd's settings are taken.
            # Force to build it, if started with force-reload.
            [ ! "$CMD_OPTION" = force-reload ] &&
                [ -f "$MD5SUM_FILE" ] && set_md5sum && [ "$MD5SUM" = "$(cat $MD5SUM_FILE)" ] ||
                build_blocklist
            echo -n "Reloading $NAME"
            kill -s HUP "$(pidofproc $DAEMON)"
            RETVAL=$?
            log_end_msg $RETVAL
            ;;
        3)  # Daemon is not running
            echo "$NAME is not running, doing nothing."
            RETVAL=0
            ;;
        # Problematic daemon status. Be verbose and exit!
        *)
            echo "Problematic daemon status: $RETVAL"
            status_of_proc $DAEMON $NAME
            exit $?
            ;;
    esac
}

# Read the non-comment|not-empty lines from BLOCKLISTS_LIST.
# Ignore all entries after # (comments).
set_LISTS_URL () {
    if [ -f "$BLOCKLISTS_LIST" ] ; then
        LISTS_URL="$(grep -Ev "^[[:space:]]*#|^[[:space:]]*$" $BLOCKLISTS_LIST | sed "s|#.*$||g")"
        [ $? -eq 0 ] ||
            { log_failure_msg "Error: set_LISTS_URL exited with $?" ; exit 1 ; }
    else
        LISTS_URL=""
    fi
}

# This function depends on LIST:
LIST_URL2LIST_NAME () {
    # Set LIST_URL depending on LIST
    # If you change this function also adapt the function LIST_NAME2LIST_URL in debian/postinst!
    # Since IFS now is standard IFS, separate words (not the complete lines from
    # blocklists.list) are used for LIST.
    # Assuming remote blocklists (supported through wget) for all blocklists in blocklists.list:
    LIST_URL="$( echo $LIST | sed -r "s|http://||;s|https://||;s|ftp://||" )"

    # Translate LIST_URL to human readable/debconf LIST_NAME.
    # Several LIST_URL may resolve to the same LIST_NAME, if alternative URLs are known for the same list.
    case $LIST_URL in
    list.iblocklist.com/?list=*)
        # Strip iblocklist.com prefix and extensions like "&fileformat=p2p&archiveformat=gz"
        LIST_URL_TRUNK="$( echo $LIST_URL | sed "s|list.iblocklist.com/?list=||;s|\&.*||" )"
        # Grep LIST_URL_TRUNK drom lists.xml. If this file is missing, try to download it.
        if ( [ -f ${BLOCKLISTS_DIR}/lists.xml ] ||
        ( test_net && [ -f ${BLOCKLISTS_DIR}/lists.xml ] )
        ) &&
        grep -q "<list>${LIST_URL_TRUNK}</list>" ${BLOCKLISTS_DIR}/lists.xml ; then
            LIST_AUTHOR="$( grep -A 2 "<list>${LIST_URL_TRUNK}</list>" ${BLOCKLISTS_DIR}/lists.xml | \
                grep -o "<author>.*</author>" | \
                sed "s|<author>\(.*\)</author>|\1|" )"
            LIST_NAME1="$( grep -A 2 "<list>${LIST_URL_TRUNK}</list>" ${BLOCKLISTS_DIR}/lists.xml | \
                grep -o "<name>.*</name>" | \
                sed "s|<name>\(.*\)</name>|\1|" )"
        else
            LIST_AUTHOR="unknown_iblocklist"
            LIST_NAME1="$LIST_URL_TRUNK"
        fi
        LIST_NAME=${LIST_AUTHOR}_${LIST_NAME1}
        ;;
    list.iblocklist.com/lists/*/*)
        # Strip iblocklist.com prefix and extensions like "&fileformat=p2p&archiveformat=gz"
        LIST_URL_TRUNK="$( echo $LIST_URL | sed "s|list.iblocklist.com/lists/||;s|\&.*||" )"
        LIST_AUTHOR="$( echo $LIST_URL_TRUNK  | sed "s|\(.*\)/\(.*\)|\1|" )"
        LIST_NAME1="$( echo $LIST_URL_TRUNK | sed "s|\(.*\)/\(.*\)|\2|" )"
        LIST_NAME=${LIST_AUTHOR}_${LIST_NAME1}
        # Fix inconsistent iblocklist names:
        if [ "$LIST_NAME" = bluetack_level-1 ] ; then
            LIST_NAME="bluetack_level1"
        elif [ "$LIST_NAME" = bluetack_level-2 ] ; then
            LIST_NAME="bluetack_level2"
        elif [ "$LIST_NAME" = bluetack_level-3 ] ; then
            LIST_NAME="bluetack_level3"
        fi
        ;;
    *)
        # Otherwise, use LIST_URL.
        LIST_NAME="$LIST_URL"
        ;;
    esac
    # Replace problematic letters, make everything lowercase
    LIST_NAME="$( echo $LIST_NAME | sed "s|.*://|_|;s|/|_|g;s/?/_/g;s/ /_/g;s/\(.\)/\L\1/g" )"
}

# Get blocklist.
get_blocklist () {
    # Depends on LIST being set.
    [ -n "$LIST" ] || {
        echo "Error $E_BLOCKLIST: get_blocklist: internal error, LIST is not set or BLOCKLISTS_LIST not existant!"
        exit $E_BLOCKLIST
        }
    test_BLOCKLISTS_DIR
    # This function depends on LIST:
    LIST_URL2LIST_NAME

    # Set blocklist directory name.
    BLOCKLIST_DIR="$BLOCKLISTS_DIR/$LIST_NAME"
    # Gives the name of the blocklist downloaded by wget. Reset the value here
    # and set it later in the script:
    BLOCKLIST_DOWNLOAD=""
    # Gives the name of successfully downloaded files:
    BLOCKLIST_DOWNLOADED="$BLOCKLIST_DIR/downloaded/$LIST_NAME"
    # BLOCKLIST_DOWNLOADED is extracted to this file
    BLOCKLIST_EXTRACTED="$BLOCKLIST_DIR/extracted/$LIST_NAME"

    echo -n "Updating $LIST_NAME... "

    # Assuming remote blocklists (supported through wget) for all blocklists in blocklists.list:
    # Create necessary directories if missing:
    [ -d "$BLOCKLIST_DIR/download" ] ||
        mkdir -p "$BLOCKLIST_DIR/download" ||
        { log_failure_msg " Error: mkdir -p exited with $?" ; exit 1 ; }

    cd "$BLOCKLIST_DIR/download" ||
        { log_failure_msg " Error: cd exited with $?" ; exit 1 ; }

    # Create necessary directories if missing:
    [ -d "$(dirname $BLOCKLIST_DOWNLOADED)" ] ||
        mkdir -p "$(dirname $BLOCKLIST_DOWNLOADED)" ||
        { log_failure_msg "Error: mkdir -p exited with $?" ; exit 1 ; }

    # Download blocklists with timestamping. If this fails remove
    # the old blocklist (which might be a corrupted file)
    # and try again without timestamping:
    test_external wget || {
        log_failure_msg "Error $E_XEXTERNAL: wget not installed."
        exit $E_XEXTERNAL
        }
    # If 7z is not available, change user agent to pglcmd_x7z,
    # so that iblocklist.com knows we are not capable of 7z.
    test_external 7zr ||
        test_external 7za ||
        test_external 7z ||
        test_external p7zip ||
        WGET_OPTS="$(echo $WGET_OPTS |
            sed "s|--user-agent=${CMD_NAME}/${VERSION}|--user-agent=${CMD_NAME}_x7z/${VERSION}|")"
    $WGET_OPTS -N "$LIST_URL"
    WGET_RET=$?
    case "$WGET_RET" in
        0)
            ;;
        403)
            echo -n "... Access denied!"
            rm -Rf $BLOCKLIST_DIR/download/* ||
                { log_failure_msg " Error: rm exited with $?" ; exit 1 ; }
            ;;
        *)
            echo -n "... failed!"
            rm -Rf $BLOCKLIST_DIR/download/* ||
                { log_failure_msg " Error: rm exited with $?" ; exit 1 ; }
            echo -n " Trying without timestamping ..."
            $WGET_OPTS "$LIST_URL"
            WGET_RET=$?
            ;;
    esac

    # Get the name of the downloaded blocklist: BLOCKLIST_DOWNLOAD
    # Take the newest file, in case there are several files in the folder.
    # There may be several files from different URLs for the same LIST_NAME
    # If the directory is empty the variable will stay empty, too.
    ls $BLOCKLIST_DIR/download/* > /dev/null 2>&1 &&
        BLOCKLIST_DOWNLOAD="$BLOCKLIST_DIR/download/$(ls -1t $BLOCKLIST_DIR/download/ | head -n 1)"

    # Download was not successful, access forbidden
    if [ "$WGET_RET" -eq 403 ] ; then
        if [ -f "$BLOCKLIST_DOWNLOADED" ] ; then
            echo " forbidden! Using old blocklist."
            UPDATE_403="$UPDATE_403 $UPDATE_403 (last modified: $(stat --format=%y $BLOCKLIST_DOWNLOADED | head -c 16));"
        else
            log_failure_msg " Error $E_BLOCKLIST: $LIST_NAME access forbidden. Aborting!"
            log_failure_msg "Check your entry $LIST_URL in $BLOCKLISTS_LIST."
            log_failure_msg "To fix this manually download $LIST_URL and save it as $BLOCKLIST_DOWNLOADED"
            exit $E_BLOCKLIST
        fi
    # Download was not successful
    elif [ "$WGET_RET" -ne 0 ] ; then
        if [ -f "$BLOCKLIST_DOWNLOADED" ] ; then
            echo " failed! Using old blocklist."
            UPDATE_FAIL="$UPDATE_FAIL $LIST_NAME (last modified: $(stat --format=%y $BLOCKLIST_DOWNLOADED | head -c 16));"
        else
            log_failure_msg " Error $E_BLOCKLIST: $LIST_NAME not available. Aborting!"
            log_failure_msg "To fix this manually download $LIST_URL and save it as $BLOCKLIST_DOWNLOADED"
            exit $E_BLOCKLIST
        fi
    # Download was successful ($WGET_RET = 0):
    # This should not happen, just for debugging:
    elif [ -z "$BLOCKLIST_DOWNLOAD" ] ; then
        log_failure_msg " Error: $LIST_URL was downloaded successfully but BLOCKLIST_DOWNLOAD is empty! Strange, aborting!"
        exit 1
    # This should not happen, just for debugging:
    elif [ ! -f "$BLOCKLIST_DOWNLOAD" ] ; then
        log_failure_msg " Error: $LIST_URL was downloaded successfully but $BLOCKLIST_DOWNLOAD doesn't exist! Strange, aborting!"
        exit 1
    # Download was successful, old blocklist is not available or older than the new one:
    elif [ ! -f "$BLOCKLIST_DOWNLOADED" ] || [ "$BLOCKLIST_DOWNLOAD" -nt "$BLOCKLIST_DOWNLOADED" ] ; then
        cp -f --preserve=timestamps $BLOCKLIST_DOWNLOAD $BLOCKLIST_DOWNLOADED &&
            echo "done." ||
            { log_failure_msg " Error: cp exited with $?"; exit 1 ; }
        [ -f "$BLOCKLIST_DOWNLOADED" ] &&
            UPDATE_SUCCESS="$UPDATE_SUCCESS $LIST_NAME (last modified: $(stat --format=%y $BLOCKLIST_DOWNLOADED | head -c 16));" ||
            { log_failure_msg " Error: $LIST_URL exists, but $BLOCKLIST_DOWNLOADED doesn't exist! Strange, aborting!" ; exit 1 ; }
    # Download was successful, blocklist is not newer than the old one:
    else
        echo ". No update available."
        [ -f "$BLOCKLIST_DOWNLOADED" ] &&
            UPDATE_SUCCESS_NA="$UPDATE_SUCCESS_NA $LIST_NAME (last modified: $(stat --format=%y $BLOCKLIST_DOWNLOADED | head -c 16));" ||
            { log_failure_msg " Error: $LIST_URL exists, but $BLOCKLIST_DOWNLOADED doesn't exist! Strange, aborting!" ; exit 1 ; }
    fi

    # Unpack the lists
    echo -n "Extracting $LIST_NAME, "

    # Create necessary directories if missing:
    [ -d "$(dirname $BLOCKLIST_EXTRACTED)" ] ||
        mkdir -p "$(dirname $BLOCKLIST_EXTRACTED)" ||
        { log_failure_msg " Error: mkdir -p exited with $?" ; exit 1 ; }

    # This should not happen, just for debugging:
    [ -f "$BLOCKLIST_DOWNLOADED" ] || {
        log_failure_msg " D'oh, why does $BLOCKLIST_DOWNLOADED not exist? Strange, aborting!" ; exit 1 ; }

    # General: To analyze the file header check
    # http://mark0.net/hexdump.html and get a list of TrID file type / file
    # extension definitions from http://mark0.net/soft-trid-deflist.html
    #
    # Using bytes with hexadecimal value HH:
    # $'\xHH' is a bashism.
    # "$(printf '\xHH')" doesn't work at least for the dash builtin printf, so
    # use: "$(/usr/bin/printf '\xHH')"

    # Read the first six (length of the 7z header) bytes of the packed
    # blocklist:
    case "$(head -c 6 $BLOCKLIST_DOWNLOADED)" in
        # 7z packed file
        "$(/usr/bin/printf '\x37\x7A\xBC\xAF\x27\x1C')")
            echo -n "detected 7z... "
            { test_external 7zr && EXTRACT_CMD='7zr x "$BLOCKLIST_DOWNLOADED" -so > "${BLOCKLIST_EXTRACTED}.tmp"' ; } ||
            { test_external 7za && EXTRACT_CMD='7za x "$BLOCKLIST_DOWNLOADED" -so > "${BLOCKLIST_EXTRACTED}.tmp"' ; } ||
            { test_external 7z && EXTRACT_CMD='7z x "$BLOCKLIST_DOWNLOADED" -so > "${BLOCKLIST_EXTRACTED}.tmp"' ; } ||
            { test_external p7zip && EXTRACT_CMD="p7zip -d < $BLOCKLIST_DOWNLOADED > ${BLOCKLIST_EXTRACTED}.tmp" ; } ||
                exit $E_XEXTERNAL
            eval $EXTRACT_CMD || {
                log_failure_msg "Error $E_BLOCKLIST: Failed to extract $LIST_NAME."
                log_failure_msg "Removing $BLOCKLIST_DOWNLOADED."
                log_failure_msg "Check your configuration in $BLOCKLISTS_LIST and try a new \"$(basename $0) update\"."
                rm "$BLOCKLIST_DOWNLOADED" ||
                    { log_failure_msg "Error: rm exited with $?" ; exit 1 ; }
                exit $E_BLOCKLIST
                }
            ;;
        # gz packed file
        "$(/usr/bin/printf '\x1F\x8B\x08')"*)
            echo -n "detected gz... "
            zcat "$BLOCKLIST_DOWNLOADED" > "${BLOCKLIST_EXTRACTED}.tmp" || {
                log_failure_msg "Error $E_BLOCKLIST: Failed to extract $LIST_NAME."
                log_failure_msg "Removing $BLOCKLIST_DOWNLOADED."
                log_failure_msg "Check your configuration in $BLOCKLISTS_LIST and try a new \"$(basename $0) update\"."
                rm "$BLOCKLIST_DOWNLOADED" ||
                    { log_failure_msg "Error: rm exited with $?" ; exit 1 ; }
                exit $E_BLOCKLIST
                }
            ;;
        # zip packed file
        "$(/usr/bin/printf '\x50\x4B\x03\x04')"*)
            echo -n "detected zip... "
            test_external unzip || {
                log_failure_msg "Error $E_XEXTERNAL: unzip not installed."
                exit $E_XEXTERNAL
                }
            unzip -p "$BLOCKLIST_DOWNLOADED" > "${BLOCKLIST_EXTRACTED}.tmp" || {
                log_failure_msg "Error $E_BLOCKLIST: Failed to extract $LIST_NAME."
                log_failure_msg "Removing $BLOCKLIST_DOWNLOADED."
                log_failure_msg "Check your configuration in $BLOCKLISTS_LIST and try a new \"$(basename $0) update\"."
                rm "$BLOCKLIST_DOWNLOADED" ||
                    { log_failure_msg "Error: rm exited with $?" ; exit 1 ; }
                exit $E_BLOCKLIST
                }
            ;;
        # Assuming non-packed otherwise:
        *)
            echo -n "not packed... "
            ln -fs $BLOCKLIST_DOWNLOADED ${BLOCKLIST_EXTRACTED}.tmp ||
                { log_failure_msg " Error: ln exited with $?"; exit 1 ; }
            ;;
    esac
    # Count the lines in the list and check if there are any lines.
    if [ "$( wc -l < ${BLOCKLIST_EXTRACTED}.tmp )" -gt 0 ] ; then
        mv -f "${BLOCKLIST_EXTRACTED}.tmp" "${BLOCKLIST_EXTRACTED}" ||
            { log_failure_msg "Error: mv exited with $?" ; exit 1 ; }
        echo "done."
    else
        # TODO: Remove list from e.g. UPDATE_SUCCESS
        log_warning_msg "${BLOCKLIST_EXTRACTED}.tmp is empty!"
        log_warning_msg "wc -l: $(wc -l ${BLOCKLIST_EXTRACTED}.tmp)"
        if [ -f "$BLOCKLIST_EXTRACTED" ] ; then
            log_warning_msg "Keeping old $BLOCKLIST_EXTRACTED."
            UPDATE_FAIL="$UPDATE_FAIL $LIST_NAME (new list was empty, keeping old, last modified: $(stat --format=%y $BLOCKLIST_DOWNLOADED | head -c 16));"
        else
            touch $BLOCKLIST_EXTRACTED
            UPDATE_FAIL="$UPDATE_FAIL $LIST_NAME (new list was empty, no old list available! Ignoring ...);"
        fi
    fi
    # Add a newline at the end of the blocklist to fix broken lists:
    echo "" >> $BLOCKLIST_EXTRACTED
}

# Function that updates blocklists and reloads daemon
update_blocklists () {
    # Remove the old MD5SUM file now, so that if anything goes wrong,
    # it's clear we have to rebuild the blocklist:
    [ -f "$MD5SUM_FILE" ] && {
    rm "$MD5SUM_FILE" || { log_failure_msg " Error: rm exited with $?" ; exit 1 ; }
    }

    UPDATE_FAIL=""          # Lists failed blocklist updates
    UPDATE_403=""           # Lists failed blocklist updates with "access forbidden"
    UPDATE_SUCCESS=""       # Lists successful blocklist updates
    UPDATE_SUCCESS_NA=""    # Lists blocklist where no update was available

    # Read the non-comment|not-empty lines from BLOCKLISTS_LIST.
    # Ignore all entries after # (comments).
    # LISTS_URL are all blocklists that are configured to be handled automatically.
    set_LISTS_URL

    # Only do the automatic updating, if any blocklist is configured to be handled automatically.
    if [ -n "$LISTS_URL" ] ; then
        echo "Updating blocklists ..."
        test_net

        for LIST in $LISTS_URL ; do
            get_blocklist
        done

        echo "Blocklists updated."
    else
        echo "Automatic blocklist management disabled."
    fi
}

# Function that builds the MASTER_BLOCKLIST from all remote blocklists (configured
# in BLOCKLISTS_LIST) and all local blocklists (all other lists in MASTER_BLOCKLIST_DIR).
# pgld is started with just this list.
# Ratio: We want to reload the daemon as fast as possible. Therefore do the whole
# blocklist management separately and save one premerged MASTER_BLOCKLIST to harddisk.
# Bad: for large local blocklists this means excess usage of harddisk space.
build_blocklist () {
    echo "Building blocklist ... "

    # DAEMON is needed to merge the single blocklists.
    test_DAEMON

    [ -d "$MASTER_BLOCKLIST_DIR" ] || {
        echo -n "Creating missing directory $MASTER_BLOCKLIST_DIR ..."
        mkdir -p "$MASTER_BLOCKLIST_DIR" && echo "."
        } || {
        log_failure_msg "Error $E_XCD: Missing directory $MASTER_BLOCKLIST_DIR."
        log_failure_msg "Check the $MASTER_BLOCKLIST_DIR setting."
        exit $E_XCD
    }
    BLOCKLISTSCAT=""

    # Remove the old MD5SUM file now, so that if anything goes wrong,
    # it's clear we have to rebuild the blocklist:
    [ -f "$MD5SUM_FILE" ] && {
    rm "$MD5SUM_FILE" || { log_failure_msg " Error: rm exited with $?" ; exit 1 ; }
    }

    # Move master blocklist to backup position. This way it is also removed,
    # in case the configuartion changed in that way, that no blocklists are
    # configured for the automatic blocklist management.
    [ -f "$MASTER_BLOCKLIST" ] &&
        mv $MASTER_BLOCKLIST ${MASTER_BLOCKLIST}~

    # Prepare removing lines from the blocklist with "grep":
    # remove pending ";" and replace all other ";" with "|" in IP_REMOVE.
    SINGLE_REMOVE="$( echo $IP_REMOVE | sed " s/;$// ; s/;/|/g " )"

    # Read the non-comment|not-empty lines from BLOCKLISTS_LIST.
    # Ignore all entries after # (comments).
    # LISTS_URL are all blocklists that are configured to be handled automatically.
    set_LISTS_URL
    if [ -n "$LISTS_URL" ] ; then
        test_BLOCKLISTS_DIR

        for LIST in $LISTS_URL ; do
            # This function depends on LIST:
            LIST_URL2LIST_NAME

            # Set name of the extracted blocklist.
            BLOCKLIST_EXTRACTED="$BLOCKLISTS_DIR/$LIST_NAME/extracted/$LIST_NAME"

            # Test if list is available:
            [ -f "$BLOCKLIST_EXTRACTED" ] ||
                get_blocklist || {
                log_failure_msg "Error $E_BLOCKLIST: $LIST_NAME not available."
                log_failure_msg "Check the entry $LIST"
                log_failure_msg "in $BLOCKLISTS_LIST. Aborting!"
                exit $E_BLOCKLIST
                }

            # Log which lines will be removed later
            if [ -n "$IP_REMOVE" ] ; then
                echo "Removing the following lines from $LIST_NAME:"
                grep -Ei "$SINGLE_REMOVE" "$BLOCKLIST_EXTRACTED" | sort
            fi

            # Remember all used lists
            BLOCKLISTSCAT="$BLOCKLISTSCAT $BLOCKLIST_EXTRACTED"
        done
    fi

    set_BLOCKLISTS_LOCAL
    if [ -n "$BLOCKLISTS_LOCAL" ] ; then
        for LIST in $BLOCKLISTS_LOCAL ; do
            # Log which lines will be removed later
            if [ -n "$IP_REMOVE" ] ; then
                echo "Removing the following lines from $LIST:"
                grep -Ei "$SINGLE_REMOVE" "$LIST" | sort
            fi

            # Remember all used lists
            BLOCKLISTSCAT="$BLOCKLISTSCAT $LIST"
        done
    fi

    if [ -z "$BLOCKLISTSCAT" ] ; then
        log_failure_msg "Error $E_BLOCKLIST: No blocklists configured or available."
        exit $E_BLOCKLIST
    else
        # Tells whether blocklist was built successfully
        BUILT=0

        # Build blocklist and remove some lines from the blocklists
        if [ -n "$IP_REMOVE" ] ; then
            # Cat together all single blocklists
            cat --squeeze-blank $BLOCKLISTSCAT |
            # Ignore comment lines
            grep -Ev "^[[:space:]]*#" |
            # Remove lines from IP_REMOVE (case-insensitive)
            grep -Eiv "$SINGLE_REMOVE" |
            # Replace repeated whitespace with a single occurence
            tr -s [:space:] |
            # Delete everything complimentary to the following characters/regex
            # alphanumeric
            # space
            # :\*.-,[]
            # newline (return gets removed, so CR+LF gets LF)
            tr -cd '[:alnum:][:space:]:\\\*\.\-,[]\n' |
            # Only keep the last occurence of :
            sed 's/.*:/&|/' | tr -d : | tr "\|" ":" |
            # Premerge the blocklist
            $DAEMON -m > $MASTER_BLOCKLIST && BUILT=1
        # Build blocklist without removing some lines from the blocklists
        else
            # Cat together all single blocklists
            cat --squeeze-blank $BLOCKLISTSCAT |
            # Ignore comment lines
            grep -Ev "^[[:space:]]*#" |
            # Replace repeated whitespace with a single occurence
            tr -s [:space:] |
            # Delete everything complimentary to the following characters/regex
            # alphanumeric
            # space
            # :\*.-,[]
            # newline (return gets removed, so CR+LF gets LF)
            tr -cd '[:alnum:][:space:]:\\\*\.\-,[]\n' |
            # Only keep the last occurence of :
            sed 's/.*:/&|/' | tr -d : | tr "\|" ":" |
            # Premerge the blocklist, pgld's information is sent to STDERR
            # and therefore ends in pglcmd.log
            $DAEMON -m > $MASTER_BLOCKLIST && BUILT=1
        fi

        if [ "$BUILT" -eq 1 ] ; then
            echo "Blocklist built."
        else
            log_failure_msg "Error: build_blocklist failed."
            if [ -f ${MASTER_BLOCKLIST}~ ] ; then
                echo -n "Restoring $MASTER_BLOCKLIST ..."
                mv ${MASTER_BLOCKLIST}~ $MASTER_BLOCKLIST ||
                    { log_failure_msg " Error: mv exited with $?" ; exit 1 ; }
                log_end_msg 0
            else
                exit $E_BLOCKLIST
            fi
        fi
    fi

    # Save configuration settings on which this blocklist bases:
    set_md5sum
    echo "$MD5SUM" > "$MD5SUM_FILE"
}

# Function that tests if IPs get blocked
test_ipblocking () {
    # First check some preconditions for the test:
    test_DAEMON
    test_REJECT

    [ -f "$MASTER_BLOCKLIST" ] || {
        log_failure_msg " Error $E_BLOCKLIST: $MASTER_BLOCKLIST not available."
        exit $E_BLOCKLIST
        }

    # Detect the logfile, where hits are logged.
    if [ "$LOG_LOGFILE" -eq 1 ] ; then
        TEST_LOG="$DAEMON_LOG"
    elif [ "$LOG_SYSLOG" -eq 1 ] ; then
        TEST_LOG="/var/log/syslog"
    else
        echo "Error: $NAME has to be started with either LOG_SYSLOG=\"1\" or LOG_LOGFILE=\"1\" for \"test\" to work."
        exit $E_CONFIG
    fi

    echo "Testing $DESC:"
    # Check if daemon is running
    status_of_proc $DAEMON $NAME > /dev/null 2>&1
    RETVAL=$?
    case "$RETVAL" in
        0)    # Daemon is running
            true
            ;;
        3)    # Daemon is not running
            status_of_proc $DAEMON $NAME
            exit $?
            ;;
        *)    # Problematic daemon status. Be verbose and exit!
            echo "Problematic daemon status: $RETVAL"
            status_of_proc $DAEMON $NAME
            exit $?
            ;;
    esac

    # If logfile does not exist, reload daemon to reopen a new one.
    [ -f "$TEST_LOG" ] || kill -s HUP "$(pidofproc $DAEMON)"

    # Pick TEST_IP. Assume blocklist in text (not binary) format.
    TESTLINE="$(expr $$ % 100 + 10)"

    # Pick the last IP address from a random line in the MASTER_BLOCKLIST (earlier IPs often result in problems with ping)
    # Remove the leading zeros in the IPs.
    TEST_IP="$(head -n$TESTLINE $MASTER_BLOCKLIST | grep -Eo "$IPv4_REGEX" | tail -n1 )"
    echo "CAUTION: This is just a simple test to check if $DESC blocks"
    echo "outgoing connections. For this, an IP from the blocklist will be pinged. Then "
    echo "the test checks if this IP appears in $TEST_LOG."
    if [ "$REJECT" -eq 1 ] ; then
        echo "$NAME marks packets to be blocked. This means you have to make sure that the"
        echo "marked packets are also blocked later (with appropriate iptables rules). If you"
        echo "are using the default configuration and $NAME is started after other firewalls"
        echo "this will be the case."
    fi
    echo "This test does not check if you have sane iptables rules. Therefore success"
    echo "doesn't imply that everything is working as you expect it."
    echo ""
    echo "Also have a look at \"$(basename $0) status\"."
    echo ""

    echo "Trying to ping $TEST_IP from $MASTER_BLOCKLIST ..."
    LOG_LENGTH="$( wc -l < $TEST_LOG )" # remember log length before test
    ping -c1 -W2 $TEST_IP > /dev/null 2>&1
    RETVAL_PING=$? # the ping exit code
    # The ping exit status is 0 if ping succeeds and 1 if ping does not receive any reply packets.
    # On other error it exits with code 2.

    # Wait a second to give the daemon time to log the current block
    sleep 1
    LOG_LENGTH_NEW="$( wc -l < $TEST_LOG )" # new log length

    if [ "$LOG_LENGTH" -ne "$LOG_LENGTH_NEW" ] ; then    # log length changed
        tail -n$((${LOG_LENGTH_NEW}-${LOG_LENGTH})) $TEST_LOG |
            grep -q $TEST_IP
        RETVAL=$? # the grep exit status
        # The grep exit status is 0 if selected lines are found and 1 otherwise.
        # If an error occurred the grep exit status is 2.
    else
        RETVAL=1
    fi

    if [ "$RETVAL" -eq 0 ] ; then    # IP in logfile
        if [ "$RETVAL_PING" -eq 1 ] ; then    # No reply to ping
            if [ "$REJECT" -eq 1 ] ; then
                echo "$NAME marked the IP to be blocked and the IP did not answer."
                echo "Test succeeded."
            else
                echo "$NAME blocked the IP. Test succeeded."
            fi
        elif [ "$RETVAL_PING" -eq 0 ] ; then    # Reply to ping
            if [ "$REJECT" -eq 1 ] ; then
                echo "$NAME blocked the IP, but ping got an answer or failed."
                echo "Check the iptables settings and make sure that \"marked block\" packets really"
                echo "get blocked."
                RETVAL=2
            else    # REJECT is 0
                echo "$NAME blocked the IP, but ping got an answer or failed - strange."
                RETVAL=2
            fi
        else
            echo "Some error occured with ping, no test result."
            RETVAL=2
        fi
    elif [ "$RETVAL" -eq 1 ] ; then    # IP not in logfile
        if [ "$REJECT" -eq 1 ] ; then
            echo "$NAME did not mark the IP to be blocked."
        else    # REJECT is 0
            echo "$NAME did not block the IP."
        fi
        if [ "$RETVAL_PING" -eq 0 ] ; then    # Reply to ping
            echo "$TEST_IP answered. Test failed."
        elif [ "$RETVAL_PING" -eq 1 ] ; then    # No reply to ping
            echo "$TEST_IP did not answer the ping."
            echo ""
            echo "No clear test result! Trying \"$TRACEROUTE -n -m 2 ${TEST_IP} ${TRACEROUTE_PORT}\" now:"
            if [ "$TRACEROUTE" ] && test_external $TRACEROUTE ; then
                TRACE_LOG="${TMPDIR}/$(basename $0).test.log"
                $TRACEROUTE -n -m 2 $TEST_IP ${TRACEROUTE_PORT} > $TRACE_LOG 2>&1
                RETVAL_TRACEROUTE=$?    # the traceroute exit status
                cat $TRACE_LOG
                echo ""
                if [ "$RETVAL_TRACEROUTE" -eq 1 ] && grep -q "send: Operation not permitted" $TRACE_LOG ; then
                    echo "Probably the $TRACEROUTE packet was blocked by another iptables rule on your"
                    echo "machine. Everything might be ok."
                    RETVAL=0
                elif [ "$RETVAL_TRACEROUTE" -eq 0 ] && [ "$( wc -l < $TRACE_LOG )" -eq 2 ] ; then
                    # Wait a second to give the daemon time to log the current block
                    sleep 1
                    LOG_LENGTH_NEW="$( wc -l < $TEST_LOG )" # new log length
                    if [ "$LOG_LENGTH" -ne "$LOG_LENGTH_NEW" ] ; then    # log length changed
                        tail -n$(($LOG_LENGTH_NEW-$LOG_LENGTH)) $TEST_LOG |
                            grep -q $TEST_IP
                        RETVAL=$? # the grep exit status
                        # The grep exit status is 0 if selected lines are found and 1 otherwise.
                        # If an error occurred the grep exit status is 2.
                        if [ "$RETVAL" -eq 0 ] ; then
                            echo "Now the packet was blocked by pglcmd. Everything might be ok."
                            RETVAL=0
                        fi
                    else
                        echo "The packet did not leave your machine, but wasn't blocked either. Confusing."
                        echo "$TRACEROUTE return code was $RETVAL_TRACEROUTE."
                    fi
                elif [ "$RETVAL_TRACEROUTE" -eq 0 ] && [ "$(wc -l < $TRACE_LOG )" -eq 3 ] ; then
                    echo "The $TRACEROUTE packet was not blocked on your machine. There is a problem!"
                else
                    echo "Probably $TEST_IP is down/doesn't answer to pings."
                    echo "This still means that $NAME is not working!"
                fi
            else
                echo "$TRACEROUTE not installed."
            fi
        else
            echo "Some error occured with ping, no test result."
            RETVAL=2
        fi
    else    # grep error
        echo "Some error occured with grep, no test result."
        RETVAL=2
    fi
    return $RETVAL
}

# Just dump stats
dump_stats () {
    SIG_STATS="USR2"
    pgl_stats
}

# Dump and reset stats
reset_stats () {
    SIG_STATS="USR1"
    pgl_stats
}

# generic stats function (SIGUSR1/SIGUSR2)
pgl_stats () {
    status_of_proc $DAEMON $NAME > /dev/null 2>&1 || {
        echo "$DAEMON is not running."
        exit 1
        }
    if [ "$LOG_LOGFILE" = 1 ] ; then
        # If logfile does not exist, reload daemon to reopen a new one.
        [ -f "$DAEMON_LOG" ] || kill -s HUP "$(pidofproc $DAEMON)"
        CURLINE="$( wc -l < $DAEMON_LOG )"
        kill -s $SIG_STATS "$(pidofproc $DAEMON)"
        (
        sleep 5
        tail -n+$(($CURLINE + 1)) $DAEMON_LOG | grep STATS:
        ) &
    elif [ "$LOG_SYSLOG" = 1 ] ; then
        CURLINE="$( grep pgld: /var/log/syslog | wc -l )"
        kill -s $SIG_STATS "$(pidofproc $DAEMON)"
        (
        sleep 5
        grep pgld: /var/log/syslog | tail -n+$(($CURLINE + 1)) | grep STATS:
        ) &
    else
        echo "Logging to logfile or syslog must be enabled to dump stats."
    fi
}

email_stats () {
    # Check if pgl is configured to mail the stats, and if daemon is running
    # (otherwise stats are not available).
    # After "reset_stats" sleep longer than the forked process in "reset_stats" itself,
    # so that we catch its output.
    if [ $STATS_MAILTO ] && status_of_proc $DAEMON $NAME >/dev/null 2>&1 && test_sendmail ; then
        echo -n "Emailing stats"
        SUBJECT="$NAME hit statistics"
        cat<<EOF | $SENDMAIL -t &
To: $STATS_MAILTO
Subject: $SUBJECT

$(reset_stats ; sleep 6)

EOF
        log_end_msg "$?"
    fi
}

search () {
    # Read the non-comment|not-empty lines from BLOCKLISTS_LIST.
    # Ignore all entries after # (comments).
    set_LISTS_URL
    echo "Checking your currently used blocklists for \"$SEARCHPATTERN\" (case-insensitive):"
    for LIST in $LISTS_URL ; do
        # This function depends on LIST:
        LIST_URL2LIST_NAME
        BLOCKLIST="$BLOCKLISTS_DIR/$LIST_NAME/extracted/$LIST_NAME"
        # Exit immediately with zero status if any match is found
        grep -qEi "$SEARCHPATTERN" "$BLOCKLIST" && {
            echo
            echo "$LIST_NAME ($LIST):"
            grep -Ei "$SEARCHPATTERN" "$BLOCKLIST"
            # Remember that current list contains SEARCHPATTERN
            HITLIST="$HITLIST $LIST"
            }
    done
    echo
    echo "\"$SEARCHPATTERN\" was found in these lists:"
    for LIST in $HITLIST ; do
        # This function depends on LIST:
        LIST_URL2LIST_NAME
        echo "$LIST_NAME ($LIST)"
    done
    echo
    echo "If you don't want to block the above shown ranges, then you may add"
    echo "\"$SEARCHPATTERN\" to IP_REMOVE in $CMD_CONF."
    echo "Or you may remove some of these lists from $BLOCKLISTS_LIST."
}

.TH hdf_set_value 3 "12 July 2007" "ClearSilver" "util/neo_hdf.h"

.de Ss
.sp
.ft CW
.nf
..
.de Se
.fi
.ft P
.sp
..
.SH NAME
hdf_set_value  - Set the value of a named node
.SH SYNOPSIS
.Ss
#include <util/neo_hdf.h>
.Se
.Ss
NEOERR* hdf_set_value (HDF *hdf, const char *name, const char *value);

.Se

.SH ARGUMENTS
hdf -> the pointer to the hdf dataset
.br
name -> the named node to walk to
.br
value -> the value to set the node to

.SH DESCRIPTION
hdf_set_value will set the value of a named node.  All
of the interstitial nodes which don't exist will be
created with a value of NULL.  Existing nodes are not
modified.  New nodes are created at the end of the list.
If a list of nodes exceeds FORCE_HASH_AT, then a HASH
will be created at that level and all of the nodes will
be added to the hash for faster lookup times.
The copy of the value will be made which the dataset
will own.

.SH "RETURN VALUE"
None

.SH "SEE ALSO"
.BR hdf_set_symlink "(3), "hdf_get_valuef "(3), "compareFunc) "(3), "hdf_dump_str "(3), "hdf_get_int_value "(3), "hdf_read_string_ignore "(3), "hdf_copy "(3), "hdf_get_node "(3), "hdf_set_value "(3), "hdf_obj_child "(3), "hdf_read_string "(3), "hdf_set_buf "(3), "hdf_register_fileload "(3), "hdf_get_obj "(3), "hdf_get_attr "(3), "hdf_obj_top "(3), "hdf_dump_format "(3), "hdf_destroy "(3), "hdf_init "(3), "hdf_obj_value "(3), "hdf_write_string "(3), "hdf_set_valuevf "(3), "hdf_sort_obj "(3), "hdf_write_file_atomic "(3), "hdf_obj_attr "(3), "hdf_set_valuef "(3), "hdf_get_copy "(3), "hdf_write_file "(3), "hdf_get_valuevf "(3), "hdf_set_int_value "(3), "hdf_dump "(3), "hdf_get_value "(3), "hdf_set_copy "(3), "hdf_obj_next "(3), "hdf_search_path "(3), "hdf_obj_name "(3), "hdf_set_attr "(3), "hdf_get_child "(3), "hdf_remove_tree

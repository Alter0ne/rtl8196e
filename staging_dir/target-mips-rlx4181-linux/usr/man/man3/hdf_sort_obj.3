.TH hdf_sort_obj 3 "12 July 2007" "ClearSilver" "util/neo_hdf.h"

.de Ss
.sp
.ft CW
.nf
..
.de Se
.fi
.ft P
.sp
..
.SH NAME
hdf_sort_obj  - sort the children of an HDF node
.SH SYNOPSIS
.Ss
#include <util/neo_hdf.h>
.Se
.Ss
hdf_sort_obj()
.Se

.SH ARGUMENTS
h - HDF node
.br
compareFunc - function which returns 1,0,-1 depending on some
.br
criteria.  The arguments to this sort function
.br
are pointers to pointers to HDF elements.  For
.br
example:
.br
int sortByName(const void *a, const void *b) {
.br
HDF **ha = (HDF **)a;
.br
HDF **hb = (HDF **)b;
.br
*
.br
return strcasecmp(hdf_obj_name(*ha), hdf_obj_name(*hb));
.br
}
.br
*

.SH DESCRIPTION
hdf_sort_obj will sort the children of an HDF node,
based on the given comparison function.
This function works by creating an array of the pointers
for each child object of h, using qsort to sort that
array, and then re-ordering the linked list of children
to the new order.  The qsort compare function uses a
pointer to the value in the array, which in our case is
a pointer to an HDF struct, so your comparison function
should work on HDF ** pointers.

.SH "RETURN VALUE"
None (h children will be sorted)

.SH "SEE ALSO"
.BR hdf_set_symlink "(3), "hdf_get_valuef "(3), "compareFunc) "(3), "hdf_dump_str "(3), "hdf_get_int_value "(3), "hdf_read_string_ignore "(3), "hdf_copy "(3), "hdf_get_node "(3), "hdf_set_value "(3), "hdf_obj_child "(3), "hdf_read_string "(3), "hdf_set_buf "(3), "hdf_register_fileload "(3), "hdf_get_obj "(3), "hdf_get_attr "(3), "hdf_obj_top "(3), "hdf_dump_format "(3), "hdf_destroy "(3), "hdf_init "(3), "hdf_obj_value "(3), "hdf_write_string "(3), "hdf_set_valuevf "(3), "hdf_sort_obj "(3), "hdf_write_file_atomic "(3), "hdf_obj_attr "(3), "hdf_set_valuef "(3), "hdf_get_copy "(3), "hdf_write_file "(3), "hdf_get_valuevf "(3), "hdf_set_int_value "(3), "hdf_dump "(3), "hdf_get_value "(3), "hdf_set_copy "(3), "hdf_obj_next "(3), "hdf_search_path "(3), "hdf_obj_name "(3), "hdf_set_attr "(3), "hdf_get_child "(3), "hdf_remove_tree

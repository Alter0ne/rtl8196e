.TH hdf_set_symlink 3 "12 July 2007" "ClearSilver" "util/neo_hdf.h"

.de Ss
.sp
.ft CW
.nf
..
.de Se
.fi
.ft P
.sp
..
.SH NAME
hdf_set_symlink  - Set part of the tree to link to another
.SH SYNOPSIS
.Ss
#include <util/neo_hdf.h>
.Se
.Ss
NEOERR *hdf_set_symlink (HDF *hdf, const char *src, const char *dest);

.Se

.SH ARGUMENTS
hdf -> the dataset node
.br
src -> the source node name
.br
dest -> the destination node name (from the top of the
.br
dataset, not relative names)

.SH DESCRIPTION
hdf_set_symlink creates a link between two sections of
an HDF dataset.  The link is "by name" hence the term
"symlink".  This means that the destination node does
not need to exist.  Any attempt to access the source
node will cause the function to walk to the dest node,
and then continue walking from there.  Using symlinks
can "hide" values in the dataset since you won't be able
to access any children of the linked node directly,
though dumps and other things which access the data
structure directly will bypass the symlink.  Use this
feature sparingly as its likely to surprise you.

.SH "RETURN VALUE"
None

.SH "SEE ALSO"
.BR hdf_set_symlink "(3), "hdf_get_valuef "(3), "compareFunc) "(3), "hdf_dump_str "(3), "hdf_get_int_value "(3), "hdf_read_string_ignore "(3), "hdf_copy "(3), "hdf_get_node "(3), "hdf_set_value "(3), "hdf_obj_child "(3), "hdf_read_string "(3), "hdf_set_buf "(3), "hdf_register_fileload "(3), "hdf_get_obj "(3), "hdf_get_attr "(3), "hdf_obj_top "(3), "hdf_dump_format "(3), "hdf_destroy "(3), "hdf_init "(3), "hdf_obj_value "(3), "hdf_write_string "(3), "hdf_set_valuevf "(3), "hdf_sort_obj "(3), "hdf_write_file_atomic "(3), "hdf_obj_attr "(3), "hdf_set_valuef "(3), "hdf_get_copy "(3), "hdf_write_file "(3), "hdf_get_valuevf "(3), "hdf_set_int_value "(3), "hdf_dump "(3), "hdf_get_value "(3), "hdf_set_copy "(3), "hdf_obj_next "(3), "hdf_search_path "(3), "hdf_obj_name "(3), "hdf_set_attr "(3), "hdf_get_child "(3), "hdf_remove_tree

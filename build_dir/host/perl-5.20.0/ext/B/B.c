/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.24 from the
 * contents of B.xs. Do not edit this file, edit B.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "B.xs"
/*	B.xs
 *
 *	Copyright (c) 1996 Malcolm Beattie
 *
 *	You may distribute under the terms of either the GNU General Public
 *	License or the Artistic License, as specified in the README file.
 *
 */

#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#ifdef PerlIO
typedef PerlIO * InputStream;
#else
typedef FILE * InputStream;
#endif


static const char* const svclassnames[] = {
    "B::NULL",
#if PERL_VERSION < 19
    "B::BIND",
#endif
    "B::IV",
    "B::NV",
#if PERL_VERSION <= 10
    "B::RV",
#endif
    "B::PV",
#if PERL_VERSION >= 19
    "B::INVLIST",
#endif
    "B::PVIV",
    "B::PVNV",
    "B::PVMG",
#if PERL_VERSION >= 11
    "B::REGEXP",
#endif
    "B::GV",
    "B::PVLV",
    "B::AV",
    "B::HV",
    "B::CV",
    "B::FM",
    "B::IO",
};

typedef enum {
    OPc_NULL,	/* 0 */
    OPc_BASEOP,	/* 1 */
    OPc_UNOP,	/* 2 */
    OPc_BINOP,	/* 3 */
    OPc_LOGOP,	/* 4 */
    OPc_LISTOP,	/* 5 */
    OPc_PMOP,	/* 6 */
    OPc_SVOP,	/* 7 */
    OPc_PADOP,	/* 8 */
    OPc_PVOP,	/* 9 */
    OPc_LOOP,	/* 10 */
    OPc_COP	/* 11 */
} opclass;

static const char* const opclassnames[] = {
    "B::NULL",
    "B::OP",
    "B::UNOP",
    "B::BINOP",
    "B::LOGOP",
    "B::LISTOP",
    "B::PMOP",
    "B::SVOP",
    "B::PADOP",
    "B::PVOP",
    "B::LOOP",
    "B::COP"	
};

static const size_t opsizes[] = {
    0,	
    sizeof(OP),
    sizeof(UNOP),
    sizeof(BINOP),
    sizeof(LOGOP),
    sizeof(LISTOP),
    sizeof(PMOP),
    sizeof(SVOP),
    sizeof(PADOP),
    sizeof(PVOP),
    sizeof(LOOP),
    sizeof(COP)	
};

#define MY_CXT_KEY "B::_guts" XS_VERSION

typedef struct {
    int		x_walkoptree_debug;	/* Flag for walkoptree debug hook */
    SV *	x_specialsv_list[7];
} my_cxt_t;

START_MY_CXT

#define walkoptree_debug	(MY_CXT.x_walkoptree_debug)
#define specialsv_list		(MY_CXT.x_specialsv_list)

static opclass
cc_opclass(pTHX_ const OP *o)
{
    bool custom = 0;

    if (!o)
	return OPc_NULL;

    if (o->op_type == 0)
	return (o->op_flags & OPf_KIDS) ? OPc_UNOP : OPc_BASEOP;

    if (o->op_type == OP_SASSIGN)
	return ((o->op_private & OPpASSIGN_BACKWARDS) ? OPc_UNOP : OPc_BINOP);

    if (o->op_type == OP_AELEMFAST) {
#if PERL_VERSION <= 14
	if (o->op_flags & OPf_SPECIAL)
	    return OPc_BASEOP;
	else
#endif
#ifdef USE_ITHREADS
	    return OPc_PADOP;
#else
	    return OPc_SVOP;
#endif
    }
    
#ifdef USE_ITHREADS
    if (o->op_type == OP_GV || o->op_type == OP_GVSV ||
	o->op_type == OP_RCATLINE)
	return OPc_PADOP;
#endif

    if (o->op_type == OP_CUSTOM)
        custom = 1;

    switch (OP_CLASS(o)) {
    case OA_BASEOP:
	return OPc_BASEOP;

    case OA_UNOP:
	return OPc_UNOP;

    case OA_BINOP:
	return OPc_BINOP;

    case OA_LOGOP:
	return OPc_LOGOP;

    case OA_LISTOP:
	return OPc_LISTOP;

    case OA_PMOP:
	return OPc_PMOP;

    case OA_SVOP:
	return OPc_SVOP;

    case OA_PADOP:
	return OPc_PADOP;

    case OA_PVOP_OR_SVOP:
        /*
         * Character translations (tr///) are usually a PVOP, keeping a 
         * pointer to a table of shorts used to look up translations.
         * Under utf8, however, a simple table isn't practical; instead,
         * the OP is an SVOP (or, under threads, a PADOP),
         * and the SV is a reference to a swash
         * (i.e., an RV pointing to an HV).
         */
	return (!custom &&
		   (o->op_private & (OPpTRANS_TO_UTF|OPpTRANS_FROM_UTF))
	       )
#if  defined(USE_ITHREADS)
		? OPc_PADOP : OPc_PVOP;
#else
		? OPc_SVOP : OPc_PVOP;
#endif

    case OA_LOOP:
	return OPc_LOOP;

    case OA_COP:
	return OPc_COP;

    case OA_BASEOP_OR_UNOP:
	/*
	 * UNI(OP_foo) in toke.c returns token UNI or FUNC1 depending on
	 * whether parens were seen. perly.y uses OPf_SPECIAL to
	 * signal whether a BASEOP had empty parens or none.
	 * Some other UNOPs are created later, though, so the best
	 * test is OPf_KIDS, which is set in newUNOP.
	 */
	return (o->op_flags & OPf_KIDS) ? OPc_UNOP : OPc_BASEOP;

    case OA_FILESTATOP:
	/*
	 * The file stat OPs are created via UNI(OP_foo) in toke.c but use
	 * the OPf_REF flag to distinguish between OP types instead of the
	 * usual OPf_SPECIAL flag. As usual, if OPf_KIDS is set, then we
	 * return OPc_UNOP so that walkoptree can find our children. If
	 * OPf_KIDS is not set then we check OPf_REF. Without OPf_REF set
	 * (no argument to the operator) it's an OP; with OPf_REF set it's
	 * an SVOP (and op_sv is the GV for the filehandle argument).
	 */
	return ((o->op_flags & OPf_KIDS) ? OPc_UNOP :
#ifdef USE_ITHREADS
		(o->op_flags & OPf_REF) ? OPc_PADOP : OPc_BASEOP);
#else
		(o->op_flags & OPf_REF) ? OPc_SVOP : OPc_BASEOP);
#endif
    case OA_LOOPEXOP:
	/*
	 * next, last, redo, dump and goto use OPf_SPECIAL to indicate that a
	 * label was omitted (in which case it's a BASEOP) or else a term was
	 * seen. In this last case, all except goto are definitely PVOP but
	 * goto is either a PVOP (with an ordinary constant label), an UNOP
	 * with OPf_STACKED (with a non-constant non-sub) or an UNOP for
	 * OP_REFGEN (with goto &sub) in which case OPf_STACKED also seems to
	 * get set.
	 */
	if (o->op_flags & OPf_STACKED)
	    return OPc_UNOP;
	else if (o->op_flags & OPf_SPECIAL)
	    return OPc_BASEOP;
	else
	    return OPc_PVOP;
    }
    warn("can't determine class of operator %s, assuming BASEOP\n",
	 OP_NAME(o));
    return OPc_BASEOP;
}

static SV *
make_op_object(pTHX_ const OP *o)
{
    SV *opsv = sv_newmortal();
    sv_setiv(newSVrv(opsv, opclassnames[cc_opclass(aTHX_ o)]), PTR2IV(o));
    return opsv;
}


static SV *
get_overlay_object(pTHX_ const OP *o, const char * const name, U32 namelen)
{
    HE *he;
    SV **svp;
    SV *key;
    SV *sv =get_sv("B::overlay", 0);
    if (!sv || !SvROK(sv))
	return NULL;
    sv = SvRV(sv);
    if (SvTYPE(sv) != SVt_PVHV)
	return NULL;
    key = newSViv(PTR2IV(o));
    he = hv_fetch_ent((HV*)sv, key, 0, 0);
    SvREFCNT_dec(key);
    if (!he)
	return NULL;
    sv = HeVAL(he);
    if (!sv || !SvROK(sv))
	return NULL;
    sv = SvRV(sv);
    if (SvTYPE(sv) != SVt_PVHV)
	return NULL;
    svp = hv_fetch((HV*)sv, name, namelen, 0);
    if (!svp)
	return NULL;
    sv = *svp;
    return sv;
}


static SV *
make_sv_object(pTHX_ SV *sv)
{
    SV *const arg = sv_newmortal();
    const char *type = 0;
    IV iv;
    dMY_CXT;

    for (iv = 0; iv < (IV)(sizeof(specialsv_list)/sizeof(SV*)); iv++) {
	if (sv == specialsv_list[iv]) {
	    type = "B::SPECIAL";
	    break;
	}
    }
    if (!type) {
	type = svclassnames[SvTYPE(sv)];
	iv = PTR2IV(sv);
    }
    sv_setiv(newSVrv(arg, type), iv);
    return arg;
}

static SV *
make_temp_object(pTHX_ SV *temp)
{
    SV *target;
    SV *arg = sv_newmortal();
    const char *const type = svclassnames[SvTYPE(temp)];
    const IV iv = PTR2IV(temp);

    target = newSVrv(arg, type);
    sv_setiv(target, iv);

    /* Need to keep our "temp" around as long as the target exists.
       Simplest way seems to be to hang it from magic, and let that clear
       it up.  No vtable, so won't actually get in the way of anything.  */
    sv_magicext(target, temp, PERL_MAGIC_sv, NULL, NULL, 0);
    /* magic object has had its reference count increased, so we must drop
       our reference.  */
    SvREFCNT_dec(temp);
    return arg;
}

static SV *
make_warnings_object(pTHX_ const COP *const cop)
{
    const STRLEN *const warnings = cop->cop_warnings;
    const char *type = 0;
    dMY_CXT;
    IV iv = sizeof(specialsv_list)/sizeof(SV*);

    /* Counting down is deliberate. Before the split between make_sv_object
       and make_warnings_obj there appeared to be a bug - Nullsv and pWARN_STD
       were both 0, so you could never get a B::SPECIAL for pWARN_STD  */

    while (iv--) {
	if ((SV*)warnings == specialsv_list[iv]) {
	    type = "B::SPECIAL";
	    break;
	}
    }
    if (type) {
	SV *arg = sv_newmortal();
	sv_setiv(newSVrv(arg, type), iv);
	return arg;
    } else {
	/* B assumes that warnings are a regular SV. Seems easier to keep it
	   happy by making them into a regular SV.  */
	return make_temp_object(aTHX_ newSVpvn((char *)(warnings + 1), *warnings));
    }
}

static SV *
make_cop_io_object(pTHX_ COP *cop)
{
    SV *const value = newSV(0);

    Perl_emulate_cop_io(aTHX_ cop, value);

    if(SvOK(value)) {
	return make_sv_object(aTHX_ value);
    } else {
	SvREFCNT_dec(value);
	return make_sv_object(aTHX_ NULL);
    }
}

static SV *
make_mg_object(pTHX_ MAGIC *mg)
{
    SV *arg = sv_newmortal();
    sv_setiv(newSVrv(arg, "B::MAGIC"), PTR2IV(mg));
    return arg;
}

static SV *
cstring(pTHX_ SV *sv, bool perlstyle)
{
    SV *sstr;

    if (!SvOK(sv))
	return newSVpvs_flags("0", SVs_TEMP);

    sstr = newSVpvs_flags("\"", SVs_TEMP);

    if (perlstyle && SvUTF8(sv)) {
	SV *tmpsv = sv_newmortal(); /* Temporary SV to feed sv_uni_display */
	const STRLEN len = SvCUR(sv);
	const char *s = sv_uni_display(tmpsv, sv, 8*len, UNI_DISPLAY_QQ);
	while (*s)
	{
	    if (*s == '"')
		sv_catpvs(sstr, "\\\"");
	    else if (*s == '$')
		sv_catpvs(sstr, "\\$");
	    else if (*s == '@')
		sv_catpvs(sstr, "\\@");
	    else if (*s == '\\')
	    {
		if (strchr("nrftax\\",*(s+1)))
		    sv_catpvn(sstr, s++, 2);
		else
		    sv_catpvs(sstr, "\\\\");
	    }
	    else /* should always be printable */
		sv_catpvn(sstr, s, 1);
	    ++s;
	}
    }
    else
    {
	/* XXX Optimise? */
	STRLEN len;
	const char *s = SvPV(sv, len);
	for (; len; len--, s++)
	{
	    /* At least try a little for readability */
	    if (*s == '"')
		sv_catpvs(sstr, "\\\"");
	    else if (*s == '\\')
		sv_catpvs(sstr, "\\\\");
            /* trigraphs - bleagh */
            else if (!perlstyle && *s == '?' && len>=3 && s[1] == '?') {
                Perl_sv_catpvf(aTHX_ sstr, "\\%03o", '?');
            }
	    else if (perlstyle && *s == '$')
		sv_catpvs(sstr, "\\$");
	    else if (perlstyle && *s == '@')
		sv_catpvs(sstr, "\\@");
	    else if (isPRINT(*s))
		sv_catpvn(sstr, s, 1);
	    else if (*s == '\n')
		sv_catpvs(sstr, "\\n");
	    else if (*s == '\r')
		sv_catpvs(sstr, "\\r");
	    else if (*s == '\t')
		sv_catpvs(sstr, "\\t");
	    else if (*s == '\a')
		sv_catpvs(sstr, "\\a");
	    else if (*s == '\b')
		sv_catpvs(sstr, "\\b");
	    else if (*s == '\f')
		sv_catpvs(sstr, "\\f");
	    else if (!perlstyle && *s == '\v')
		sv_catpvs(sstr, "\\v");
	    else
	    {
		/* Don't want promotion of a signed -1 char in sprintf args */
		const unsigned char c = (unsigned char) *s;
		Perl_sv_catpvf(aTHX_ sstr, "\\%03o", c);
	    }
	    /* XXX Add line breaks if string is long */
	}
    }
    sv_catpvs(sstr, "\"");
    return sstr;
}

static SV *
cchar(pTHX_ SV *sv)
{
    SV *sstr = newSVpvs_flags("'", SVs_TEMP);
    const char *s = SvPV_nolen(sv);
    /* Don't want promotion of a signed -1 char in sprintf args */
    const unsigned char c = (unsigned char) *s;

    if (c == '\'')
	sv_catpvs(sstr, "\\'");
    else if (c == '\\')
	sv_catpvs(sstr, "\\\\");
    else if (isPRINT(c))
	sv_catpvn(sstr, s, 1);
    else if (c == '\n')
	sv_catpvs(sstr, "\\n");
    else if (c == '\r')
	sv_catpvs(sstr, "\\r");
    else if (c == '\t')
	sv_catpvs(sstr, "\\t");
    else if (c == '\a')
	sv_catpvs(sstr, "\\a");
    else if (c == '\b')
	sv_catpvs(sstr, "\\b");
    else if (c == '\f')
	sv_catpvs(sstr, "\\f");
    else if (c == '\v')
	sv_catpvs(sstr, "\\v");
    else
	Perl_sv_catpvf(aTHX_ sstr, "\\%03o", c);
    sv_catpvs(sstr, "'");
    return sstr;
}

#define PMOP_pmreplstart(o)	o->op_pmstashstartu.op_pmreplstart
#define PMOP_pmreplroot(o)	o->op_pmreplrootu.op_pmreplroot

static SV *
walkoptree(pTHX_ OP *o, const char *method, SV *ref)
{
    dSP;
    OP *kid;
    SV *object;
    const char *const classname = opclassnames[cc_opclass(aTHX_ o)];
    dMY_CXT;

    /* Check that no-one has changed our reference, or is holding a reference
       to it.  */
    if (SvREFCNT(ref) == 1 && SvROK(ref) && SvTYPE(ref) == SVt_RV
	&& (object = SvRV(ref)) && SvREFCNT(object) == 1
	&& SvTYPE(object) == SVt_PVMG && SvIOK_only(object)
	&& !SvMAGICAL(object) && !SvMAGIC(object) && SvSTASH(object)) {
	/* Looks good, so rebless it for the class we need:  */
	sv_bless(ref, gv_stashpv(classname, GV_ADD));
    } else {
	/* Need to make a new one. */
	ref = sv_newmortal();
	object = newSVrv(ref, classname);
    }
    sv_setiv(object, PTR2IV(o));

    if (walkoptree_debug) {
	PUSHMARK(sp);
	XPUSHs(ref);
	PUTBACK;
	perl_call_method("walkoptree_debug", G_DISCARD);
    }
    PUSHMARK(sp);
    XPUSHs(ref);
    PUTBACK;
    perl_call_method(method, G_DISCARD);
    if (o && (o->op_flags & OPf_KIDS)) {
	for (kid = ((UNOP*)o)->op_first; kid; kid = kid->op_sibling) {
	    ref = walkoptree(aTHX_ kid, method, ref);
	}
    }
    if (o && (cc_opclass(aTHX_ o) == OPc_PMOP) && o->op_type != OP_PUSHRE
           && (kid = PMOP_pmreplroot(cPMOPo)))
    {
	ref = walkoptree(aTHX_ kid, method, ref);
    }
    return ref;
}

static SV **
oplist(pTHX_ OP *o, SV **SP)
{
    for(; o; o = o->op_next) {
	if (o->op_opt == 0)
	    break;
	o->op_opt = 0;
	XPUSHs(make_op_object(aTHX_ o));
        switch (o->op_type) {
	case OP_SUBST:
            SP = oplist(aTHX_ PMOP_pmreplstart(cPMOPo), SP);
            continue;
	case OP_SORT:
	    if (o->op_flags & OPf_STACKED && o->op_flags & OPf_SPECIAL) {
		OP *kid = cLISTOPo->op_first->op_sibling;   /* pass pushmark */
		kid = kUNOP->op_first;                      /* pass rv2gv */
		kid = kUNOP->op_first;                      /* pass leave */
		SP = oplist(aTHX_ kid->op_next, SP);
	    }
	    continue;
        }
	switch (PL_opargs[o->op_type] & OA_CLASS_MASK) {
	case OA_LOGOP:
	    SP = oplist(aTHX_ cLOGOPo->op_other, SP);
	    break;
	case OA_LOOP:
	    SP = oplist(aTHX_ cLOOPo->op_lastop, SP);
	    SP = oplist(aTHX_ cLOOPo->op_nextop, SP);
	    SP = oplist(aTHX_ cLOOPo->op_redoop, SP);
	    break;
	}
    }
    return SP;
}

typedef OP	*B__OP;
typedef UNOP	*B__UNOP;
typedef BINOP	*B__BINOP;
typedef LOGOP	*B__LOGOP;
typedef LISTOP	*B__LISTOP;
typedef PMOP	*B__PMOP;
typedef SVOP	*B__SVOP;
typedef PADOP	*B__PADOP;
typedef PVOP	*B__PVOP;
typedef LOOP	*B__LOOP;
typedef COP	*B__COP;

typedef SV	*B__SV;
typedef SV	*B__IV;
typedef SV	*B__PV;
typedef SV	*B__NV;
typedef SV	*B__PVMG;
#if PERL_VERSION >= 11
typedef SV	*B__REGEXP;
#endif
typedef SV	*B__PVLV;
typedef SV	*B__BM;
typedef SV	*B__RV;
typedef SV	*B__FM;
typedef AV	*B__AV;
typedef HV	*B__HV;
typedef CV	*B__CV;
typedef GV	*B__GV;
typedef IO	*B__IO;

typedef MAGIC	*B__MAGIC;
typedef HE      *B__HE;
typedef struct refcounted_he	*B__RHE;
#ifdef PadlistARRAY
typedef PADLIST	*B__PADLIST;
#endif

#ifdef MULTIPLICITY
#  define ASSIGN_COMMON_ALIAS(prefix, var) \
    STMT_START { XSANY.any_i32 = offsetof(struct interpreter, prefix##var); } STMT_END
#else
#  define ASSIGN_COMMON_ALIAS(prefix, var) \
    STMT_START { XSANY.any_ptr = (void *)&PL_##var; } STMT_END
#endif

/* This needs to be ALIASed in a custom way, hence can't easily be defined as
   a regular XSUB.  */
static XSPROTO(intrpvar_sv_common); /* prototype to pass -Wmissing-prototypes */
static XSPROTO(intrpvar_sv_common)
{
    dVAR;
    dXSARGS;
    SV *ret;
    if (items != 0)
       croak_xs_usage(cv,  "");
#ifdef MULTIPLICITY
    ret = *(SV **)(XSANY.any_i32 + (char *)my_perl);
#else
    ret = *(SV **)(XSANY.any_ptr);
#endif
    ST(0) = make_sv_object(aTHX_ ret);
    XSRETURN(1);
}



#define SVp                 0x0
#define U32p                0x1
#define line_tp             0x2
#define OPp                 0x3
#define PADOFFSETp          0x4
#define U8p                 0x5
#define IVp                 0x6
#define char_pp             0x7
/* Keep this last:  */
#define op_offset_special   0x8

/* table that drives most of the B::*OP methods */

struct OP_methods {
    const char *name;
    U8 namelen;
    U8    type; /* if op_offset_special, access is handled on a case-by-case basis */
    U16 offset;
} op_methods[] = {
  { STR_WITH_LEN("next"),    OPp,    offsetof(struct op, op_next),     },/* 0*/
  { STR_WITH_LEN("sibling"), OPp,    offsetof(struct op, op_sibling),  },/* 1*/
  { STR_WITH_LEN("targ"),    PADOFFSETp, offsetof(struct op, op_targ), },/* 2*/
  { STR_WITH_LEN("flags"),   U8p,    offsetof(struct op, op_flags),    },/* 3*/
  { STR_WITH_LEN("private"), U8p,    offsetof(struct op, op_private),  },/* 4*/
  { STR_WITH_LEN("first"),   OPp,    offsetof(struct unop, op_first),  },/* 5*/
  { STR_WITH_LEN("last"),    OPp,    offsetof(struct binop, op_last),  },/* 6*/
  { STR_WITH_LEN("other"),   OPp,    offsetof(struct logop, op_other), },/* 7*/
  { STR_WITH_LEN("pmreplstart"), op_offset_special, 0,                 },/* 8*/
  { STR_WITH_LEN("redoop"),  OPp,    offsetof(struct loop, op_redoop), },/* 9*/
  { STR_WITH_LEN("nextop"),  OPp,    offsetof(struct loop, op_nextop), },/*10*/
  { STR_WITH_LEN("lastop"),  OPp,    offsetof(struct loop, op_lastop), },/*11*/
  { STR_WITH_LEN("pmflags"), U32p,   offsetof(struct pmop, op_pmflags),},/*12*/
#if PERL_VERSION >= 17
  { STR_WITH_LEN("code_list"),OPp,   offsetof(struct pmop, op_code_list),},/*13*/
#else
  { STR_WITH_LEN("code_list"),op_offset_special, 0,
#endif
  { STR_WITH_LEN("sv"),      SVp,     offsetof(struct svop, op_sv),    },/*14*/
  { STR_WITH_LEN("gv"),      SVp,     offsetof(struct svop, op_sv),    },/*15*/
  { STR_WITH_LEN("padix"),   PADOFFSETp,offsetof(struct padop, op_padix),},/*16*/
  { STR_WITH_LEN("cop_seq"), U32p,    offsetof(struct cop, cop_seq),   },/*17*/
  { STR_WITH_LEN("line"),    line_tp, offsetof(struct cop, cop_line),  },/*18*/
  { STR_WITH_LEN("hints"),   U32p,    offsetof(struct cop, cop_hints), },/*19*/
#ifdef USE_ITHREADS
  { STR_WITH_LEN("pmoffset"),IVp,     offsetof(struct pmop, op_pmoffset),},/*20*/
  { STR_WITH_LEN("filegv"),  op_offset_special, 0,                     },/*21*/
  { STR_WITH_LEN("file"),    char_pp, offsetof(struct cop, cop_file),  },/*22*/
  { STR_WITH_LEN("stash"),   op_offset_special, 0,                     },/*23*/
#  if PERL_VERSION < 17
  { STR_WITH_LEN("stashpv"), char_pp, offsetof(struct cop, cop_stashpv),}, /*24*/
  { STR_WITH_LEN("stashoff"),op_offset_special, 0,                     },/*25*/
#  else
  { STR_WITH_LEN("stashpv"), op_offset_special, 0,                     },/*24*/
  { STR_WITH_LEN("stashoff"),PADOFFSETp,offsetof(struct cop,cop_stashoff),},/*25*/
#  endif
#else
  { STR_WITH_LEN("pmoffset"),op_offset_special, 0,                     },/*20*/
  { STR_WITH_LEN("filegv"),  SVp,     offsetof(struct cop, cop_filegv),},/*21*/
  { STR_WITH_LEN("file"),    op_offset_special, 0,                     },/*22*/
  { STR_WITH_LEN("stash"),   SVp,     offsetof(struct cop, cop_stash), },/*23*/
  { STR_WITH_LEN("stashpv"), op_offset_special, 0,                     },/*24*/
  { STR_WITH_LEN("stashoff"),op_offset_special, 0,                     },/*25*/
#endif
  { STR_WITH_LEN("size"),    op_offset_special, 0,                     },/*26*/
  { STR_WITH_LEN("name"),    op_offset_special, 0,                     },/*27*/
  { STR_WITH_LEN("desc"),    op_offset_special, 0,                     },/*28*/
  { STR_WITH_LEN("ppaddr"),  op_offset_special, 0,                     },/*29*/
  { STR_WITH_LEN("type"),    op_offset_special, 0,                     },/*30*/
  { STR_WITH_LEN("opt"),     op_offset_special, 0,                     },/*31*/
  { STR_WITH_LEN("spare"),   op_offset_special, 0,                     },/*32*/
  { STR_WITH_LEN("children"),op_offset_special, 0,                     },/*33*/
  { STR_WITH_LEN("pmreplroot"), op_offset_special, 0,                  },/*34*/
  { STR_WITH_LEN("pmstashpv"), op_offset_special, 0,                   },/*35*/
  { STR_WITH_LEN("pmstash"), op_offset_special, 0,                     },/*36*/
  { STR_WITH_LEN("precomp"), op_offset_special, 0,                     },/*37*/
  { STR_WITH_LEN("reflags"), op_offset_special, 0,                     },/*38*/
  { STR_WITH_LEN("sv"),      op_offset_special, 0,                     },/*39*/
  { STR_WITH_LEN("gv"),      op_offset_special, 0,                     },/*40*/
  { STR_WITH_LEN("pv"),      op_offset_special, 0,                     },/*41*/
  { STR_WITH_LEN("label"),   op_offset_special, 0,                     },/*42*/
  { STR_WITH_LEN("arybase"), op_offset_special, 0,                     },/*43*/
  { STR_WITH_LEN("warnings"),op_offset_special, 0,                     },/*44*/
  { STR_WITH_LEN("io"),      op_offset_special, 0,                     },/*45*/
  { STR_WITH_LEN("hints_hash"),op_offset_special, 0,                   },/*46*/
#if PERL_VERSION >= 17
  { STR_WITH_LEN("slabbed"), op_offset_special, 0,                     },/*47*/
  { STR_WITH_LEN("savefree"),op_offset_special, 0,                     },/*48*/
  { STR_WITH_LEN("static"),  op_offset_special, 0,                     },/*49*/
#  if PERL_VERSION >= 19
  { STR_WITH_LEN("folded"),  op_offset_special, 0,                     },/*50*/
#  endif
#endif
};

#include "const-c.inc"

#line 750 "B.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 892 "B.c"

/* INCLUDE:  Including 'const-xs.inc' from 'B.xs' */


/* INCLUDE: Returning to 'B.xs' from 'const-xs.inc' */

#ifndef PL_formfeed
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_B_formfeed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_formfeed)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 796 "B.xs"
	PUSHs(make_sv_object(aTHX_ GvSV(gv_fetchpvs("\f", GV_ADD, SVt_PV))));
#line 914 "B.c"
	PUTBACK;
	return;
    }
}

#endif

XS_EUPXS(XS_B_amagic_generation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_amagic_generation)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	long	RETVAL;
	dXSTARG;
#line 803 "B.xs"
	RETVAL = PL_amagic_generation;
#line 933 "B.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B_comppadlist); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_comppadlist)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 810 "B.xs"
	PADLIST *padlist = CvPADLIST(PL_main_cv ? PL_main_cv : PL_compcv);
#line 951 "B.c"
#line 812 "B.xs"
#ifdef PadlistARRAY
	{
	    SV * const rv = sv_newmortal();
	    sv_setiv(newSVrv(rv, padlist ? "B::PADLIST" : "B::NULL"),
		     PTR2IV(padlist));
	    PUSHs(rv);
	}
#else
	PUSHs(make_sv_object(aTHX_ (SV *)padlist));
#endif
#line 963 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B_sv_undef); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_sv_undef)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 829 "B.xs"
	PUSHs(make_sv_object(aTHX_ ix > 1 ? &PL_sv_yes
					  : ix < 1 ? &PL_sv_undef
						   : &PL_sv_no));
#line 984 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B_main_root); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_main_root)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 838 "B.xs"
	PUSHs(make_op_object(aTHX_ ix ? PL_main_start : PL_main_root));
#line 1003 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B_sub_generation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_sub_generation)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	UV	RETVAL;
	dXSTARG;
#line 845 "B.xs"
	RETVAL = ix ? PL_dowarn : PL_sub_generation;
#line 1022 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B_walkoptree); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_walkoptree)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "op, method");
    {
	B__OP	op;
	const char *	method = (const char *)SvPV_nolen(ST(1))
;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    op = INT2PTR(B__OP,tmp);
	}
	else
	    croak("op is not a reference")
;
#line 854 "B.xs"
	(void) walkoptree(aTHX_ op, method, &PL_sv_undef);
#line 1049 "B.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_B_walkoptree_debug); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_walkoptree_debug)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	RETVAL;
	dXSTARG;
#line 859 "B.xs"
	dMY_CXT;
	RETVAL = walkoptree_debug;
	if (items > 0 && SvTRUE(ST(1)))
	    walkoptree_debug = 1;
#line 1068 "B.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#define address(sv) PTR2IV(sv)

XS_EUPXS(XS_B_address); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_address)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0)
;
	IV	RETVAL;
	dXSTARG;

	RETVAL = address(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B_svref_2object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_svref_2object)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sv = ST(0)
;
#line 876 "B.xs"
	if (!SvROK(sv))
	    croak("argument is not a reference");
	PUSHs(make_sv_object(aTHX_ SvRV(sv)));
#line 1110 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B_opnumber); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_opnumber)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	const char *	name = (const char *)SvPV_nolen(ST(0))
;
#line 884 "B.xs"
{
 int i; 
 IV  result = -1;
 ST(0) = sv_newmortal();
 if (strncmp(name,"pp_",3) == 0)
   name += 3;
 for (i = 0; i < PL_maxo; i++)
  {
   if (strcmp(name, PL_op_name[i]) == 0)
    {
     result = i;
     break;
    }
  }
 sv_setiv(ST(0),result);
}
#line 1143 "B.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B_ppname); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_ppname)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "opnum");
    {
	int	opnum = (int)SvIV(ST(0))
;
#line 905 "B.xs"
	ST(0) = sv_newmortal();
	if (opnum >= 0 && opnum < PL_maxo)
	    Perl_sv_setpvf(aTHX_ ST(0), "pp_%s", PL_op_name[opnum]);
#line 1162 "B.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B_hash); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_hash)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0)
;
#line 913 "B.xs"
	STRLEN len;
	U32 hash = 0;
	const char *s = SvPVbyte(sv, len);
	PERL_HASH(hash, s, len);
	ST(0) = sv_2mortal(Perl_newSVpvf(aTHX_ "0x%"UVxf, (UV)hash));
#line 1183 "B.c"
    }
    XSRETURN(1);
}

#define cast_I32(foo) (I32)foo

XS_EUPXS(XS_B_cast_I32); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_cast_I32)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	IV	i = (IV)SvIV(ST(0))
;
	IV	RETVAL;
	dXSTARG;

	RETVAL = cast_I32(i);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B_minus_c); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_minus_c)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 929 "B.xs"
	if (ix)
	    PL_savebegin = TRUE;
	else
	    PL_minus_c = TRUE;
#line 1222 "B.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_B_cstring); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_cstring)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sv = ST(0)
;
#line 941 "B.xs"
	PUSHs(ix == 2 ? cchar(aTHX_ sv) : cstring(aTHX_ sv, (bool)ix));
#line 1242 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B_threadsv_names); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_threadsv_names)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 945 "B.xs"
#line 1259 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__OP_next); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__OP_next)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__OP	o;
#line 1012 "B.xs"
	SV *ret;
#line 1279 "B.c"

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 1014 "B.xs"
	if (ix < 0 || (U32)ix >= C_ARRAY_LENGTH(op_methods))
	    croak("Illegal alias %d for B::*OP::next", (int)ix);
	ret = get_overlay_object(aTHX_ o,
			    op_methods[ix].name, op_methods[ix].namelen);
	if (ret) {
	    ST(0) = ret;
	    XSRETURN(1);
	}

	/* handle non-direct field access */

	if (op_methods[ix].type == op_offset_special)
	    switch (ix) {
	    case 8: /* pmreplstart */
		ret = make_op_object(aTHX_
				cPMOPo->op_type == OP_SUBST
				    ?  cPMOPo->op_pmstashstartu.op_pmreplstart
				    : NULL
		      );
		break;
#ifdef USE_ITHREADS
	    case 21: /* filegv */
		ret = make_sv_object(aTHX_ (SV *)CopFILEGV((COP*)o));
		break;
#endif
#ifndef USE_ITHREADS
	    case 22: /* file */
		ret = sv_2mortal(newSVpv(CopFILE((COP*)o), 0));
		break;
#endif
#ifdef USE_ITHREADS
	    case 23: /* stash */
		ret = make_sv_object(aTHX_ (SV *)CopSTASH((COP*)o));
		break;
#endif
#if PERL_VERSION >= 17 || !defined USE_ITHREADS
	    case 24: /* stashpv */
#  if PERL_VERSION >= 17
		ret = sv_2mortal(CopSTASH((COP*)o)
				&& SvTYPE(CopSTASH((COP*)o)) == SVt_PVHV
		    ? newSVhek(HvNAME_HEK(CopSTASH((COP*)o)))
		    : &PL_sv_undef);
#  else
		ret = sv_2mortal(newSVpv(CopSTASHPV((COP*)o), 0));
#  endif
		break;
#endif
	    case 26: /* size */
		ret = sv_2mortal(newSVuv((UV)(opsizes[cc_opclass(aTHX_ o)])));
		break;
	    case 27: /* name */
	    case 28: /* desc */
		ret = sv_2mortal(newSVpv(
			    (char *)(ix == 28 ? OP_DESC(o) : OP_NAME(o)), 0));
		break;
	    case 29: /* ppaddr */
		{
		    int i;
		    ret = sv_2mortal(Perl_newSVpvf(aTHX_ "PL_ppaddr[OP_%s]",
						  PL_op_name[o->op_type]));
		    for (i=13; (STRLEN)i < SvCUR(ret); ++i)
			SvPVX(ret)[i] = toUPPER(SvPVX(ret)[i]);
		}
		break;
	    case 30: /* type  */
	    case 31: /* opt   */
	    case 32: /* spare */
#if PERL_VERSION >= 17
	    case 47: /* slabbed  */
	    case 48: /* savefree */
	    case 49: /* static   */
#if PERL_VERSION >= 19
	    case 50: /* folded   */
#endif
#endif
	    /* These are all bitfields, so we can't take their addresses */
		ret = sv_2mortal(newSVuv((UV)(
				      ix == 30 ? o->op_type
		                    : ix == 31 ? o->op_opt
		                    : ix == 47 ? o->op_slabbed
		                    : ix == 48 ? o->op_savefree
		                    : ix == 49 ? o->op_static
		                    : ix == 50 ? o->op_folded
		                    :            o->op_spare)));
		break;
	    case 33: /* children */
		{
		    OP *kid;
		    UV i = 0;
		    for (kid = ((LISTOP*)o)->op_first; kid; kid = kid->op_sibling)
			i++;
		    ret = sv_2mortal(newSVuv(i));
		}
		break;
	    case 34: /* pmreplroot */
		if (cPMOPo->op_type == OP_PUSHRE) {
#ifdef USE_ITHREADS
		    ret = sv_newmortal();
		    sv_setiv(ret, cPMOPo->op_pmreplrootu.op_pmtargetoff);
#else
		    GV *const target = cPMOPo->op_pmreplrootu.op_pmtargetgv;
		    ret = sv_newmortal();
		    sv_setiv(newSVrv(ret, target ?
				     svclassnames[SvTYPE((SV*)target)] : "B::SV"),
			     PTR2IV(target));
#endif
		}
		else {
		    OP *const root = cPMOPo->op_pmreplrootu.op_pmreplroot;
		    ret = make_op_object(aTHX_ root);
		}
		break;
#ifdef USE_ITHREADS
	    case 35: /* pmstashpv */
		ret = sv_2mortal(newSVpv(PmopSTASHPV(cPMOPo),0));
		break;
#else
	    case 36: /* pmstash */
		ret = make_sv_object(aTHX_ (SV *) PmopSTASH(cPMOPo));
		break;
#endif
	    case 37: /* precomp */
	    case 38: /* reflags */
		{
		    REGEXP *rx = PM_GETRE(cPMOPo);
		    ret = sv_newmortal();
		    if (rx) {
			if (ix==38) {
			    sv_setuv(ret, RX_EXTFLAGS(rx));
			}
			else {
			    sv_setpvn(ret, RX_PRECOMP(rx), RX_PRELEN(rx));
                            if (RX_UTF8(rx))
                                SvUTF8_on(ret);
			}
		    }
		}
		break;
	    case 39: /* sv */
	    case 40: /* gv */
		/* It happens that the output typemaps for B::SV and B::GV
		 * are identical. The "smarts" are in make_sv_object(),
		 * which determines which class to use based on SvTYPE(),
		 * rather than anything baked in at compile time.  */
		if (cPADOPo->op_padix) {
		    ret = PAD_SVl(cPADOPo->op_padix);
		    if (ix == 40 && SvTYPE(ret) != SVt_PVGV)
			ret = NULL;
		} else {
		    ret = NULL;
		}
		ret = make_sv_object(aTHX_ ret);
		break;
	    case 41: /* pv */
		/* OP_TRANS uses op_pv to point to a table of 256 or >=258
		 * shorts whereas other PVOPs point to a null terminated
		 * string.  */
		if (    (cPVOPo->op_type == OP_TRANS
			|| cPVOPo->op_type == OP_TRANSR) &&
			(cPVOPo->op_private & OPpTRANS_COMPLEMENT) &&
			!(cPVOPo->op_private & OPpTRANS_DELETE))
		{
		    const short* const tbl = (short*)cPVOPo->op_pv;
		    const short entries = 257 + tbl[256];
		    ret = newSVpvn_flags(cPVOPo->op_pv, entries * sizeof(short), SVs_TEMP);
		}
		else if (cPVOPo->op_type == OP_TRANS || cPVOPo->op_type == OP_TRANSR) {
		    ret = newSVpvn_flags(cPVOPo->op_pv, 256 * sizeof(short), SVs_TEMP);
		}
		else
		    ret = newSVpvn_flags(cPVOPo->op_pv, strlen(cPVOPo->op_pv), SVs_TEMP);
		break;
	    case 42: /* label */
		ret = sv_2mortal(newSVpv(CopLABEL(cCOPo),0));
		break;
	    case 43: /* arybase */
		ret = sv_2mortal(newSVuv(0));
		break;
	    case 44: /* warnings */
		ret = make_warnings_object(aTHX_ cCOPo);
		break;
	    case 45: /* io */
		ret = make_cop_io_object(aTHX_ cCOPo);
		break;
	    case 46: /* hints_hash */
		ret = sv_newmortal();
		sv_setiv(newSVrv(ret, "B::RHE"),
			PTR2IV(CopHINTHASH_get(cCOPo)));
		break;
	    default:
		croak("method %s not implemented", op_methods[ix].name);
	} else {
	    /* do a direct structure offset lookup */
	    const char *const ptr = (char *)o + op_methods[ix].offset;
	    switch (op_methods[ix].type) {
	    case OPp:
		ret = make_op_object(aTHX_ *((OP **)ptr));
		break;
	    case PADOFFSETp:
		ret = sv_2mortal(newSVuv(*((PADOFFSET*)ptr)));
		break;
	    case U8p:
		ret = sv_2mortal(newSVuv(*((U8*)ptr)));
		break;
	    case U32p:
		ret = sv_2mortal(newSVuv(*((U32*)ptr)));
		break;
	    case SVp:
		ret = make_sv_object(aTHX_ *((SV **)ptr));
		break;
	    case line_tp:
		ret = sv_2mortal(newSVuv(*((line_t *)ptr)));
		break;
	    case IVp:
		ret = sv_2mortal(newSViv(*((IV*)ptr)));
		break;
	    case char_pp:
		ret = sv_2mortal(newSVpv(*((char **)ptr), 0));
		break;
	    default:
		croak("Illegal type 0x%x for B::*OP::%s",
		      (unsigned)op_methods[ix].type, op_methods[ix].name);
	    }
	}
	ST(0) = ret;
	XSRETURN(1);
#line 1515 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__OP_oplist); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__OP_oplist)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__OP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 1246 "B.xs"
	SP = oplist(aTHX_ o, SP);
#line 1542 "B.c"
	PUTBACK;
	return;
    }
}

#define MAGICAL_FLAG_BITS (SVs_GMG|SVs_SMG|SVs_RMG)

XS_EUPXS(XS_B__SV_REFCNT); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__SV_REFCNT)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1263 "B.xs"
	RETVAL = ix ? (SvFLAGS(sv) & (U32)ix) : SvREFCNT(sv);
#line 1571 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__SV_object_2svref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__SV_object_2svref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__SV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1271 "B.xs"
	ST(0) = sv_2mortal(newRV(sv));
	XSRETURN(1);
#line 1599 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__IV_IV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__IV_IV)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__IV	sv;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference")
;

	RETVAL = SvIV(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#define sv_SVp		0x00000
#define sv_IVp		0x10000
#define sv_UVp		0x20000
#define sv_STRLENp	0x30000
#define sv_U32p		0x40000
#define sv_U8p		0x50000
#define sv_char_pp	0x60000
#define sv_NVp		0x70000
#define sv_char_p	0x80000
#define sv_SSize_tp	0x90000
#define sv_I32p		0xA0000
#define sv_U16p		0xB0000
#define IV_ivx_ix	sv_IVp | offsetof(struct xpviv, xiv_iv)
#define IV_uvx_ix	sv_UVp | offsetof(struct xpvuv, xuv_uv)
#define NV_nvx_ix	sv_NVp | offsetof(struct xpvnv, xnv_u.xnv_nv)
#define NV_cop_seq_range_low_ix \
			sv_U32p | offsetof(struct xpvnv, xnv_u.xpad_cop_seq.xlow)
#define NV_cop_seq_range_high_ix \
			sv_U32p | offsetof(struct xpvnv, xnv_u.xpad_cop_seq.xhigh)
#define NV_parent_pad_index_ix \
			sv_U32p | offsetof(struct xpvnv, xnv_u.xpad_cop_seq.xlow)
#define NV_parent_fakelex_flags_ix \
			sv_U32p | offsetof(struct xpvnv, xnv_u.xpad_cop_seq.xhigh)
#define PV_cur_ix	sv_STRLENp | offsetof(struct xpv, xpv_cur)
#define PV_len_ix	sv_STRLENp | offsetof(struct xpv, xpv_len)
#define PVMG_stash_ix	sv_SVp | offsetof(struct xpvmg, xmg_stash)
#if PERL_VERSION > 18
#    define PVBM_useful_ix	sv_IVp | offsetof(struct xpviv, xiv_u.xivu_iv)
#elif PERL_VERSION > 14
#    define PVBM_useful_ix	sv_I32p | offsetof(struct xpvgv, xnv_u.xbm_s.xbm_useful)
#else
#define PVBM_useful_ix	sv_I32p | offsetof(struct xpvgv, xiv_u.xivu_i32)
#endif
#define PVLV_targoff_ix	sv_U32p | offsetof(struct xpvlv, xlv_targoff)
#define PVLV_targlen_ix	sv_U32p | offsetof(struct xpvlv, xlv_targlen)
#define PVLV_targ_ix	sv_SVp | offsetof(struct xpvlv, xlv_targ)
#define PVLV_type_ix	sv_char_p | offsetof(struct xpvlv, xlv_type)
#define PVGV_stash_ix	sv_SVp | offsetof(struct xpvgv, xnv_u.xgv_stash)
#define PVGV_flags_ix	sv_STRLENp | offsetof(struct xpvgv, xpv_cur)
#define PVIO_lines_ix	sv_IVp | offsetof(struct xpvio, xiv_iv)
#define PVIO_page_ix	    sv_IVp | offsetof(struct xpvio, xio_page)
#define PVIO_page_len_ix    sv_IVp | offsetof(struct xpvio, xio_page_len)
#define PVIO_lines_left_ix  sv_IVp | offsetof(struct xpvio, xio_lines_left)
#define PVIO_top_name_ix    sv_char_pp | offsetof(struct xpvio, xio_top_name)
#define PVIO_top_gv_ix	    sv_SVp | offsetof(struct xpvio, xio_top_gv)
#define PVIO_fmt_name_ix    sv_char_pp | offsetof(struct xpvio, xio_fmt_name)
#define PVIO_fmt_gv_ix	    sv_SVp | offsetof(struct xpvio, xio_fmt_gv)
#define PVIO_bottom_name_ix sv_char_pp | offsetof(struct xpvio, xio_bottom_name)
#define PVIO_bottom_gv_ix   sv_SVp | offsetof(struct xpvio, xio_bottom_gv)
#define PVIO_type_ix	    sv_char_p | offsetof(struct xpvio, xio_type)
#define PVIO_flags_ix	    sv_U8p | offsetof(struct xpvio, xio_flags)
#define PVAV_max_ix	sv_SSize_tp | offsetof(struct xpvav, xav_max)
#define PVCV_stash_ix	sv_SVp | offsetof(struct xpvcv, xcv_stash) 
#if PERL_VERSION > 17 || (PERL_VERSION == 17 && PERL_SUBVERSION >= 3)
# define PVCV_gv_ix	sv_SVp | offsetof(struct xpvcv, xcv_gv_u.xcv_gv)
#else
# define PVCV_gv_ix	sv_SVp | offsetof(struct xpvcv, xcv_gv)
#endif
#define PVCV_file_ix	sv_char_pp | offsetof(struct xpvcv, xcv_file)
#define PVCV_outside_ix	sv_SVp | offsetof(struct xpvcv, xcv_outside)
#define PVCV_outside_seq_ix sv_U32p | offsetof(struct xpvcv, xcv_outside_seq)
#define PVCV_flags_ix	sv_U32p | offsetof(struct xpvcv, xcv_flags)
#define PVHV_max_ix	sv_STRLENp | offsetof(struct xpvhv, xhv_max)
#if PERL_VERSION > 12
#define PVHV_keys_ix	sv_STRLENp | offsetof(struct xpvhv, xhv_keys)
#else
#define PVHV_keys_ix	sv_IVp | offsetof(struct xpvhv, xhv_keys)
#endif

XS_EUPXS(XS_B__IV_IVX); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__IV_IVX)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__SV	sv;
#line 1408 "B.xs"
	char *ptr;
	SV *ret;
#line 1714 "B.c"

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1411 "B.xs"
	ptr = (ix & 0xFFFF) + (char *)SvANY(sv);
	switch ((U8)(ix >> 16)) {
	case (U8)(sv_SVp >> 16):
	    ret = make_sv_object(aTHX_ *((SV **)ptr));
	    break;
	case (U8)(sv_IVp >> 16):
	    ret = sv_2mortal(newSViv(*((IV *)ptr)));
	    break;
	case (U8)(sv_UVp >> 16):
	    ret = sv_2mortal(newSVuv(*((UV *)ptr)));
	    break;
	case (U8)(sv_STRLENp >> 16):
	    ret = sv_2mortal(newSVuv(*((STRLEN *)ptr)));
	    break;
	case (U8)(sv_U32p >> 16):
	    ret = sv_2mortal(newSVuv(*((U32 *)ptr)));
	    break;
	case (U8)(sv_U8p >> 16):
	    ret = sv_2mortal(newSVuv(*((U8 *)ptr)));
	    break;
	case (U8)(sv_char_pp >> 16):
	    ret = sv_2mortal(newSVpv(*((char **)ptr), 0));
	    break;
	case (U8)(sv_NVp >> 16):
	    ret = sv_2mortal(newSVnv(*((NV *)ptr)));
	    break;
	case (U8)(sv_char_p >> 16):
	    ret = newSVpvn_flags((char *)ptr, 1, SVs_TEMP);
	    break;
	case (U8)(sv_SSize_tp >> 16):
	    ret = sv_2mortal(newSViv(*((SSize_t *)ptr)));
	    break;
	case (U8)(sv_I32p >> 16):
	    ret = sv_2mortal(newSVuv(*((I32 *)ptr)));
	    break;
	case (U8)(sv_U16p >> 16):
	    ret = sv_2mortal(newSVuv(*((U16 *)ptr)));
	    break;
	default:
	    croak("Illegal alias 0x%08x for B::*IVX", (unsigned)ix);
	}
	ST(0) = ret;
	XSRETURN(1);
#line 1767 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__IV_packiv); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__IV_packiv)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__IV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1461 "B.xs"
	if (ix) {
	    ST(0) = boolSV((I32)SvIVX(sv) != SvIVX(sv));
	} else if (sizeof(IV) == 8) {
	    U32 wp[2];
	    const IV iv = SvIVX(sv);
	    /*
	     * The following way of spelling 32 is to stop compilers on
	     * 32-bit architectures from moaning about the shift count
	     * being >= the width of the type. Such architectures don't
	     * reach this code anyway (unless sizeof(IV) > 8 but then
	     * everything else breaks too so I'm not fussed at the moment).
	     */
#ifdef UV_IS_QUAD
	    wp[0] = htonl(((UV)iv) >> (sizeof(UV)*4));
#else
	    wp[0] = htonl(((U32)iv) >> (sizeof(UV)*4));
#endif
	    wp[1] = htonl(iv & 0xffffffff);
	    ST(0) = newSVpvn_flags((char *)wp, 8, SVs_TEMP);
	} else {
	    U32 w = htonl((U32)SvIVX(sv));
	    ST(0) = newSVpvn_flags((char *)&w, 4, SVs_TEMP);
	}
#line 1815 "B.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__NV_NV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__NV_NV)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__NV	sv;
	NV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference")
;

	RETVAL = SvNV(sv);
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION < 11
#define XSubPPtmpAAAB 1


XS_EUPXS(XS_B__RV_RV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__RV_RV)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__RV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__RV,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1499 "B.xs"
	PUSHs(make_sv_object(aTHX_ SvRV(sv)));
#line 1870 "B.c"
	PUTBACK;
	return;
    }
}

#else
#define XSubPPtmpAAAC 1


XS_EUPXS(XS_B__REGEXP_REGEX); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__REGEXP_REGEX)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__REGEXP	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__REGEXP,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1511 "B.xs"
	if (ix) {
	    PUSHs(newSVpvn_flags(RX_PRECOMP(sv), RX_PRELEN(sv), SVs_TEMP));
	} else {
	    dXSTARG;
	    /* FIXME - can we code this method more efficiently?  */
	    PUSHi(PTR2IV(sv));
	}
#line 1907 "B.c"
	PUTBACK;
	return;
    }
}

#endif

XS_EUPXS(XS_B__PV_RV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PV_RV)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__PV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1527 "B.xs"
        if (!SvROK(sv))
            croak( "argument is not SvROK" );
	PUSHs(make_sv_object(aTHX_ SvRV(sv)));
#line 1937 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__PV_PV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PV_PV)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PV	sv;
#line 1539 "B.xs"
	const char *p;
	STRLEN len = 0;
	U32 utf8 = 0;
#line 1957 "B.c"

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1543 "B.xs"
	if (ix == 3) {
#ifndef PERL_FBM_TABLE_OFFSET
	    const MAGIC *const mg = mg_find(sv, PERL_MAGIC_bm);

	    if (!mg)
                croak("argument to B::BM::TABLE is not a PVBM");
	    p = mg->mg_ptr;
	    len = mg->mg_len;
#else
	    p = SvPV(sv, len);
	    /* Boyer-Moore table is just after string and its safety-margin \0 */
	    p += len + PERL_FBM_TABLE_OFFSET;
	    len = 256;
#endif
	} else if (ix == 2) {
	    /* This used to read 257. I think that that was buggy - should have
	       been 258. (The "\0", the flags byte, and 256 for the table.)
	       The only user of this method is B::Bytecode in B::PV::bsave.
	       I'm guessing that nothing tested the runtime correctness of
	       output of bytecompiled string constant arguments to index (etc).

	       Note the start pointer is and has always been SvPVX(sv), not
	       SvPVX(sv) + SvCUR(sv) PVBM was added in 651aa52ea1faa806, and
	       first used by the compiler in 651aa52ea1faa806. It's used to
	       get a "complete" dump of the buffer at SvPVX(), not just the
	       PVBM table. This permits the generated bytecode to "load"
	       SvPVX in "one" hit.

	       5.15 and later store the BM table via MAGIC, so the compiler
	       should handle this just fine without changes if PVBM now
	       always returns the SvPVX() buffer.  */
#ifdef isREGEXP
	    p = isREGEXP(sv)
		 ? RX_WRAPPED_const((REGEXP*)sv)
		 : SvPVX_const(sv);
#else
	    p = SvPVX_const(sv);
#endif
#ifdef PERL_FBM_TABLE_OFFSET
	    len = SvCUR(sv) + (SvVALID(sv) ? 256 + PERL_FBM_TABLE_OFFSET : 0);
#else
	    len = SvCUR(sv);
#endif
	} else if (ix) {
#ifdef isREGEXP
	    p = isREGEXP(sv) ? RX_WRAPPED((REGEXP*)sv) : SvPVX(sv);
#else
	    p = SvPVX(sv);
#endif
	    len = strlen(p);
	} else if (SvPOK(sv)) {
	    len = SvCUR(sv);
	    p = SvPVX_const(sv);
	    utf8 = SvUTF8(sv);
        }
#ifdef isREGEXP
	else if (isREGEXP(sv)) {
	    len = SvCUR(sv);
	    p = RX_WRAPPED_const((REGEXP*)sv);
	    utf8 = SvUTF8(sv);
	}
#endif
        else {
            /* XXX for backward compatibility, but should fail */
            /* croak( "argument is not SvPOK" ); */
	    p = NULL;
        }
	ST(0) = newSVpvn_flags(p, len, SVs_TEMP | utf8);
#line 2035 "B.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__PVMG_MAGIC); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PVMG_MAGIC)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__PVMG	sv;
	MAGIC *	mg;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVMG,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1619 "B.xs"
	for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic)
	    XPUSHs(make_mg_object(aTHX_ mg));
#line 2063 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__MAGIC_MOREMAGIC); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__MAGIC_MOREMAGIC)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "mg");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__MAGIC	mg;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference")
;
#line 1637 "B.xs"
	switch (ix) {
	case 0:
	    XPUSHs(mg->mg_moremagic ? make_mg_object(aTHX_ mg->mg_moremagic)
				    : &PL_sv_undef);
	    break;
	case 1:
	    mPUSHu(mg->mg_private);
	    break;
	case 2:
	    PUSHs(newSVpvn_flags(&(mg->mg_type), 1, SVs_TEMP));
	    break;
	case 3:
	    mPUSHu(mg->mg_flags);
	    break;
	case 4:
	    mPUSHi(mg->mg_len);
	    break;
	case 5:
	    PUSHs(make_sv_object(aTHX_ mg->mg_obj));
	    break;
	case 6:
	    if (mg->mg_ptr) {
		if (mg->mg_len >= 0) {
		    PUSHs(newSVpvn_flags(mg->mg_ptr, mg->mg_len, SVs_TEMP));
		} else if (mg->mg_len == HEf_SVKEY) {
		    PUSHs(make_sv_object(aTHX_ (SV*)mg->mg_ptr));
		} else
		    PUSHs(sv_newmortal());
	    } else
		PUSHs(sv_newmortal());
	    break;
	case 7:
	    if(mg->mg_type == PERL_MAGIC_qr) {
                mPUSHi(PTR2IV(mg->mg_obj));
	    } else {
		croak("REGEX is only meaningful on r-magic");
	    }
	    break;
	case 8:
	    if (mg->mg_type == PERL_MAGIC_qr) {
		REGEXP *rx = (REGEXP *)mg->mg_obj;
		PUSHs(newSVpvn_flags(rx ? RX_PRECOMP(rx) : NULL,
				     rx ? RX_PRELEN(rx) : 0, SVs_TEMP));
	    } else {
		croak( "precomp is only meaningful on r-magic" );
	    }
	    break;
	}
#line 2138 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__BM_PREVIOUS); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__BM_PREVIOUS)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__BM	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__BM,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1692 "B.xs"
#if PERL_VERSION >= 19
        PERL_UNUSED_VAR(sv);
#endif
	RETVAL = BmPREVIOUS(sv);
#line 2168 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__BM_RARE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__BM_RARE)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__BM	sv;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__BM,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1704 "B.xs"
#if PERL_VERSION >= 19
        PERL_UNUSED_VAR(sv);
#endif
	RETVAL = BmRARE(sv);
#line 2198 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__GV_NAME); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__GV_NAME)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference")
;
#line 1721 "B.xs"
	ST(0) = sv_2mortal(newSVhek(!ix ? GvNAME_HEK(gv)
					: (ix == 1 ? GvFILE_HEK(gv)
						   : HvNAME_HEK((HV *)gv))));
#line 2226 "B.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__GV_is_empty); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__GV_is_empty)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	bool	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference")
;
#line 1731 "B.xs"
	if (ix) {
	    RETVAL = isGV_with_GP(gv) ? TRUE : FALSE;
	} else {
            RETVAL = GvGP(gv) == Null(GP*);
	}
#line 2256 "B.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__GV_GP); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__GV_GP)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	void *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference")
;

	RETVAL = GvGP(gv);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#define GP_sv_ix	(SVp << 16) | offsetof(struct gp, gp_sv)
#define GP_io_ix	(SVp << 16) | offsetof(struct gp, gp_io)
#define GP_cv_ix	(SVp << 16) | offsetof(struct gp, gp_cv)
#define GP_cvgen_ix	(U32p << 16) | offsetof(struct gp, gp_cvgen)
#define GP_refcnt_ix	(U32p << 16) | offsetof(struct gp, gp_refcnt)
#define GP_hv_ix	(SVp << 16) | offsetof(struct gp, gp_hv)
#define GP_av_ix	(SVp << 16) | offsetof(struct gp, gp_av)
#define GP_form_ix	(SVp << 16) | offsetof(struct gp, gp_form)
#define GP_egv_ix	(SVp << 16) | offsetof(struct gp, gp_egv)
#define GP_line_ix	(line_tp << 16) | offsetof(struct gp, gp_line)

XS_EUPXS(XS_B__GV_SV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__GV_SV)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__GV	gv;
#line 1769 "B.xs"
	GP *gp;
	char *ptr;
	SV *ret;
#line 2314 "B.c"

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference")
;
#line 1773 "B.xs"
	gp = GvGP(gv);
	if (!gp) {
	    const GV *const gv = CvGV(cv);
	    Perl_croak(aTHX_ "NULL gp in B::GV::%s", gv ? GvNAME(gv) : "???");
	}
	ptr = (ix & 0xFFFF) + (char *)gp;
	switch ((U8)(ix >> 16)) {
	case SVp:
	    ret = make_sv_object(aTHX_ *((SV **)ptr));
	    break;
	case U32p:
	    ret = sv_2mortal(newSVuv(*((U32*)ptr)));
	    break;
	case line_tp:
	    ret = sv_2mortal(newSVuv(*((line_t *)ptr)));
	    break;
	default:
	    croak("Illegal alias 0x%08x for B::*SV", (unsigned)ix);
	}
	ST(0) = ret;
	XSRETURN(1);
#line 2345 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__GV_FILEGV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__GV_FILEGV)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__GV	gv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference")
;
#line 1799 "B.xs"
	PUSHs(make_sv_object(aTHX_ (SV *)GvFILEGV(gv)));
#line 2372 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__IO_IsSTD); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__IO_IsSTD)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "io, name");
    {
	B__IO	io;
	const char*	name = (const char *)SvPV_nolen(ST(1))
;
#line 1809 "B.xs"
	PerlIO* handle = 0;
#line 2391 "B.c"
	bool	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference")
;
#line 1811 "B.xs"
	if( strEQ( name, "stdin" ) ) {
	    handle = PerlIO_stdin();
	}
	else if( strEQ( name, "stdout" ) ) {
	    handle = PerlIO_stdout();
	}
	else if( strEQ( name, "stderr" ) ) {
	    handle = PerlIO_stderr();
	}
	else {
	    croak( "Invalid value '%s'", name );
	}
	RETVAL = handle == IoIFP(io);
#line 2415 "B.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__AV_FILL); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__AV_FILL)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "av");
    {
	B__AV	av;
	SSize_t	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference")
;

	RETVAL = AvFILL(av);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__AV_ARRAY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__AV_ARRAY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "av");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__AV	av;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference")
;
#line 1837 "B.xs"
	if (AvFILL(av) >= 0) {
	    SV **svp = AvARRAY(av);
	    I32 i;
	    for (i = 0; i <= AvFILL(av); i++)
		XPUSHs(make_sv_object(aTHX_ svp[i]));
	}
#line 2473 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__AV_ARRAYelt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__AV_ARRAYelt)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "av, idx");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__AV	av;
	int	idx = (int)SvIV(ST(1))
;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference")
;
#line 1849 "B.xs"
    	if (idx >= 0 && AvFILL(av) >= 0 && idx <= AvFILL(av))
	    XPUSHs(make_sv_object(aTHX_ (AvARRAY(av)[idx])));
	else
	    XPUSHs(make_sv_object(aTHX_ NULL));
#line 2505 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__FM_LINES); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__FM_LINES)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "format");
    {
	B__FM	format;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    format = INT2PTR(B__FM,tmp);
	}
	else
	    croak("format is not a reference")
;
#line 1861 "B.xs"
        PERL_UNUSED_VAR(format);
       RETVAL = 0;
#line 2533 "B.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__CV_CONST); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_CONST)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;

	RETVAL = CvCONST(cv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__CV_START); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_START)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__CV	cv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;
#line 1879 "B.xs"
	PUSHs(make_op_object(aTHX_ CvISXSUB(cv) ? NULL
			     : ix ? CvROOT(cv) : CvSTART(cv)));
#line 2588 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__CV_DEPTH); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_DEPTH)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;

	RETVAL = CvDEPTH(cv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef PadlistARRAY
#define XSubPPtmpAAAD 1


XS_EUPXS(XS_B__CV_PADLIST); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_PADLIST)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	B__PADLIST	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;

	RETVAL = CvPADLIST(cv);
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), RETVAL ? "B::PADLIST" : "B::NULL"),
		 PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAE 1


XS_EUPXS(XS_B__CV_PADLIST); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_PADLIST)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__CV	cv;
	B__AV	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;
#line 1898 "B.xs"
	PUSHs(make_sv_object(aTHX_ (SV *)CvPADLIST(cv)));
#line 2675 "B.c"
	PUTBACK;
	return;
    }
}

#endif

XS_EUPXS(XS_B__CV_XSUB); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_XSUB)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;
#line 1909 "B.xs"
	ST(0) = ix && CvCONST(cv)
	    ? make_sv_object(aTHX_ (SV *)CvXSUBANY(cv).any_ptr)
	    : sv_2mortal(newSViv(CvISXSUB(cv)
				 ? (ix ? CvXSUBANY(cv).any_iv
				       : PTR2IV(CvXSUB(cv)))
				 : 0));
#line 2707 "B.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__CV_const_sv); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_const_sv)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__CV	cv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;
#line 1920 "B.xs"
	PUSHs(make_sv_object(aTHX_ (SV *)cv_const_sv(cv)));
#line 2733 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__CV_GV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_GV)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;
#line 1926 "B.xs"
	ST(0) = make_sv_object(aTHX_ (SV*)CvGV(cv));
#line 2758 "B.c"
    }
    XSRETURN(1);
}

#if PERL_VERSION > 17
#define XSubPPtmpAAAF 1


XS_EUPXS(XS_B__CV_NAME_HEK); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_NAME_HEK)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;
#line 1934 "B.xs"
	RETVAL = CvNAMED(cv) ? newSVhek(CvNAME_HEK(cv)) : &PL_sv_undef;
#line 2786 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_B__HV_FILL); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__HV_FILL)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    {
	B__HV	hv;
	STRLEN	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference")
;

	RETVAL = HvFILL(hv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__HV_RITER); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__HV_RITER)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    {
	B__HV	hv;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference")
;

	RETVAL = HvRITER(hv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__HV_ARRAY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__HV_ARRAY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__HV	hv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference")
;
#line 1954 "B.xs"
	if (HvUSEDKEYS(hv) > 0) {
	    HE *he;
	    (void)hv_iterinit(hv);
	    EXTEND(sp, HvUSEDKEYS(hv) * 2);
	    while ((he = hv_iternext(hv))) {
                if (HeSVKEY(he)) {
                    mPUSHs(HeSVKEY(he));
                } else if (HeKUTF8(he)) {
                    PUSHs(newSVpvn_flags(HeKEY(he), HeKLEN(he), SVf_UTF8|SVs_TEMP));
                } else {
                    mPUSHp(HeKEY(he), HeKLEN(he));
                }
		PUSHs(make_sv_object(aTHX_ HeVAL(he)));
	    }
	}
#line 2881 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__HE_VAL); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__HE_VAL)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "he");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__HE	he;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    he = INT2PTR(B__HE,tmp);
	}
	else
	    croak("he is not a reference")
;
#line 1978 "B.xs"
	PUSHs(make_sv_object(aTHX_ ix ? HeSVKEY_force(he) : HeVAL(he)));
#line 2909 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__HE_HASH); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__HE_HASH)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "he");
    {
	B__HE	he;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    he = INT2PTR(B__HE,tmp);
	}
	else
	    croak("he is not a reference")
;

	RETVAL = HeHASH(he);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__RHE_HASH); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__RHE_HASH)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "h");
    {
	B__RHE	h;
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    h = INT2PTR(B__RHE,tmp);
	}
	else
	    croak("h is not a reference")
;
#line 1990 "B.xs"
	RETVAL = newRV( (SV*)cophh_2hv(h, 0) );
#line 2961 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#ifdef PadlistARRAY
#define XSubPPtmpAAAG 1


XS_EUPXS(XS_B__PADLIST_MAX); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PADLIST_MAX)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "padlist");
    {
	B__PADLIST	padlist;
	SSize_t	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    padlist = INT2PTR(B__PADLIST,tmp);
	}
	else
	    croak("padlist is not a reference")
;

	RETVAL = PadlistMAX(padlist);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__PADLIST_ARRAY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PADLIST_ARRAY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "padlist");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__PADLIST	padlist;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    padlist = INT2PTR(B__PADLIST,tmp);
	}
	else
	    croak("padlist is not a reference")
;
#line 2007 "B.xs"
	if (PadlistMAX(padlist) >= 0) {
	    PAD **padp = PadlistARRAY(padlist);
            SSize_t i;
	    for (i = 0; i <= PadlistMAX(padlist); i++)
		XPUSHs(make_sv_object(aTHX_ (SV *)padp[i]));
	}
#line 3023 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__PADLIST_ARRAYelt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PADLIST_ARRAYelt)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "padlist, idx");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__PADLIST	padlist;
	SSize_t	idx = (SSize_t)SvIV(ST(1))
;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    padlist = INT2PTR(B__PADLIST,tmp);
	}
	else
	    croak("padlist is not a reference")
;
#line 2019 "B.xs"
	if (PadlistMAX(padlist) >= 0
	 && idx <= PadlistMAX(padlist))
	    XPUSHs(make_sv_object(aTHX_
				  (SV *)PadlistARRAY(padlist)[idx]));
	else
	    XPUSHs(make_sv_object(aTHX_ NULL));
#line 3057 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__PADLIST_REFCNT); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PADLIST_REFCNT)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "padlist");
    {
	B__PADLIST	padlist;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    padlist = INT2PTR(B__PADLIST,tmp);
	}
	else
	    croak("padlist is not a reference")
;
#line 2030 "B.xs"
        PERL_UNUSED_VAR(padlist);
	RETVAL = PadlistREFCNT(padlist);
#line 3085 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#endif
#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_B); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_B)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

#if XSubPPtmpAAAA
        newXS("B::formfeed", XS_B_formfeed, file);
#endif
        newXS("B::amagic_generation", XS_B_amagic_generation, file);
        newXS("B::comppadlist", XS_B_comppadlist, file);
        cv = newXS("B::sv_no", XS_B_sv_undef, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::sv_undef", XS_B_sv_undef, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::sv_yes", XS_B_sv_undef, file);
        XSANY.any_i32 = 2;
        cv = newXS("B::main_root", XS_B_main_root, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::main_start", XS_B_main_root, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::dowarn", XS_B_sub_generation, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::sub_generation", XS_B_sub_generation, file);
        XSANY.any_i32 = 0;
        newXS("B::walkoptree", XS_B_walkoptree, file);
        newXS("B::walkoptree_debug", XS_B_walkoptree_debug, file);
        newXS("B::address", XS_B_address, file);
        newXS("B::svref_2object", XS_B_svref_2object, file);
        newXS("B::opnumber", XS_B_opnumber, file);
        newXS("B::ppname", XS_B_ppname, file);
        newXS("B::hash", XS_B_hash, file);
        newXS("B::cast_I32", XS_B_cast_I32, file);
        cv = newXS("B::minus_c", XS_B_minus_c, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::save_BEGINs", XS_B_minus_c, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::cchar", XS_B_cstring, file);
        XSANY.any_i32 = 2;
        cv = newXS("B::cstring", XS_B_cstring, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::perlstring", XS_B_cstring, file);
        XSANY.any_i32 = 1;
        newXS("B::threadsv_names", XS_B_threadsv_names, file);
        cv = newXS("B::BINOP::last", XS_B__OP_next, file);
        XSANY.any_i32 = 6;
        cv = newXS("B::COP::arybase", XS_B__OP_next, file);
        XSANY.any_i32 = 43;
        cv = newXS("B::COP::cop_seq", XS_B__OP_next, file);
        XSANY.any_i32 = 17;
        cv = newXS("B::COP::file", XS_B__OP_next, file);
        XSANY.any_i32 = 22;
        cv = newXS("B::COP::filegv", XS_B__OP_next, file);
        XSANY.any_i32 = 21;
        cv = newXS("B::COP::hints", XS_B__OP_next, file);
        XSANY.any_i32 = 19;
        cv = newXS("B::COP::hints_hash", XS_B__OP_next, file);
        XSANY.any_i32 = 46;
        cv = newXS("B::COP::io", XS_B__OP_next, file);
        XSANY.any_i32 = 45;
        cv = newXS("B::COP::label", XS_B__OP_next, file);
        XSANY.any_i32 = 42;
        cv = newXS("B::COP::line", XS_B__OP_next, file);
        XSANY.any_i32 = 18;
        cv = newXS("B::COP::stash", XS_B__OP_next, file);
        XSANY.any_i32 = 23;
        cv = newXS("B::COP::stashoff", XS_B__OP_next, file);
        XSANY.any_i32 = 25;
        cv = newXS("B::COP::stashpv", XS_B__OP_next, file);
        XSANY.any_i32 = 24;
        cv = newXS("B::COP::warnings", XS_B__OP_next, file);
        XSANY.any_i32 = 44;
        cv = newXS("B::LISTOP::children", XS_B__OP_next, file);
        XSANY.any_i32 = 33;
        cv = newXS("B::LOGOP::other", XS_B__OP_next, file);
        XSANY.any_i32 = 7;
        cv = newXS("B::LOOP::lastop", XS_B__OP_next, file);
        XSANY.any_i32 = 11;
        cv = newXS("B::LOOP::nextop", XS_B__OP_next, file);
        XSANY.any_i32 = 10;
        cv = newXS("B::LOOP::redoop", XS_B__OP_next, file);
        XSANY.any_i32 = 9;
        cv = newXS("B::OP::desc", XS_B__OP_next, file);
        XSANY.any_i32 = 28;
        cv = newXS("B::OP::flags", XS_B__OP_next, file);
        XSANY.any_i32 = 3;
        cv = newXS("B::OP::folded", XS_B__OP_next, file);
        XSANY.any_i32 = 50;
        cv = newXS("B::OP::name", XS_B__OP_next, file);
        XSANY.any_i32 = 27;
        cv = newXS("B::OP::next", XS_B__OP_next, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::OP::opt", XS_B__OP_next, file);
        XSANY.any_i32 = 31;
        cv = newXS("B::OP::ppaddr", XS_B__OP_next, file);
        XSANY.any_i32 = 29;
        cv = newXS("B::OP::private", XS_B__OP_next, file);
        XSANY.any_i32 = 4;
        cv = newXS("B::OP::savefree", XS_B__OP_next, file);
        XSANY.any_i32 = 48;
        cv = newXS("B::OP::sibling", XS_B__OP_next, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::OP::size", XS_B__OP_next, file);
        XSANY.any_i32 = 26;
        cv = newXS("B::OP::slabbed", XS_B__OP_next, file);
        XSANY.any_i32 = 47;
        cv = newXS("B::OP::spare", XS_B__OP_next, file);
        XSANY.any_i32 = 32;
        cv = newXS("B::OP::static", XS_B__OP_next, file);
        XSANY.any_i32 = 49;
        cv = newXS("B::OP::targ", XS_B__OP_next, file);
        XSANY.any_i32 = 2;
        cv = newXS("B::OP::type", XS_B__OP_next, file);
        XSANY.any_i32 = 30;
        cv = newXS("B::PADOP::gv", XS_B__OP_next, file);
        XSANY.any_i32 = 40;
        cv = newXS("B::PADOP::padix", XS_B__OP_next, file);
        XSANY.any_i32 = 16;
        cv = newXS("B::PADOP::sv", XS_B__OP_next, file);
        XSANY.any_i32 = 39;
        cv = newXS("B::PMOP::code_list", XS_B__OP_next, file);
        XSANY.any_i32 = 13;
        cv = newXS("B::PMOP::pmflags", XS_B__OP_next, file);
        XSANY.any_i32 = 12;
        cv = newXS("B::PMOP::pmoffset", XS_B__OP_next, file);
        XSANY.any_i32 = 20;
        cv = newXS("B::PMOP::pmreplroot", XS_B__OP_next, file);
        XSANY.any_i32 = 34;
        cv = newXS("B::PMOP::pmreplstart", XS_B__OP_next, file);
        XSANY.any_i32 = 8;
        cv = newXS("B::PMOP::pmstash", XS_B__OP_next, file);
        XSANY.any_i32 = 36;
        cv = newXS("B::PMOP::pmstashpv", XS_B__OP_next, file);
        XSANY.any_i32 = 35;
        cv = newXS("B::PMOP::precomp", XS_B__OP_next, file);
        XSANY.any_i32 = 37;
        cv = newXS("B::PMOP::reflags", XS_B__OP_next, file);
        XSANY.any_i32 = 38;
        cv = newXS("B::PVOP::pv", XS_B__OP_next, file);
        XSANY.any_i32 = 41;
        cv = newXS("B::SVOP::gv", XS_B__OP_next, file);
        XSANY.any_i32 = 15;
        cv = newXS("B::SVOP::sv", XS_B__OP_next, file);
        XSANY.any_i32 = 14;
        cv = newXS("B::UNOP::first", XS_B__OP_next, file);
        XSANY.any_i32 = 5;
        newXS("B::OP::oplist", XS_B__OP_oplist, file);
        cv = newXS("B::SV::FLAGS", XS_B__SV_REFCNT, file);
        XSANY.any_i32 = 0xFFFFFFFF;
        cv = newXS("B::SV::MAGICAL", XS_B__SV_REFCNT, file);
        XSANY.any_i32 = MAGICAL_FLAG_BITS;
        cv = newXS("B::SV::POK", XS_B__SV_REFCNT, file);
        XSANY.any_i32 = SVf_POK;
        cv = newXS("B::SV::REFCNT", XS_B__SV_REFCNT, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::SV::ROK", XS_B__SV_REFCNT, file);
        XSANY.any_i32 = SVf_ROK;
        cv = newXS("B::SV::SvTYPE", XS_B__SV_REFCNT, file);
        XSANY.any_i32 = SVTYPEMASK;
        newXS("B::SV::object_2svref", XS_B__SV_object_2svref, file);
        newXS("B::IV::IV", XS_B__IV_IV, file);
        cv = newXS("B::AV::MAX", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVAV_max_ix;
        cv = newXS("B::BM::USEFUL", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVBM_useful_ix;
        cv = newXS("B::CV::CvFLAGS", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVCV_flags_ix;
        cv = newXS("B::CV::FILE", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVCV_file_ix;
        cv = newXS("B::CV::OUTSIDE", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVCV_outside_ix;
        cv = newXS("B::CV::OUTSIDE_SEQ", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVCV_outside_seq_ix;
        cv = newXS("B::CV::STASH", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVCV_stash_ix;
        cv = newXS("B::GV::GvFLAGS", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVGV_flags_ix;
        cv = newXS("B::GV::STASH", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVGV_stash_ix;
        cv = newXS("B::HV::KEYS", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVHV_keys_ix;
        cv = newXS("B::HV::MAX", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVHV_max_ix;
        cv = newXS("B::IO::BOTTOM_GV", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_bottom_gv_ix;
        cv = newXS("B::IO::BOTTOM_NAME", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_bottom_name_ix;
        cv = newXS("B::IO::FMT_GV", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_fmt_gv_ix;
        cv = newXS("B::IO::FMT_NAME", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_fmt_name_ix;
        cv = newXS("B::IO::IoFLAGS", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_flags_ix;
        cv = newXS("B::IO::IoTYPE", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_type_ix;
        cv = newXS("B::IO::LINES", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_lines_ix;
        cv = newXS("B::IO::LINES_LEFT", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_lines_left_ix;
        cv = newXS("B::IO::PAGE", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_page_ix;
        cv = newXS("B::IO::PAGE_LEN", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_page_len_ix;
        cv = newXS("B::IO::TOP_GV", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_top_gv_ix;
        cv = newXS("B::IO::TOP_NAME", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_top_name_ix;
        cv = newXS("B::IV::IVX", XS_B__IV_IVX, file);
        XSANY.any_i32 = IV_ivx_ix;
        cv = newXS("B::IV::UVX", XS_B__IV_IVX, file);
        XSANY.any_i32 = IV_uvx_ix;
        cv = newXS("B::NV::COP_SEQ_RANGE_HIGH", XS_B__IV_IVX, file);
        XSANY.any_i32 = NV_cop_seq_range_high_ix;
        cv = newXS("B::NV::COP_SEQ_RANGE_LOW", XS_B__IV_IVX, file);
        XSANY.any_i32 = NV_cop_seq_range_low_ix;
        cv = newXS("B::NV::NVX", XS_B__IV_IVX, file);
        XSANY.any_i32 = NV_nvx_ix;
        cv = newXS("B::NV::PARENT_FAKELEX_FLAGS", XS_B__IV_IVX, file);
        XSANY.any_i32 = NV_parent_fakelex_flags_ix;
        cv = newXS("B::NV::PARENT_PAD_INDEX", XS_B__IV_IVX, file);
        XSANY.any_i32 = NV_parent_pad_index_ix;
        cv = newXS("B::PV::CUR", XS_B__IV_IVX, file);
        XSANY.any_i32 = PV_cur_ix;
        cv = newXS("B::PV::LEN", XS_B__IV_IVX, file);
        XSANY.any_i32 = PV_len_ix;
        cv = newXS("B::PVLV::TARG", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVLV_targ_ix;
        cv = newXS("B::PVLV::TARGLEN", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVLV_targlen_ix;
        cv = newXS("B::PVLV::TARGOFF", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVLV_targoff_ix;
        cv = newXS("B::PVLV::TYPE", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVLV_type_ix;
        cv = newXS("B::PVMG::SvSTASH", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVMG_stash_ix;
        cv = newXS("B::IV::needs64bits", XS_B__IV_packiv, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::IV::packiv", XS_B__IV_packiv, file);
        XSANY.any_i32 = 0;
        newXS("B::NV::NV", XS_B__NV_NV, file);
#if XSubPPtmpAAAB
        newXS("B::RV::RV", XS_B__RV_RV, file);
#endif
#if XSubPPtmpAAAC
        cv = newXS("B::REGEXP::REGEX", XS_B__REGEXP_REGEX, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::REGEXP::precomp", XS_B__REGEXP_REGEX, file);
        XSANY.any_i32 = 1;
#endif
        newXS("B::PV::RV", XS_B__PV_RV, file);
        cv = newXS("B::BM::TABLE", XS_B__PV_PV, file);
        XSANY.any_i32 = 3;
        cv = newXS("B::PV::PV", XS_B__PV_PV, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::PV::PVBM", XS_B__PV_PV, file);
        XSANY.any_i32 = 2;
        cv = newXS("B::PV::PVX", XS_B__PV_PV, file);
        XSANY.any_i32 = 1;
        newXS("B::PVMG::MAGIC", XS_B__PVMG_MAGIC, file);
        cv = newXS("B::MAGIC::FLAGS", XS_B__MAGIC_MOREMAGIC, file);
        XSANY.any_i32 = 3;
        cv = newXS("B::MAGIC::LENGTH", XS_B__MAGIC_MOREMAGIC, file);
        XSANY.any_i32 = 4;
        cv = newXS("B::MAGIC::MOREMAGIC", XS_B__MAGIC_MOREMAGIC, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::MAGIC::OBJ", XS_B__MAGIC_MOREMAGIC, file);
        XSANY.any_i32 = 5;
        cv = newXS("B::MAGIC::PRIVATE", XS_B__MAGIC_MOREMAGIC, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::MAGIC::PTR", XS_B__MAGIC_MOREMAGIC, file);
        XSANY.any_i32 = 6;
        cv = newXS("B::MAGIC::REGEX", XS_B__MAGIC_MOREMAGIC, file);
        XSANY.any_i32 = 7;
        cv = newXS("B::MAGIC::TYPE", XS_B__MAGIC_MOREMAGIC, file);
        XSANY.any_i32 = 2;
        cv = newXS("B::MAGIC::precomp", XS_B__MAGIC_MOREMAGIC, file);
        XSANY.any_i32 = 8;
        newXS("B::BM::PREVIOUS", XS_B__BM_PREVIOUS, file);
        newXS("B::BM::RARE", XS_B__BM_RARE, file);
        cv = newXS("B::GV::FILE", XS_B__GV_NAME, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::GV::NAME", XS_B__GV_NAME, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::HV::NAME", XS_B__GV_NAME, file);
        XSANY.any_i32 = 2;
        cv = newXS("B::GV::isGV_with_GP", XS_B__GV_is_empty, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::GV::is_empty", XS_B__GV_is_empty, file);
        XSANY.any_i32 = 0;
        newXS("B::GV::GP", XS_B__GV_GP, file);
        cv = newXS("B::GV::AV", XS_B__GV_SV, file);
        XSANY.any_i32 = GP_av_ix;
        cv = newXS("B::GV::CV", XS_B__GV_SV, file);
        XSANY.any_i32 = GP_cv_ix;
        cv = newXS("B::GV::CVGEN", XS_B__GV_SV, file);
        XSANY.any_i32 = GP_cvgen_ix;
        cv = newXS("B::GV::EGV", XS_B__GV_SV, file);
        XSANY.any_i32 = GP_egv_ix;
        cv = newXS("B::GV::FORM", XS_B__GV_SV, file);
        XSANY.any_i32 = GP_form_ix;
        cv = newXS("B::GV::GvREFCNT", XS_B__GV_SV, file);
        XSANY.any_i32 = GP_refcnt_ix;
        cv = newXS("B::GV::HV", XS_B__GV_SV, file);
        XSANY.any_i32 = GP_hv_ix;
        cv = newXS("B::GV::IO", XS_B__GV_SV, file);
        XSANY.any_i32 = GP_io_ix;
        cv = newXS("B::GV::LINE", XS_B__GV_SV, file);
        XSANY.any_i32 = GP_line_ix;
        cv = newXS("B::GV::SV", XS_B__GV_SV, file);
        XSANY.any_i32 = GP_sv_ix;
        newXS("B::GV::FILEGV", XS_B__GV_FILEGV, file);
        newXS("B::IO::IsSTD", XS_B__IO_IsSTD, file);
        newXS("B::AV::FILL", XS_B__AV_FILL, file);
        newXS("B::AV::ARRAY", XS_B__AV_ARRAY, file);
        newXS("B::AV::ARRAYelt", XS_B__AV_ARRAYelt, file);
        newXS("B::FM::LINES", XS_B__FM_LINES, file);
        newXS("B::CV::CONST", XS_B__CV_CONST, file);
        cv = newXS("B::CV::ROOT", XS_B__CV_START, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::CV::START", XS_B__CV_START, file);
        XSANY.any_i32 = 0;
        newXS("B::CV::DEPTH", XS_B__CV_DEPTH, file);
#if XSubPPtmpAAAD
        newXS("B::CV::PADLIST", XS_B__CV_PADLIST, file);
#endif
#if XSubPPtmpAAAE
        newXS("B::CV::PADLIST", XS_B__CV_PADLIST, file);
#endif
        cv = newXS("B::CV::XSUB", XS_B__CV_XSUB, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::CV::XSUBANY", XS_B__CV_XSUB, file);
        XSANY.any_i32 = 1;
        newXS("B::CV::const_sv", XS_B__CV_const_sv, file);
        newXS("B::CV::GV", XS_B__CV_GV, file);
#if XSubPPtmpAAAF
        newXS("B::CV::NAME_HEK", XS_B__CV_NAME_HEK, file);
#endif
        newXS("B::HV::FILL", XS_B__HV_FILL, file);
        newXS("B::HV::RITER", XS_B__HV_RITER, file);
        newXS("B::HV::ARRAY", XS_B__HV_ARRAY, file);
        cv = newXS("B::HE::SVKEY_force", XS_B__HE_VAL, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::HE::VAL", XS_B__HE_VAL, file);
        XSANY.any_i32 = 0;
        newXS("B::HE::HASH", XS_B__HE_HASH, file);
        newXS("B::RHE::HASH", XS_B__RHE_HASH, file);
#if XSubPPtmpAAAG
        newXS("B::PADLIST::MAX", XS_B__PADLIST_MAX, file);
        newXS("B::PADLIST::ARRAY", XS_B__PADLIST_ARRAY, file);
        newXS("B::PADLIST::ARRAYelt", XS_B__PADLIST_ARRAYelt, file);
        newXS("B::PADLIST::REFCNT", XS_B__PADLIST_REFCNT, file);
#endif

    /* Initialisation Section */

#line 2 "./const-xs.inc"
  {
#ifdef dTHX
    dTHX;
#endif
    HV *symbol_table = get_hv("B::", GV_ADD);
    AV *push = get_av("B::EXPORT_OK", GV_ADD);
    HE *he;

    static const struct iv_s values_for_iv[] =
      {
        { "HEf_SVKEY", 9, HEf_SVKEY },
        { NULL, 0, 0 } };
	const struct iv_s *value_for_iv = values_for_iv;

    static const struct uv_s values_for_uv[] =
      {
        { "SVTYPEMASK", 10, SVTYPEMASK },
        { "SVt_PVGV", 8, SVt_PVGV },
        { "SVt_PVHV", 8, SVt_PVHV },
        { "PAD_FAKELEX_ANON", 16, PAD_FAKELEX_ANON },
        { "PAD_FAKELEX_MULTI", 17, PAD_FAKELEX_MULTI },
        { "CXt_NULL", 8, CXt_NULL },
        { "CXt_WHEN", 8, CXt_WHEN },
        { "CXt_BLOCK", 9, CXt_BLOCK },
        { "CXt_GIVEN", 9, CXt_GIVEN },
        { "CXt_LOOP_FOR", 12, CXt_LOOP_FOR },
        { "CXt_LOOP_PLAIN", 14, CXt_LOOP_PLAIN },
        { "CXt_LOOP_LAZYSV", 15, CXt_LOOP_LAZYSV },
        { "CXt_LOOP_LAZYIV", 15, CXt_LOOP_LAZYIV },
        { "CXt_SUB", 7, CXt_SUB },
        { "CXt_FORMAT", 10, CXt_FORMAT },
        { "CXt_EVAL", 8, CXt_EVAL },
        { "CXt_SUBST", 9, CXt_SUBST },
        { "CXp_MULTICALL", 13, CXp_MULTICALL },
        { "CXp_HASARGS", 11, CXp_HASARGS },
        { "CXp_SUB_RE", 10, CXp_SUB_RE },
        { "CXp_SUB_RE_FAKE", 15, CXp_SUB_RE_FAKE },
        { "CXp_REAL", 8, CXp_REAL },
        { "CXp_TRYBLOCK", 12, CXp_TRYBLOCK },
        { "CXp_FOR_DEF", 11, CXp_FOR_DEF },
        { "CXp_ONCE", 8, CXp_ONCE },
        { "G_SCALAR", 8, G_SCALAR },
        { "G_ARRAY", 7, G_ARRAY },
        { "G_VOID", 6, G_VOID },
        { "G_WANT", 6, G_WANT },
        { "G_DISCARD", 9, G_DISCARD },
        { "G_EVAL", 6, G_EVAL },
        { "G_NOARGS", 8, G_NOARGS },
        { "G_KEEPERR", 9, G_KEEPERR },
        { "G_NODEBUG", 9, G_NODEBUG },
        { "G_METHOD", 8, G_METHOD },
        { "G_FAKINGEVAL", 12, G_FAKINGEVAL },
        { "G_UNDEF_FILL", 12, G_UNDEF_FILL },
        { "G_WRITING_TO_STDERR", 19, G_WRITING_TO_STDERR },
        { "G_RE_REPARSING", 14, G_RE_REPARSING },
        { "G_METHOD_NAMED", 14, G_METHOD_NAMED },
        { "EVAL_NULL", 9, EVAL_NULL },
        { "EVAL_INEVAL", 11, EVAL_INEVAL },
        { "EVAL_WARNONLY", 13, EVAL_WARNONLY },
        { "EVAL_KEEPERR", 12, EVAL_KEEPERR },
        { "EVAL_INREQUIRE", 14, EVAL_INREQUIRE },
        { "EVAL_RE_REPARSING", 17, EVAL_RE_REPARSING },
        { "PERLSI_UNDEF", 12, PERLSI_UNDEF },
        { "PERLSI_MAIN", 11, PERLSI_MAIN },
        { "PERLSI_MAGIC", 12, PERLSI_MAGIC },
        { "PERLSI_SORT", 11, PERLSI_SORT },
        { "PERLSI_SIGNAL", 13, PERLSI_SIGNAL },
        { "PERLSI_OVERLOAD", 15, PERLSI_OVERLOAD },
        { "PERLSI_DESTROY", 14, PERLSI_DESTROY },
        { "PERLSI_WARNHOOK", 15, PERLSI_WARNHOOK },
        { "PERLSI_DIEHOOK", 14, PERLSI_DIEHOOK },
        { "PERLSI_REQUIRE", 14, PERLSI_REQUIRE },
        { "CVf_METHOD", 10, CVf_METHOD },
        { "CVf_LVALUE", 10, CVf_LVALUE },
        { "CVf_CONST", 9, CVf_CONST },
        { "CVf_ISXSUB", 10, CVf_ISXSUB },
        { "CVf_WEAKOUTSIDE", 15, CVf_WEAKOUTSIDE },
        { "CVf_CLONE", 9, CVf_CLONE },
        { "CVf_CLONED", 10, CVf_CLONED },
        { "CVf_ANON", 8, CVf_ANON },
        { "CVf_UNIQUE", 10, CVf_UNIQUE },
        { "CVf_NODEBUG", 11, CVf_NODEBUG },
        { "CVf_CVGV_RC", 11, CVf_CVGV_RC },
        { "CVf_DYNFILE", 11, CVf_DYNFILE },
        { "CVf_AUTOLOAD", 12, CVf_AUTOLOAD },
        { "CVf_HASEVAL", 11, CVf_HASEVAL },
        { "CVf_NAMED", 9, CVf_NAMED },
        { "GVf_INTRO", 9, GVf_INTRO },
        { "GVf_MULTI", 9, GVf_MULTI },
        { "GVf_ASSUMECV", 12, GVf_ASSUMECV },
        { "GVf_IN_PAD", 10, GVf_IN_PAD },
        { "GVf_IMPORTED_SV", 15, GVf_IMPORTED_SV },
        { "GVf_IMPORTED_AV", 15, GVf_IMPORTED_AV },
        { "GVf_IMPORTED_HV", 15, GVf_IMPORTED_HV },
        { "GVf_IMPORTED_CV", 15, GVf_IMPORTED_CV },
        { "OPf_WANT", 8, OPf_WANT },
        { "OPf_WANT_VOID", 13, OPf_WANT_VOID },
        { "OPf_WANT_SCALAR", 15, OPf_WANT_SCALAR },
        { "OPf_WANT_LIST", 13, OPf_WANT_LIST },
        { "OPf_KIDS", 8, OPf_KIDS },
        { "OPf_PARENS", 10, OPf_PARENS },
        { "OPf_REF", 7, OPf_REF },
        { "OPf_MOD", 7, OPf_MOD },
        { "OPf_STACKED", 11, OPf_STACKED },
        { "OPf_SPECIAL", 11, OPf_SPECIAL },
        { "OPpLVAL_INTRO", 13, OPpLVAL_INTRO },
        { "OPpTARGET_MY", 12, OPpTARGET_MY },
        { "OPpREFCOUNTED", 13, OPpREFCOUNTED },
        { "OPpLVALUE", 9, OPpLVALUE },
        { "OPpASSIGN_COMMON", 16, OPpASSIGN_COMMON },
        { "OPpASSIGN_BACKWARDS", 19, OPpASSIGN_BACKWARDS },
        { "OPpASSIGN_CV_TO_GV", 18, OPpASSIGN_CV_TO_GV },
        { "OPpRUNTIME", 10, OPpRUNTIME },
        { "OPpTRANS_FROM_UTF", 17, OPpTRANS_FROM_UTF },
        { "OPpTRANS_TO_UTF", 15, OPpTRANS_TO_UTF },
        { "OPpTRANS_IDENTICAL", 18, OPpTRANS_IDENTICAL },
        { "OPpTRANS_SQUASH", 15, OPpTRANS_SQUASH },
        { "OPpTRANS_COMPLEMENT", 19, OPpTRANS_COMPLEMENT },
        { "OPpTRANS_GROWS", 14, OPpTRANS_GROWS },
        { "OPpTRANS_DELETE", 15, OPpTRANS_DELETE },
        { "OPpREPEAT_DOLIST", 16, OPpREPEAT_DOLIST },
        { "OPpDEREF", 8, OPpDEREF },
        { "OPpDEREF_AV", 11, OPpDEREF_AV },
        { "OPpDEREF_HV", 11, OPpDEREF_HV },
        { "OPpDEREF_SV", 11, OPpDEREF_SV },
        { "OPpENTERSUB_DB", 14, OPpENTERSUB_DB },
        { "OPpENTERSUB_HASTARG", 19, OPpENTERSUB_HASTARG },
        { "OPpENTERSUB_INARGS", 18, OPpENTERSUB_INARGS },
        { "OPpENTERSUB_AMPER", 17, OPpENTERSUB_AMPER },
        { "OPpENTERSUB_NOPAREN", 19, OPpENTERSUB_NOPAREN },
        { "OPpMAY_RETURN_CONSTANT", 22, OPpMAY_RETURN_CONSTANT },
        { "OPpEARLY_CV", 11, OPpEARLY_CV },
        { "OPpLVAL_DEFER", 13, OPpLVAL_DEFER },
        { "OPpSLICEWARNING", 15, OPpSLICEWARNING },
        { "OPpOUR_INTRO", 12, OPpOUR_INTRO },
        { "OPpMAYBE_LVSUB", 14, OPpMAYBE_LVSUB },
        { "OPpTRUEBOOL", 11, OPpTRUEBOOL },
        { "OPpMAYBE_TRUEBOOL", 17, OPpMAYBE_TRUEBOOL },
        { "OPpSUBSTR_REPL_FIRST", 20, OPpSUBSTR_REPL_FIRST },
        { "OPpPAD_STATE", 12, OPpPAD_STATE },
        { "OPpPADRANGE_COUNTMASK", 21, OPpPADRANGE_COUNTMASK },
        { "OPpPADRANGE_COUNTSHIFT", 22, OPpPADRANGE_COUNTSHIFT },
        { "OPpDONT_INIT_GV", 15, OPpDONT_INIT_GV },
        { "OPpALLOW_FAKE", 13, OPpALLOW_FAKE },
        { "OPpITER_REVERSED", 16, OPpITER_REVERSED },
        { "OPpITER_DEF", 11, OPpITER_DEF },
        { "OPpCONST_NOVER", 14, OPpCONST_NOVER },
        { "OPpCONST_SHORTCIRCUIT", 21, OPpCONST_SHORTCIRCUIT },
        { "OPpCONST_STRICT", 15, OPpCONST_STRICT },
        { "OPpCONST_ENTERED", 16, OPpCONST_ENTERED },
        { "OPpCONST_BARE", 13, OPpCONST_BARE },
        { "OPpFLIP_LINENUM", 15, OPpFLIP_LINENUM },
        { "OPpLIST_GUESSED", 15, OPpLIST_GUESSED },
        { "OPpSLICE", 8, OPpSLICE },
        { "OPpEXISTS_SUB", 13, OPpEXISTS_SUB },
        { "OPpSORT_NUMERIC", 15, OPpSORT_NUMERIC },
        { "OPpSORT_INTEGER", 15, OPpSORT_INTEGER },
        { "OPpSORT_REVERSE", 15, OPpSORT_REVERSE },
        { "OPpSORT_INPLACE", 15, OPpSORT_INPLACE },
        { "OPpSORT_DESCEND", 15, OPpSORT_DESCEND },
        { "OPpSORT_QSORT", 13, OPpSORT_QSORT },
        { "OPpSORT_STABLE", 14, OPpSORT_STABLE },
        { "OPpREVERSE_INPLACE", 18, OPpREVERSE_INPLACE },
        { "OPpOPEN_IN_RAW", 14, OPpOPEN_IN_RAW },
        { "OPpOPEN_IN_CRLF", 15, OPpOPEN_IN_CRLF },
        { "OPpOPEN_OUT_RAW", 15, OPpOPEN_OUT_RAW },
        { "OPpOPEN_OUT_CRLF", 16, OPpOPEN_OUT_CRLF },
        { "OPpHUSH_VMSISH", 14, OPpHUSH_VMSISH },
        { "OPpFT_ACCESS", 12, OPpFT_ACCESS },
        { "OPpFT_STACKED", 13, OPpFT_STACKED },
        { "OPpFT_STACKING", 14, OPpFT_STACKING },
        { "OPpFT_AFTER_t", 13, OPpFT_AFTER_t },
        { "OPpGREP_LEX", 11, OPpGREP_LEX },
        { "OPpEVAL_HAS_HH", 14, OPpEVAL_HAS_HH },
        { "OPpEVAL_UNICODE", 15, OPpEVAL_UNICODE },
        { "OPpEVAL_BYTES", 13, OPpEVAL_BYTES },
        { "OPpEVAL_COPHH", 13, OPpEVAL_COPHH },
        { "OPpEVAL_RE_REPARSING", 20, OPpEVAL_RE_REPARSING },
        { "OPpOFFBYONE", 11, OPpOFFBYONE },
        { "OPpCOREARGS_DEREF1", 18, OPpCOREARGS_DEREF1 },
        { "OPpCOREARGS_DEREF2", 18, OPpCOREARGS_DEREF2 },
        { "OPpCOREARGS_SCALARMOD", 21, OPpCOREARGS_SCALARMOD },
        { "OPpCOREARGS_PUSHMARK", 20, OPpCOREARGS_PUSHMARK },
        { "OPpPV_IS_UTF8", 13, OPpPV_IS_UTF8 },
        { "OPpSPLIT_IMPLIM", 15, OPpSPLIT_IMPLIM },
        { "PMf_RETAINT", 11, PMf_RETAINT },
        { "PMf_ONCE", 8, PMf_ONCE },
        { "PMf_USED", 8, PMf_USED },
        { "PMf_CONST", 9, PMf_CONST },
        { "PMf_KEEP", 8, PMf_KEEP },
        { "PMf_GLOBAL", 10, PMf_GLOBAL },
        { "PMf_CONTINUE", 12, PMf_CONTINUE },
        { "PMf_EVAL", 8, PMf_EVAL },
        { "PMf_NONDESTRUCT", 15, PMf_NONDESTRUCT },
        { "PMf_HAS_CV", 10, PMf_HAS_CV },
        { "PMf_CODELIST_PRIVATE", 20, PMf_CODELIST_PRIVATE },
        { "PMf_IS_QR", 9, PMf_IS_QR },
        { "PMf_USE_RE_EVAL", 15, PMf_USE_RE_EVAL },
        { "OA_MARK", 7, OA_MARK },
        { "OA_FOLDCONST", 12, OA_FOLDCONST },
        { "OA_RETSCALAR", 12, OA_RETSCALAR },
        { "OA_TARGET", 9, OA_TARGET },
        { "OA_TARGLEX", 10, OA_TARGLEX },
        { "OA_OTHERINT", 11, OA_OTHERINT },
        { "OA_DANGEROUS", 12, OA_DANGEROUS },
        { "OA_DEFGV", 8, OA_DEFGV },
        { "OCSHIFT", 7, OCSHIFT },
        { "OA_CLASS_MASK", 13, OA_CLASS_MASK },
        { "OA_BASEOP", 9, OA_BASEOP },
        { "OA_UNOP", 7, OA_UNOP },
        { "OA_BINOP", 8, OA_BINOP },
        { "OA_LOGOP", 8, OA_LOGOP },
        { "OA_LISTOP", 9, OA_LISTOP },
        { "OA_PMOP", 7, OA_PMOP },
        { "OA_SVOP", 7, OA_SVOP },
        { "OA_PADOP", 8, OA_PADOP },
        { "OA_PVOP_OR_SVOP", 15, OA_PVOP_OR_SVOP },
        { "OA_LOOP", 7, OA_LOOP },
        { "OA_COP", 6, OA_COP },
        { "OA_BASEOP_OR_UNOP", 17, OA_BASEOP_OR_UNOP },
        { "OA_FILESTATOP", 13, OA_FILESTATOP },
        { "OA_LOOPEXOP", 11, OA_LOOPEXOP },
        { "OASHIFT", 7, OASHIFT },
        { "OA_SCALAR", 9, OA_SCALAR },
        { "OA_LIST", 7, OA_LIST },
        { "OA_AVREF", 8, OA_AVREF },
        { "OA_HVREF", 8, OA_HVREF },
        { "OA_CVREF", 8, OA_CVREF },
        { "OA_FILEREF", 10, OA_FILEREF },
        { "OA_SCALARREF", 12, OA_SCALARREF },
        { "OA_OPTIONAL", 11, OA_OPTIONAL },
        { "PERL_LOADMOD_DENY", 17, PERL_LOADMOD_DENY },
        { "PERL_LOADMOD_NOIMPORT", 21, PERL_LOADMOD_NOIMPORT },
        { "PERL_LOADMOD_IMPORT_OPS", 23, PERL_LOADMOD_IMPORT_OPS },
        { "BHKf_bhk_start", 14, BHKf_bhk_start },
        { "BHKf_bhk_pre_end", 16, BHKf_bhk_pre_end },
        { "BHKf_bhk_post_end", 17, BHKf_bhk_post_end },
        { "BHKf_bhk_eval", 13, BHKf_bhk_eval },
        { "RV2CVOPCV_MARK_EARLY", 20, RV2CVOPCV_MARK_EARLY },
        { "RV2CVOPCV_RETURN_NAME_GV", 24, RV2CVOPCV_RETURN_NAME_GV },
        { "OP_LVALUE_NO_CROAK", 18, OP_LVALUE_NO_CROAK },
        { "XOPf_xop_name", 13, XOPf_xop_name },
        { "XOPf_xop_desc", 13, XOPf_xop_desc },
        { "XOPf_xop_class", 14, XOPf_xop_class },
        { "XOPf_xop_peep", 13, XOPf_xop_peep },
        { "RXf_PMf_STD_PMMOD_SHIFT", 23, RXf_PMf_STD_PMMOD_SHIFT },
        { "RXf_PMf_MULTILINE", 17, RXf_PMf_MULTILINE },
        { "RXf_PMf_SINGLELINE", 18, RXf_PMf_SINGLELINE },
        { "RXf_PMf_FOLD", 12, RXf_PMf_FOLD },
        { "RXf_PMf_EXTENDED", 16, RXf_PMf_EXTENDED },
        { "RXf_PMf_KEEPCOPY", 16, RXf_PMf_KEEPCOPY },
        { "RXf_PMf_CHARSET", 15, RXf_PMf_CHARSET },
        { "RXf_PMf_SPLIT", 13, RXf_PMf_SPLIT },
        { "PMf_MULTILINE", 13, PMf_MULTILINE },
        { "PMf_SINGLELINE", 14, PMf_SINGLELINE },
        { "PMf_FOLD", 8, PMf_FOLD },
        { "PMf_EXTENDED", 12, PMf_EXTENDED },
        { "PMf_KEEPCOPY", 12, PMf_KEEPCOPY },
        { "PMf_CHARSET", 11, PMf_CHARSET },
        { "PMf_SPLIT", 9, PMf_SPLIT },
        { "RXf_SPLIT", 9, RXf_SPLIT },
        { "RXf_IS_ANCHORED", 15, RXf_IS_ANCHORED },
        { "RXf_UNUSED1", 11, RXf_UNUSED1 },
        { "RXf_UNUSED2", 11, RXf_UNUSED2 },
        { "RXf_UNUSED3", 11, RXf_UNUSED3 },
        { "RXf_UNUSED4", 11, RXf_UNUSED4 },
        { "RXf_UNUSED5", 11, RXf_UNUSED5 },
        { "RXf_NO_INPLACE_SUBST", 20, RXf_NO_INPLACE_SUBST },
        { "RXf_EVAL_SEEN", 13, RXf_EVAL_SEEN },
        { "RXf_UNUSED8", 11, RXf_UNUSED8 },
        { "RXf_UNBOUNDED_QUANTIFIER_SEEN", 29, RXf_UNBOUNDED_QUANTIFIER_SEEN },
        { "RXf_CHECK_ALL", 13, RXf_CHECK_ALL },
        { "RXf_MATCH_UTF8", 14, RXf_MATCH_UTF8 },
        { "RXf_USE_INTUIT_NOML", 19, RXf_USE_INTUIT_NOML },
        { "RXf_USE_INTUIT_ML", 17, RXf_USE_INTUIT_ML },
        { "RXf_INTUIT_TAIL", 15, RXf_INTUIT_TAIL },
        { "RXf_COPY_DONE", 13, RXf_COPY_DONE },
        { "RXf_TAINTED_SEEN", 16, RXf_TAINTED_SEEN },
        { "RXf_TAINTED", 11, RXf_TAINTED },
        { "RXf_START_ONLY", 14, RXf_START_ONLY },
        { "RXf_SKIPWHITE", 13, RXf_SKIPWHITE },
        { "RXf_WHITE", 9, RXf_WHITE },
        { "SVf_IOK", 7, SVf_IOK },
        { "SVf_NOK", 7, SVf_NOK },
        { "SVf_POK", 7, SVf_POK },
        { "SVf_ROK", 7, SVf_ROK },
        { "SVp_IOK", 7, SVp_IOK },
        { "SVp_NOK", 7, SVp_NOK },
        { "SVp_POK", 7, SVp_POK },
        { "SVp_SCREAM", 10, SVp_SCREAM },
        { "SVf_IsCOW", 9, SVf_IsCOW },
        { "SVs_PADTMP", 10, SVs_PADTMP },
        { "SVs_PADSTALE", 12, SVs_PADSTALE },
        { "SVpad_TYPED", 11, SVpad_TYPED },
        { "SVs_PADMY", 9, SVs_PADMY },
        { "SVpad_OUR", 9, SVpad_OUR },
        { "SVs_TEMP", 8, SVs_TEMP },
        { "SVs_OBJECT", 10, SVs_OBJECT },
        { "SVs_GMG", 7, SVs_GMG },
        { "SVs_SMG", 7, SVs_SMG },
        { "SVs_RMG", 7, SVs_RMG },
        { "SVf_FAKE", 8, SVf_FAKE },
        { "SVf_OOK", 7, SVf_OOK },
        { "SVf_BREAK", 9, SVf_BREAK },
        { "SVf_READONLY", 12, SVf_READONLY },
        { "SVf_AMAGIC", 10, SVf_AMAGIC },
        { "SVf_UTF8", 8, SVf_UTF8 },
        { "SVf_IVisUV", 10, SVf_IVisUV },
        { "SVpad_STATE", 11, SVpad_STATE },
        { NULL, 0, 0 } };
	const struct uv_s *value_for_uv = values_for_uv;
        while (value_for_iv->name) {
	    he = _add_symbol(aTHX_  symbol_table, value_for_iv->name,
				     value_for_iv->namelen, newSViv(value_for_iv->value));
	    av_push(push, newSVhek(HeKEY_hek(he)));
            ++value_for_iv;
	}
        while (value_for_uv->name) {
	    he = _add_symbol(aTHX_  symbol_table, value_for_uv->name,
				     value_for_uv->namelen, newSVuv(value_for_uv->value));
	    av_push(push, newSVhek(HeKEY_hek(he)));
            ++value_for_uv;
	}
	if (C_ARRAY_LENGTH(values_for_notfound) > 1) {
#ifndef SYMBIAN
	    HV *const _missing = get_missing_hash(aTHX);
#endif
	    const struct notfound_s *value_for_notfound = values_for_notfound;
	    do {

		/* Need to add prototypes, else parsing will vary by platform.  */
		HE *he = (HE*) hv_common_key_len(symbol_table,
						 value_for_notfound->name,
						 value_for_notfound->namelen,
						 HV_FETCH_LVALUE, NULL, 0);
		SV *sv;
#ifndef SYMBIAN
		HEK *hek;
#endif
		if (!he) {
		    Perl_croak(aTHX_ 
			       "Couldn't add key '%s' to %%B::",
			       value_for_notfound->name);
		}
		sv = HeVAL(he);
		if (!SvOK(sv) && SvTYPE(sv) != SVt_PVGV) {
		    /* Nothing was here before, so mark a prototype of ""  */
		    sv_setpvn(sv, "", 0);
		} else if (SvPOK(sv) && SvCUR(sv) == 0) {
		    /* There is already a prototype of "" - do nothing  */
		} else {
		    /* Someone has been here before us - have to make a real
		       typeglob.  */
		    /* It turns out to be incredibly hard to deal with all the
		       corner cases of sub foo (); and reporting errors correctly,
		       so lets cheat a bit.  Start with a constant subroutine  */
		    CV *cv = newCONSTSUB(symbol_table,
					 value_for_notfound->name,
					 &PL_sv_yes);
		    /* and then turn it into a non constant declaration only.  */
		    SvREFCNT_dec(CvXSUBANY(cv).any_ptr);
		    CvCONST_off(cv);
		    CvXSUB(cv) = NULL;
		    CvXSUBANY(cv).any_ptr = NULL;
		}
#ifndef SYMBIAN
		hek = HeKEY_hek(he);
		if (!hv_common(_missing, NULL, HEK_KEY(hek),
 			       HEK_LEN(hek), HEK_FLAGS(hek), HV_FETCH_ISSTORE,
			       &PL_sv_yes, HEK_HASH(hek)))
		    Perl_croak(aTHX_  "Couldn't add key '%s' to missing_hash",
			       value_for_notfound->name);
#endif
		av_push(push, newSVhek(hek));
	    } while ((++value_for_notfound)->name);
	}
    /* As we've been creating subroutines, we better invalidate any cached
       methods  */
    mro_method_changed_in(symbol_table);
  }

#line 747 "B.xs"
{
    CV *cv;
    const char *file = __FILE__;
    MY_CXT_INIT;
    specialsv_list[0] = Nullsv;
    specialsv_list[1] = &PL_sv_undef;
    specialsv_list[2] = &PL_sv_yes;
    specialsv_list[3] = &PL_sv_no;
    specialsv_list[4] = (SV *) pWARN_ALL;
    specialsv_list[5] = (SV *) pWARN_NONE;
    specialsv_list[6] = (SV *) pWARN_STD;

    cv = newXS("B::init_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, initav);
    cv = newXS("B::check_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, checkav_save);
    cv = newXS("B::unitcheck_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, unitcheckav_save);
    cv = newXS("B::begin_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, beginav_save);
    cv = newXS("B::end_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, endav);
    cv = newXS("B::main_cv", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, main_cv);
    cv = newXS("B::inc_gv", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, incgv);
    cv = newXS("B::defstash", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, defstash);
    cv = newXS("B::curstash", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, curstash);
#ifdef PL_formfeed
    cv = newXS("B::formfeed", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, formfeed);
#endif
#ifdef USE_ITHREADS
    cv = newXS("B::regex_padav", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, regex_padav);
#endif
    cv = newXS("B::warnhook", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, warnhook);
    cv = newXS("B::diehook", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, diehook);
}

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#if XSubPPtmpAAAF
#endif
#if XSubPPtmpAAAG
#endif
#line 3902 "B.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}


/* valacallabletype.c generated by valac, the Vala compiler
 * generated from valacallabletype.vala, do not modify */

/* valacallabletype.vala
 *
 * Copyright (C) 2017  Rico Tzschichholz
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Rico Tzschichholz <ricotz@ubuntu.com>
 */

#include "vala.h"
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <valagee.h>
#include <glib-object.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _vala_code_node_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_node_unref (var), NULL)))
#define _vala_iterable_unref0(var) ((var == NULL) ? NULL : (var = (vala_iterable_unref (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))

static gpointer vala_callable_type_parent_class = NULL;

static gchar* vala_callable_type_real_to_prototype_string (ValaDataType* base,
                                                    const gchar* override_name);

static gpointer
_vala_code_node_ref0 (gpointer self)
{
	return self ? vala_code_node_ref (self) : NULL;
}

static gpointer
_vala_iterable_ref0 (gpointer self)
{
	return self ? vala_iterable_ref (self) : NULL;
}

static gchar*
vala_callable_type_real_to_prototype_string (ValaDataType* base,
                                             const gchar* override_name)
{
	ValaCallableType * self;
	GString* builder = NULL;
	GString* _tmp0_;
	ValaDataType* return_type = NULL;
	ValaDataType* _tmp1_;
	ValaDataType* _tmp2_;
	GString* _tmp4_;
	ValaDataType* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	GString* _tmp8_;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_;
	GString* _tmp12_;
	GString* _tmp13_;
	GString* _tmp14_;
	gint i = 0;
	ValaDelegateType* delegate_type = NULL;
	ValaDelegateType* _tmp15_;
	ValaDelegateType* _tmp16_;
	GString* _tmp94_;
	ValaArrayList* error_types = NULL;
	GEqualFunc _tmp95_;
	ValaArrayList* _tmp96_;
	ValaArrayList* _tmp97_;
	ValaArrayList* _tmp98_;
	gint _tmp99_;
	gint _tmp100_;
	GString* _tmp114_;
	const gchar* _tmp115_;
	gchar* _tmp116_;
	gchar* result = NULL;
	self = (ValaCallableType*) base;
	_tmp0_ = g_string_new ("");
	builder = _tmp0_;
	_tmp1_ = vala_data_type_get_return_type ((ValaDataType*) self);
	return_type = _tmp1_;
	_tmp2_ = return_type;
	if (vala_data_type_is_weak (_tmp2_)) {
		GString* _tmp3_;
		_tmp3_ = builder;
		g_string_append (_tmp3_, "unowned ");
	}
	_tmp4_ = builder;
	_tmp5_ = return_type;
	_tmp6_ = vala_data_type_to_qualified_string (_tmp5_, NULL);
	_tmp7_ = _tmp6_;
	g_string_append (_tmp4_, _tmp7_);
	_g_free0 (_tmp7_);
	_tmp8_ = builder;
	g_string_append_c (_tmp8_, ' ');
	_tmp10_ = g_strdup (override_name);
	_tmp9_ = _tmp10_;
	if (_tmp9_ == NULL) {
		gchar* _tmp11_;
		_tmp11_ = vala_code_node_to_string ((ValaCodeNode*) self);
		_g_free0 (_tmp9_);
		_tmp9_ = _tmp11_;
	}
	_tmp12_ = builder;
	g_string_append (_tmp12_, _tmp9_);
	_tmp13_ = builder;
	g_string_append_c (_tmp13_, ' ');
	_tmp14_ = builder;
	g_string_append_c (_tmp14_, '(');
	i = 1;
	_tmp15_ = _vala_code_node_ref0 (VALA_IS_DELEGATE_TYPE (self) ? ((ValaDelegateType*) self) : NULL);
	delegate_type = _tmp15_;
	_tmp16_ = delegate_type;
	if (_tmp16_ != NULL) {
		ValaDelegate* delegate_symbol = NULL;
		ValaDelegateType* _tmp17_;
		ValaDelegate* _tmp18_;
		ValaDelegate* _tmp19_;
		ValaDelegate* _tmp20_;
		gboolean _tmp21_ = FALSE;
		ValaDelegate* _tmp22_;
		ValaSymbol* _tmp23_;
		ValaSymbol* _tmp24_;
		_tmp17_ = delegate_type;
		_tmp18_ = vala_delegate_type_get_delegate_symbol (_tmp17_);
		_tmp19_ = _tmp18_;
		_tmp20_ = _vala_code_node_ref0 (_tmp19_);
		delegate_symbol = _tmp20_;
		_tmp22_ = delegate_symbol;
		_tmp23_ = vala_symbol_get_parent_symbol ((ValaSymbol*) _tmp22_);
		_tmp24_ = _tmp23_;
		if (VALA_IS_SIGNAL (_tmp24_)) {
			ValaDelegate* _tmp25_;
			ValaDataType* _tmp26_;
			ValaDataType* _tmp27_;
			_tmp25_ = delegate_symbol;
			_tmp26_ = vala_delegate_get_sender_type (_tmp25_);
			_tmp27_ = _tmp26_;
			_tmp21_ = _tmp27_ != NULL;
		} else {
			_tmp21_ = FALSE;
		}
		if (_tmp21_) {
			GString* _tmp28_;
			ValaDelegate* _tmp29_;
			ValaDataType* _tmp30_;
			ValaDataType* _tmp31_;
			gchar* _tmp32_;
			gchar* _tmp33_;
			gint _tmp34_;
			_tmp28_ = builder;
			_tmp29_ = delegate_symbol;
			_tmp30_ = vala_delegate_get_sender_type (_tmp29_);
			_tmp31_ = _tmp30_;
			_tmp32_ = vala_data_type_to_qualified_string (_tmp31_, NULL);
			_tmp33_ = _tmp32_;
			g_string_append (_tmp28_, _tmp33_);
			_g_free0 (_tmp33_);
			_tmp34_ = i;
			i = _tmp34_ + 1;
		}
		_vala_code_node_unref0 (delegate_symbol);
	}
	{
		ValaList* _param_list = NULL;
		ValaList* _tmp35_;
		gint _param_size = 0;
		ValaList* _tmp36_;
		gint _tmp37_;
		gint _tmp38_;
		gint _param_index = 0;
		_tmp35_ = vala_data_type_get_parameters ((ValaDataType*) self);
		_param_list = _tmp35_;
		_tmp36_ = _param_list;
		_tmp37_ = vala_collection_get_size ((ValaCollection*) _tmp36_);
		_tmp38_ = _tmp37_;
		_param_size = _tmp38_;
		_param_index = -1;
		while (TRUE) {
			ValaParameter* param = NULL;
			ValaList* _tmp39_;
			gpointer _tmp40_;
			ValaParameter* _tmp42_;
			gboolean _tmp43_;
			gboolean _tmp44_;
			ValaParameter* _tmp46_;
			gboolean _tmp47_;
			gboolean _tmp48_;
			ValaParameter* _tmp50_;
			ValaParameterDirection _tmp51_;
			ValaParameterDirection _tmp52_;
			GString* _tmp77_;
			ValaParameter* _tmp78_;
			ValaDataType* _tmp79_;
			ValaDataType* _tmp80_;
			gchar* _tmp81_;
			gchar* _tmp82_;
			ValaParameter* _tmp83_;
			ValaExpression* _tmp84_;
			ValaExpression* _tmp85_;
			gint _tmp93_;
			_param_index = _param_index + 1;
			if (!(_param_index < _param_size)) {
				break;
			}
			_tmp39_ = _param_list;
			_tmp40_ = vala_list_get (_tmp39_, _param_index);
			param = (ValaParameter*) _tmp40_;
			if (i > 1) {
				GString* _tmp41_;
				_tmp41_ = builder;
				g_string_append (_tmp41_, ", ");
			}
			_tmp42_ = param;
			_tmp43_ = vala_parameter_get_ellipsis (_tmp42_);
			_tmp44_ = _tmp43_;
			if (_tmp44_) {
				GString* _tmp45_;
				_tmp45_ = builder;
				g_string_append (_tmp45_, "...");
				_vala_code_node_unref0 (param);
				continue;
			}
			_tmp46_ = param;
			_tmp47_ = vala_parameter_get_params_array (_tmp46_);
			_tmp48_ = _tmp47_;
			if (_tmp48_) {
				GString* _tmp49_;
				_tmp49_ = builder;
				g_string_append (_tmp49_, "params ");
			}
			_tmp50_ = param;
			_tmp51_ = vala_parameter_get_direction (_tmp50_);
			_tmp52_ = _tmp51_;
			if (_tmp52_ == VALA_PARAMETER_DIRECTION_IN) {
				ValaParameter* _tmp53_;
				ValaDataType* _tmp54_;
				ValaDataType* _tmp55_;
				gboolean _tmp56_;
				gboolean _tmp57_;
				_tmp53_ = param;
				_tmp54_ = vala_variable_get_variable_type ((ValaVariable*) _tmp53_);
				_tmp55_ = _tmp54_;
				_tmp56_ = vala_data_type_get_value_owned (_tmp55_);
				_tmp57_ = _tmp56_;
				if (_tmp57_) {
					GString* _tmp58_;
					_tmp58_ = builder;
					g_string_append (_tmp58_, "owned ");
				}
			} else {
				ValaParameter* _tmp59_;
				ValaParameterDirection _tmp60_;
				ValaParameterDirection _tmp61_;
				gboolean _tmp67_ = FALSE;
				ValaParameter* _tmp68_;
				ValaDataType* _tmp69_;
				ValaDataType* _tmp70_;
				gboolean _tmp71_;
				gboolean _tmp72_;
				_tmp59_ = param;
				_tmp60_ = vala_parameter_get_direction (_tmp59_);
				_tmp61_ = _tmp60_;
				if (_tmp61_ == VALA_PARAMETER_DIRECTION_REF) {
					GString* _tmp62_;
					_tmp62_ = builder;
					g_string_append (_tmp62_, "ref ");
				} else {
					ValaParameter* _tmp63_;
					ValaParameterDirection _tmp64_;
					ValaParameterDirection _tmp65_;
					_tmp63_ = param;
					_tmp64_ = vala_parameter_get_direction (_tmp63_);
					_tmp65_ = _tmp64_;
					if (_tmp65_ == VALA_PARAMETER_DIRECTION_OUT) {
						GString* _tmp66_;
						_tmp66_ = builder;
						g_string_append (_tmp66_, "out ");
					}
				}
				_tmp68_ = param;
				_tmp69_ = vala_variable_get_variable_type ((ValaVariable*) _tmp68_);
				_tmp70_ = _tmp69_;
				_tmp71_ = vala_data_type_get_value_owned (_tmp70_);
				_tmp72_ = _tmp71_;
				if (!_tmp72_) {
					ValaParameter* _tmp73_;
					ValaDataType* _tmp74_;
					ValaDataType* _tmp75_;
					_tmp73_ = param;
					_tmp74_ = vala_variable_get_variable_type ((ValaVariable*) _tmp73_);
					_tmp75_ = _tmp74_;
					_tmp67_ = VALA_IS_REFERENCE_TYPE (_tmp75_);
				} else {
					_tmp67_ = FALSE;
				}
				if (_tmp67_) {
					GString* _tmp76_;
					_tmp76_ = builder;
					g_string_append (_tmp76_, "weak ");
				}
			}
			_tmp77_ = builder;
			_tmp78_ = param;
			_tmp79_ = vala_variable_get_variable_type ((ValaVariable*) _tmp78_);
			_tmp80_ = _tmp79_;
			_tmp81_ = vala_data_type_to_qualified_string (_tmp80_, NULL);
			_tmp82_ = _tmp81_;
			g_string_append (_tmp77_, _tmp82_);
			_g_free0 (_tmp82_);
			_tmp83_ = param;
			_tmp84_ = vala_variable_get_initializer ((ValaVariable*) _tmp83_);
			_tmp85_ = _tmp84_;
			if (_tmp85_ != NULL) {
				GString* _tmp86_;
				GString* _tmp87_;
				ValaParameter* _tmp88_;
				ValaExpression* _tmp89_;
				ValaExpression* _tmp90_;
				gchar* _tmp91_;
				gchar* _tmp92_;
				_tmp86_ = builder;
				g_string_append (_tmp86_, " = ");
				_tmp87_ = builder;
				_tmp88_ = param;
				_tmp89_ = vala_variable_get_initializer ((ValaVariable*) _tmp88_);
				_tmp90_ = _tmp89_;
				_tmp91_ = vala_code_node_to_string ((ValaCodeNode*) _tmp90_);
				_tmp92_ = _tmp91_;
				g_string_append (_tmp87_, _tmp92_);
				_g_free0 (_tmp92_);
			}
			_tmp93_ = i;
			i = _tmp93_ + 1;
			_vala_code_node_unref0 (param);
		}
		_vala_iterable_unref0 (_param_list);
	}
	_tmp94_ = builder;
	g_string_append_c (_tmp94_, ')');
	_tmp95_ = g_direct_equal;
	_tmp96_ = vala_array_list_new (VALA_TYPE_DATA_TYPE, (GBoxedCopyFunc) vala_code_node_ref, (GDestroyNotify) vala_code_node_unref, _tmp95_);
	error_types = _tmp96_;
	_tmp97_ = error_types;
	vala_code_node_get_error_types ((ValaCodeNode*) self, (ValaCollection*) _tmp97_, NULL);
	_tmp98_ = error_types;
	_tmp99_ = vala_collection_get_size ((ValaCollection*) _tmp98_);
	_tmp100_ = _tmp99_;
	if (_tmp100_ > 0) {
		GString* _tmp101_;
		gboolean first = FALSE;
		_tmp101_ = builder;
		g_string_append (_tmp101_, " throws ");
		first = TRUE;
		{
			ValaArrayList* _type_list = NULL;
			ValaArrayList* _tmp102_;
			ValaArrayList* _tmp103_;
			gint _type_size = 0;
			ValaArrayList* _tmp104_;
			gint _tmp105_;
			gint _tmp106_;
			gint _type_index = 0;
			_tmp102_ = error_types;
			_tmp103_ = _vala_iterable_ref0 (_tmp102_);
			_type_list = _tmp103_;
			_tmp104_ = _type_list;
			_tmp105_ = vala_collection_get_size ((ValaCollection*) _tmp104_);
			_tmp106_ = _tmp105_;
			_type_size = _tmp106_;
			_type_index = -1;
			while (TRUE) {
				ValaDataType* type = NULL;
				ValaArrayList* _tmp107_;
				gpointer _tmp108_;
				GString* _tmp110_;
				ValaDataType* _tmp111_;
				gchar* _tmp112_;
				gchar* _tmp113_;
				_type_index = _type_index + 1;
				if (!(_type_index < _type_size)) {
					break;
				}
				_tmp107_ = _type_list;
				_tmp108_ = vala_list_get ((ValaList*) _tmp107_, _type_index);
				type = (ValaDataType*) _tmp108_;
				if (!first) {
					GString* _tmp109_;
					_tmp109_ = builder;
					g_string_append (_tmp109_, ", ");
				} else {
					first = FALSE;
				}
				_tmp110_ = builder;
				_tmp111_ = type;
				_tmp112_ = vala_code_node_to_string ((ValaCodeNode*) _tmp111_);
				_tmp113_ = _tmp112_;
				g_string_append (_tmp110_, _tmp113_);
				_g_free0 (_tmp113_);
				_vala_code_node_unref0 (type);
			}
			_vala_iterable_unref0 (_type_list);
		}
	}
	_tmp114_ = builder;
	_tmp115_ = _tmp114_->str;
	_tmp116_ = g_strdup (_tmp115_);
	result = _tmp116_;
	_vala_iterable_unref0 (error_types);
	_vala_code_node_unref0 (delegate_type);
	_g_free0 (_tmp9_);
	_vala_code_node_unref0 (return_type);
	_g_string_free0 (builder);
	return result;
}

ValaCallableType*
vala_callable_type_construct (GType object_type)
{
	ValaCallableType* self = NULL;
	self = (ValaCallableType*) vala_data_type_construct (object_type);
	return self;
}

static void
vala_callable_type_class_init (ValaCallableTypeClass * klass,
                               gpointer klass_data)
{
	vala_callable_type_parent_class = g_type_class_peek_parent (klass);
	((ValaDataTypeClass *) klass)->to_prototype_string = (gchar* (*) (ValaDataType*, const gchar*)) vala_callable_type_real_to_prototype_string;
}

static void
vala_callable_type_instance_init (ValaCallableType * self,
                                  gpointer klass)
{
}

/**
 * A callable type, i.e. a delegate, method, or signal type.
 */
GType
vala_callable_type_get_type (void)
{
	static volatile gsize vala_callable_type_type_id__volatile = 0;
	if (g_once_init_enter (&vala_callable_type_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ValaCallableTypeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) vala_callable_type_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValaCallableType), 0, (GInstanceInitFunc) vala_callable_type_instance_init, NULL };
		GType vala_callable_type_type_id;
		vala_callable_type_type_id = g_type_register_static (VALA_TYPE_DATA_TYPE, "ValaCallableType", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&vala_callable_type_type_id__volatile, vala_callable_type_type_id);
	}
	return vala_callable_type_type_id__volatile;
}


/* sequencerule.c generated by valac, the Vala compiler
 * generated from sequencerule.vala, do not modify */

/* sequencerule.vala
 *
 * Copyright (C) 2008-2009 Florian Brosch, Didier Villevalois
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Didier 'Ptitjes Villevalois <ptitjes@free.fr>
 */

#include "valadoc.h"
#include <glib-object.h>
#include <glib.h>
#include <stdlib.h>
#include <string.h>

#define VALADOC_TYPE_SEQUENCE_RULE (valadoc_sequence_rule_get_type ())
#define VALADOC_SEQUENCE_RULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALADOC_TYPE_SEQUENCE_RULE, ValadocSequenceRule))
#define VALADOC_SEQUENCE_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALADOC_TYPE_SEQUENCE_RULE, ValadocSequenceRuleClass))
#define VALADOC_IS_SEQUENCE_RULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALADOC_TYPE_SEQUENCE_RULE))
#define VALADOC_IS_SEQUENCE_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALADOC_TYPE_SEQUENCE_RULE))
#define VALADOC_SEQUENCE_RULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALADOC_TYPE_SEQUENCE_RULE, ValadocSequenceRuleClass))

typedef struct _ValadocSequenceRule ValadocSequenceRule;
typedef struct _ValadocSequenceRuleClass ValadocSequenceRuleClass;
typedef struct _ValadocSequenceRulePrivate ValadocSequenceRulePrivate;
enum  {
	VALADOC_SEQUENCE_RULE_0_PROPERTY,
	VALADOC_SEQUENCE_RULE_NUM_PROPERTIES
};
static GParamSpec* valadoc_sequence_rule_properties[VALADOC_SEQUENCE_RULE_NUM_PROPERTIES];

#define VALADOC_SEQUENCE_RULE_TYPE_STATE (valadoc_sequence_rule_state_get_type ())
#define VALADOC_SEQUENCE_RULE_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALADOC_SEQUENCE_RULE_TYPE_STATE, ValadocSequenceRuleState))
#define VALADOC_SEQUENCE_RULE_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALADOC_SEQUENCE_RULE_TYPE_STATE, ValadocSequenceRuleStateClass))
#define VALADOC_SEQUENCE_RULE_IS_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALADOC_SEQUENCE_RULE_TYPE_STATE))
#define VALADOC_SEQUENCE_RULE_IS_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALADOC_SEQUENCE_RULE_TYPE_STATE))
#define VALADOC_SEQUENCE_RULE_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALADOC_SEQUENCE_RULE_TYPE_STATE, ValadocSequenceRuleStateClass))

typedef struct _ValadocSequenceRuleState ValadocSequenceRuleState;
typedef struct _ValadocSequenceRuleStateClass ValadocSequenceRuleStateClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _ValadocSequenceRuleStatePrivate ValadocSequenceRuleStatePrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
enum  {
	VALADOC_SEQUENCE_RULE_STATE_0_PROPERTY,
	VALADOC_SEQUENCE_RULE_STATE_NUM_PROPERTIES
};
static GParamSpec* valadoc_sequence_rule_state_properties[VALADOC_SEQUENCE_RULE_STATE_NUM_PROPERTIES];

struct _ValadocSequenceRule {
	ValadocRule parent_instance;
	ValadocSequenceRulePrivate * priv;
};

struct _ValadocSequenceRuleClass {
	ValadocRuleClass parent_class;
};

struct _ValadocSequenceRulePrivate {
	GObject** _scheme;
	gint _scheme_length1;
	gint __scheme_size_;
};

struct _ValadocSequenceRuleState {
	GObject parent_instance;
	gint index;
	ValadocSequenceRuleStatePrivate * priv;
};

struct _ValadocSequenceRuleStateClass {
	GObjectClass parent_class;
};

static gint ValadocSequenceRule_private_offset;
static gpointer valadoc_sequence_rule_parent_class = NULL;
static gpointer valadoc_sequence_rule_state_parent_class = NULL;

G_GNUC_INTERNAL GType valadoc_sequence_rule_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ValadocSequenceRule, g_object_unref)
G_GNUC_INTERNAL ValadocSequenceRule* valadoc_sequence_rule_new (GObject** scheme,
                                                gint scheme_length1);
G_GNUC_INTERNAL ValadocSequenceRule* valadoc_sequence_rule_construct (GType object_type,
                                                      GObject** scheme,
                                                      gint scheme_length1);
static GObject** _vala_array_dup3 (GObject** self,
                            int length);
static gboolean valadoc_sequence_rule_real_is_optional (ValadocRule* base);
static gboolean valadoc_sequence_rule_real_starts_with_token (ValadocRule* base,
                                                       ValadocToken* token);
static gboolean valadoc_sequence_rule_test_token (ValadocSequenceRule* self,
                                           gint from_index,
                                           ValadocToken* token);
static gboolean valadoc_sequence_rule_test_reduce (ValadocSequenceRule* self,
                                            gint from_index,
                                            ValadocToken* token);
static gboolean valadoc_sequence_rule_real_accept_token (ValadocRule* base,
                                                  ValadocToken* token,
                                                  ValadocParserCallback* parser,
                                                  ValadocRuleForward forward,
                                                  GError** error);
static GType valadoc_sequence_rule_state_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ValadocSequenceRuleState, g_object_unref)
static ValadocSequenceRuleState* valadoc_sequence_rule_state_new (void);
static ValadocSequenceRuleState* valadoc_sequence_rule_state_construct (GType object_type);
static gboolean valadoc_sequence_rule_real_would_accept_token (ValadocRule* base,
                                                        ValadocToken* token,
                                                        GObject* rule_state);
static gboolean valadoc_sequence_rule_real_would_reduce (ValadocRule* base,
                                                  ValadocToken* token,
                                                  GObject* rule_state);
static gchar* valadoc_sequence_rule_real_to_string (ValadocRule* base,
                                             GObject* rule_state);
static void valadoc_sequence_rule_state_finalize (GObject * obj);
static void valadoc_sequence_rule_finalize (GObject * obj);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);

static inline gpointer
valadoc_sequence_rule_get_instance_private (ValadocSequenceRule* self)
{
	return G_STRUCT_MEMBER_P (self, ValadocSequenceRule_private_offset);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static GObject**
_vala_array_dup3 (GObject** self,
                  int length)
{
	GObject** result;
	int i;
	result = g_new0 (GObject*, length + 1);
	for (i = 0; i < length; i++) {
		GObject* _tmp0_;
		_tmp0_ = _g_object_ref0 (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}

G_GNUC_INTERNAL ValadocSequenceRule*
valadoc_sequence_rule_construct (GType object_type,
                                 GObject** scheme,
                                 gint scheme_length1)
{
	ValadocSequenceRule * self = NULL;
	GObject** _tmp0_;
	gint _tmp0__length1;
	self = (ValadocSequenceRule*) valadoc_rule_construct (object_type);
	_tmp0_ = (scheme != NULL) ? _vala_array_dup3 (scheme, scheme_length1) : ((gpointer) scheme);
	_tmp0__length1 = scheme_length1;
	self->priv->_scheme = (_vala_array_free (self->priv->_scheme, self->priv->_scheme_length1, (GDestroyNotify) g_object_unref), NULL);
	self->priv->_scheme = _tmp0_;
	self->priv->_scheme_length1 = _tmp0__length1;
	self->priv->__scheme_size_ = self->priv->_scheme_length1;
	return self;
}

G_GNUC_INTERNAL ValadocSequenceRule*
valadoc_sequence_rule_new (GObject** scheme,
                           gint scheme_length1)
{
	return valadoc_sequence_rule_construct (VALADOC_TYPE_SEQUENCE_RULE, scheme, scheme_length1);
}

static gboolean
valadoc_sequence_rule_real_is_optional (ValadocRule* base)
{
	ValadocSequenceRule * self;
	gboolean result = FALSE;
	self = (ValadocSequenceRule*) base;
	result = FALSE;
	return result;
}

static gboolean
valadoc_sequence_rule_real_starts_with_token (ValadocRule* base,
                                              ValadocToken* token)
{
	ValadocSequenceRule * self;
	gboolean result = FALSE;
	self = (ValadocSequenceRule*) base;
	g_return_val_if_fail (token != NULL, FALSE);
	result = valadoc_sequence_rule_test_token (self, 0, token);
	return result;
}

static gboolean
valadoc_sequence_rule_test_token (ValadocSequenceRule* self,
                                  gint from_index,
                                  ValadocToken* token)
{
	gint i = 0;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (token != NULL, FALSE);
	i = from_index;
	while (TRUE) {
		GObject** _tmp0_;
		gint _tmp0__length1;
		GObject** _tmp1_;
		gint _tmp1__length1;
		GObject* _tmp2_;
		GObject** _tmp3_;
		gint _tmp3__length1;
		GObject* _tmp4_;
		gint _tmp5_;
		_tmp0_ = self->priv->_scheme;
		_tmp0__length1 = self->priv->_scheme_length1;
		if (!(i < _tmp0__length1)) {
			break;
		}
		_tmp1_ = self->priv->_scheme;
		_tmp1__length1 = self->priv->_scheme_length1;
		_tmp2_ = _tmp1_[i];
		if (valadoc_rule_has_start_token ((ValadocRule*) self, _tmp2_, token)) {
			result = TRUE;
			return result;
		}
		_tmp3_ = self->priv->_scheme;
		_tmp3__length1 = self->priv->_scheme_length1;
		_tmp4_ = _tmp3_[i];
		if (!valadoc_rule_is_optional_rule ((ValadocRule*) self, _tmp4_)) {
			break;
		}
		_tmp5_ = i;
		i = _tmp5_ + 1;
	}
	result = FALSE;
	return result;
}

static gboolean
valadoc_sequence_rule_test_reduce (ValadocSequenceRule* self,
                                   gint from_index,
                                   ValadocToken* token)
{
	gint i = 0;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (token != NULL, FALSE);
	i = from_index;
	while (TRUE) {
		GObject** _tmp0_;
		gint _tmp0__length1;
		GObject** _tmp1_;
		gint _tmp1__length1;
		GObject* _tmp2_;
		gint _tmp3_;
		_tmp0_ = self->priv->_scheme;
		_tmp0__length1 = self->priv->_scheme_length1;
		if (!(i < _tmp0__length1)) {
			break;
		}
		_tmp1_ = self->priv->_scheme;
		_tmp1__length1 = self->priv->_scheme_length1;
		_tmp2_ = _tmp1_[i];
		if (!valadoc_rule_is_optional_rule ((ValadocRule*) self, _tmp2_)) {
			result = FALSE;
			return result;
		}
		_tmp3_ = i;
		i = _tmp3_ + 1;
	}
	result = TRUE;
	return result;
}

static gboolean
valadoc_sequence_rule_real_accept_token (ValadocRule* base,
                                         ValadocToken* token,
                                         ValadocParserCallback* parser,
                                         ValadocRuleForward forward,
                                         GError** error)
{
	ValadocSequenceRule * self;
	ValadocSequenceRuleState* state = NULL;
	GObject* _tmp0_;
	ValadocSequenceRuleState* _tmp1_;
	ValadocSequenceRuleState* _tmp2_;
	ValadocSequenceRuleState* _tmp5_;
	GObject* scheme_element = NULL;
	gboolean handled = FALSE;
	ValadocSequenceRuleState* _tmp33_;
	GObject** _tmp34_;
	gint _tmp34__length1;
	GObject* _tmp37_;
	GError* _inner_error0_ = NULL;
	gboolean result = FALSE;
	self = (ValadocSequenceRule*) base;
	g_return_val_if_fail (token != NULL, FALSE);
	g_return_val_if_fail (parser != NULL, FALSE);
	_tmp0_ = valadoc_parser_callback_get_rule_state (parser);
	_tmp1_ = VALADOC_SEQUENCE_RULE_IS_STATE (_tmp0_) ? ((ValadocSequenceRuleState*) _tmp0_) : NULL;
	if (_tmp1_ == NULL) {
		_g_object_unref0 (_tmp0_);
	}
	state = _tmp1_;
	_tmp2_ = state;
	if (_tmp2_ == NULL) {
		ValadocSequenceRuleState* _tmp3_;
		ValadocSequenceRuleState* _tmp4_;
		_tmp3_ = valadoc_sequence_rule_state_new ();
		_g_object_unref0 (state);
		state = _tmp3_;
		_tmp4_ = state;
		valadoc_parser_callback_set_rule_state (parser, (GObject*) _tmp4_);
	}
	_tmp5_ = state;
	if (_tmp5_->index == 0) {
		valadoc_rule_do_start ((ValadocRule*) self, parser, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == VALADOC_PARSER_ERROR) {
				gboolean _tmp6_ = FALSE;
				g_propagate_error (error, _inner_error0_);
				_g_object_unref0 (state);
				return _tmp6_;
			} else {
				gboolean _tmp7_ = FALSE;
				_g_object_unref0 (state);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return _tmp7_;
			}
		}
	} else {
		ValadocSequenceRuleState* _tmp8_;
		GObject** _tmp9_;
		gint _tmp9__length1;
		_tmp8_ = state;
		_tmp9_ = self->priv->_scheme;
		_tmp9__length1 = self->priv->_scheme_length1;
		if (_tmp8_->index == _tmp9__length1) {
			valadoc_rule_do_reduce ((ValadocRule*) self, parser, &_inner_error0_);
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				if (_inner_error0_->domain == VALADOC_PARSER_ERROR) {
					gboolean _tmp10_ = FALSE;
					g_propagate_error (error, _inner_error0_);
					_g_object_unref0 (state);
					return _tmp10_;
				} else {
					gboolean _tmp11_ = FALSE;
					_g_object_unref0 (state);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
					g_clear_error (&_inner_error0_);
					return _tmp11_;
				}
			}
			result = FALSE;
			_g_object_unref0 (state);
			return result;
		}
	}
	scheme_element = NULL;
	{
		gboolean _tmp12_ = FALSE;
		_tmp12_ = TRUE;
		while (TRUE) {
			GObject** _tmp15_;
			gint _tmp15__length1;
			ValadocSequenceRuleState* _tmp16_;
			GObject* _tmp17_;
			GObject* _tmp18_;
			gboolean _tmp19_ = FALSE;
			GObject* _tmp20_;
			gboolean _tmp21_ = FALSE;
			gboolean _tmp22_;
			GObject* _tmp27_;
			ValadocSequenceRuleState* _tmp31_;
			gint _tmp32_;
			if (!_tmp12_) {
				ValadocSequenceRuleState* _tmp13_;
				GObject** _tmp14_;
				gint _tmp14__length1;
				_tmp13_ = state;
				_tmp14_ = self->priv->_scheme;
				_tmp14__length1 = self->priv->_scheme_length1;
				if (!(_tmp13_->index < _tmp14__length1)) {
					break;
				}
			}
			_tmp12_ = FALSE;
			_tmp15_ = self->priv->_scheme;
			_tmp15__length1 = self->priv->_scheme_length1;
			_tmp16_ = state;
			_tmp17_ = _tmp15_[_tmp16_->index];
			_tmp18_ = _g_object_ref0 (_tmp17_);
			_g_object_unref0 (scheme_element);
			scheme_element = _tmp18_;
			_tmp20_ = scheme_element;
			_tmp22_ = valadoc_rule_try_to_apply ((ValadocRule*) self, _tmp20_, token, parser, &_tmp21_, &_inner_error0_);
			handled = _tmp21_;
			_tmp19_ = _tmp22_;
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				if (_inner_error0_->domain == VALADOC_PARSER_ERROR) {
					gboolean _tmp23_ = FALSE;
					g_propagate_error (error, _inner_error0_);
					_g_object_unref0 (scheme_element);
					_g_object_unref0 (state);
					return _tmp23_;
				} else {
					gboolean _tmp24_ = FALSE;
					_g_object_unref0 (scheme_element);
					_g_object_unref0 (state);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
					g_clear_error (&_inner_error0_);
					return _tmp24_;
				}
			}
			if (_tmp19_) {
				ValadocSequenceRuleState* _tmp25_;
				gint _tmp26_;
				_tmp25_ = state;
				_tmp26_ = _tmp25_->index;
				_tmp25_->index = _tmp26_ + 1;
				result = handled;
				_g_object_unref0 (scheme_element);
				_g_object_unref0 (state);
				return result;
			}
			_tmp27_ = scheme_element;
			if (!valadoc_rule_is_optional_rule ((ValadocRule*) self, _tmp27_)) {
				break;
			} else {
				GObject* _tmp28_;
				_tmp28_ = scheme_element;
				valadoc_rule_do_skip (G_TYPE_CHECK_INSTANCE_CAST (_tmp28_, VALADOC_TYPE_RULE, ValadocRule), parser, &_inner_error0_);
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					if (_inner_error0_->domain == VALADOC_PARSER_ERROR) {
						gboolean _tmp29_ = FALSE;
						g_propagate_error (error, _inner_error0_);
						_g_object_unref0 (scheme_element);
						_g_object_unref0 (state);
						return _tmp29_;
					} else {
						gboolean _tmp30_ = FALSE;
						_g_object_unref0 (scheme_element);
						_g_object_unref0 (state);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
						g_clear_error (&_inner_error0_);
						return _tmp30_;
					}
				}
			}
			_tmp31_ = state;
			_tmp32_ = _tmp31_->index;
			_tmp31_->index = _tmp32_ + 1;
		}
	}
	_tmp33_ = state;
	_tmp34_ = self->priv->_scheme;
	_tmp34__length1 = self->priv->_scheme_length1;
	if (_tmp33_->index == _tmp34__length1) {
		valadoc_rule_do_reduce ((ValadocRule*) self, parser, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == VALADOC_PARSER_ERROR) {
				gboolean _tmp35_ = FALSE;
				g_propagate_error (error, _inner_error0_);
				_g_object_unref0 (scheme_element);
				_g_object_unref0 (state);
				return _tmp35_;
			} else {
				gboolean _tmp36_ = FALSE;
				_g_object_unref0 (scheme_element);
				_g_object_unref0 (state);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return _tmp36_;
			}
		}
		result = FALSE;
		_g_object_unref0 (scheme_element);
		_g_object_unref0 (state);
		return result;
	}
	_tmp37_ = scheme_element;
	if (VALADOC_IS_TOKEN_TYPE (_tmp37_)) {
		GObject* _tmp38_;
		const gchar* _tmp39_;
		gchar* _tmp40_;
		gchar* _tmp41_;
		_tmp38_ = scheme_element;
		_tmp39_ = valadoc_token_type_to_pretty_string (G_TYPE_CHECK_INSTANCE_CAST (_tmp38_, VALADOC_TYPE_TOKEN_TYPE, ValadocTokenType));
		_tmp40_ = g_strdup_printf ("expected %s", _tmp39_);
		_tmp41_ = _tmp40_;
		valadoc_parser_callback_error (parser, token, _tmp41_, &_inner_error0_);
		_g_free0 (_tmp41_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == VALADOC_PARSER_ERROR) {
				gboolean _tmp42_ = FALSE;
				g_propagate_error (error, _inner_error0_);
				_g_object_unref0 (scheme_element);
				_g_object_unref0 (state);
				return _tmp42_;
			} else {
				gboolean _tmp43_ = FALSE;
				_g_object_unref0 (scheme_element);
				_g_object_unref0 (state);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return _tmp43_;
			}
		}
	} else {
		valadoc_parser_callback_error (parser, token, "unexpected token", &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == VALADOC_PARSER_ERROR) {
				gboolean _tmp44_ = FALSE;
				g_propagate_error (error, _inner_error0_);
				_g_object_unref0 (scheme_element);
				_g_object_unref0 (state);
				return _tmp44_;
			} else {
				gboolean _tmp45_ = FALSE;
				_g_object_unref0 (scheme_element);
				_g_object_unref0 (state);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return _tmp45_;
			}
		}
	}
	g_assert_not_reached ();
	_g_object_unref0 (scheme_element);
	_g_object_unref0 (state);
}

static gboolean
valadoc_sequence_rule_real_would_accept_token (ValadocRule* base,
                                               ValadocToken* token,
                                               GObject* rule_state)
{
	ValadocSequenceRule * self;
	ValadocSequenceRuleState* state = NULL;
	ValadocSequenceRuleState* _tmp0_;
	gboolean result = FALSE;
	self = (ValadocSequenceRule*) base;
	g_return_val_if_fail (token != NULL, FALSE);
	_tmp0_ = _g_object_ref0 (VALADOC_SEQUENCE_RULE_IS_STATE (rule_state) ? ((ValadocSequenceRuleState*) rule_state) : NULL);
	state = _tmp0_;
	result = valadoc_sequence_rule_test_token (self, state->index, token);
	_g_object_unref0 (state);
	return result;
}

static gboolean
valadoc_sequence_rule_real_would_reduce (ValadocRule* base,
                                         ValadocToken* token,
                                         GObject* rule_state)
{
	ValadocSequenceRule * self;
	ValadocSequenceRuleState* state = NULL;
	ValadocSequenceRuleState* _tmp0_;
	gboolean _tmp1_ = FALSE;
	ValadocSequenceRuleState* _tmp2_;
	GObject** _tmp3_;
	gint _tmp3__length1;
	gboolean result = FALSE;
	self = (ValadocSequenceRule*) base;
	g_return_val_if_fail (token != NULL, FALSE);
	_tmp0_ = _g_object_ref0 (VALADOC_SEQUENCE_RULE_IS_STATE (rule_state) ? ((ValadocSequenceRuleState*) rule_state) : NULL);
	state = _tmp0_;
	_tmp2_ = state;
	_tmp3_ = self->priv->_scheme;
	_tmp3__length1 = self->priv->_scheme_length1;
	if (_tmp2_->index == _tmp3__length1) {
		_tmp1_ = TRUE;
	} else {
		ValadocSequenceRuleState* _tmp4_;
		_tmp4_ = state;
		_tmp1_ = valadoc_sequence_rule_test_reduce (self, _tmp4_->index, token);
	}
	result = _tmp1_;
	_g_object_unref0 (state);
	return result;
}

static gchar*
valadoc_sequence_rule_real_to_string (ValadocRule* base,
                                      GObject* rule_state)
{
	ValadocSequenceRule * self;
	ValadocSequenceRuleState* state = NULL;
	ValadocSequenceRuleState* _tmp0_;
	ValadocSequenceRuleState* _tmp1_;
	const gchar* _tmp3_ = NULL;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	ValadocSequenceRuleState* _tmp8_;
	GObject** _tmp9_;
	gint _tmp9__length1;
	gchar* _tmp10_;
	gchar* result = NULL;
	self = (ValadocSequenceRule*) base;
	_tmp0_ = _g_object_ref0 (VALADOC_SEQUENCE_RULE_IS_STATE (rule_state) ? ((ValadocSequenceRuleState*) rule_state) : NULL);
	state = _tmp0_;
	_tmp1_ = state;
	if (_tmp1_ == NULL) {
		ValadocSequenceRuleState* _tmp2_;
		_tmp2_ = valadoc_sequence_rule_state_new ();
		_g_object_unref0 (state);
		state = _tmp2_;
	}
	_tmp4_ = valadoc_rule_get_name ((ValadocRule*) self);
	_tmp5_ = _tmp4_;
	if (_tmp5_ != NULL) {
		const gchar* _tmp6_;
		const gchar* _tmp7_;
		_tmp6_ = valadoc_rule_get_name ((ValadocRule*) self);
		_tmp7_ = _tmp6_;
		_tmp3_ = _tmp7_;
	} else {
		_tmp3_ = " ";
	}
	_tmp8_ = state;
	_tmp9_ = self->priv->_scheme;
	_tmp9__length1 = self->priv->_scheme_length1;
	_tmp10_ = g_strdup_printf ("%-15s%-15s(index=%d/%d)", _tmp3_, "[seq]", _tmp8_->index, _tmp9__length1);
	result = _tmp10_;
	_g_object_unref0 (state);
	return result;
}

static ValadocSequenceRuleState*
valadoc_sequence_rule_state_construct (GType object_type)
{
	ValadocSequenceRuleState * self = NULL;
	self = (ValadocSequenceRuleState*) g_object_new (object_type, NULL);
	return self;
}

static ValadocSequenceRuleState*
valadoc_sequence_rule_state_new (void)
{
	return valadoc_sequence_rule_state_construct (VALADOC_SEQUENCE_RULE_TYPE_STATE);
}

static void
valadoc_sequence_rule_state_class_init (ValadocSequenceRuleStateClass * klass,
                                        gpointer klass_data)
{
	valadoc_sequence_rule_state_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = valadoc_sequence_rule_state_finalize;
}

static void
valadoc_sequence_rule_state_instance_init (ValadocSequenceRuleState * self,
                                           gpointer klass)
{
	self->index = 0;
}

static void
valadoc_sequence_rule_state_finalize (GObject * obj)
{
	ValadocSequenceRuleState * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, VALADOC_SEQUENCE_RULE_TYPE_STATE, ValadocSequenceRuleState);
	G_OBJECT_CLASS (valadoc_sequence_rule_state_parent_class)->finalize (obj);
}

static GType
valadoc_sequence_rule_state_get_type (void)
{
	static volatile gsize valadoc_sequence_rule_state_type_id__volatile = 0;
	if (g_once_init_enter (&valadoc_sequence_rule_state_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ValadocSequenceRuleStateClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) valadoc_sequence_rule_state_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValadocSequenceRuleState), 0, (GInstanceInitFunc) valadoc_sequence_rule_state_instance_init, NULL };
		GType valadoc_sequence_rule_state_type_id;
		valadoc_sequence_rule_state_type_id = g_type_register_static (G_TYPE_OBJECT, "ValadocSequenceRuleState", &g_define_type_info, 0);
		g_once_init_leave (&valadoc_sequence_rule_state_type_id__volatile, valadoc_sequence_rule_state_type_id);
	}
	return valadoc_sequence_rule_state_type_id__volatile;
}

static void
valadoc_sequence_rule_class_init (ValadocSequenceRuleClass * klass,
                                  gpointer klass_data)
{
	valadoc_sequence_rule_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &ValadocSequenceRule_private_offset);
	((ValadocRuleClass *) klass)->is_optional = (gboolean (*) (ValadocRule*)) valadoc_sequence_rule_real_is_optional;
	((ValadocRuleClass *) klass)->starts_with_token = (gboolean (*) (ValadocRule*, ValadocToken*)) valadoc_sequence_rule_real_starts_with_token;
	((ValadocRuleClass *) klass)->accept_token = (gboolean (*) (ValadocRule*, ValadocToken*, ValadocParserCallback*, ValadocRuleForward, GError**)) valadoc_sequence_rule_real_accept_token;
	((ValadocRuleClass *) klass)->would_accept_token = (gboolean (*) (ValadocRule*, ValadocToken*, GObject*)) valadoc_sequence_rule_real_would_accept_token;
	((ValadocRuleClass *) klass)->would_reduce = (gboolean (*) (ValadocRule*, ValadocToken*, GObject*)) valadoc_sequence_rule_real_would_reduce;
	((ValadocRuleClass *) klass)->to_string = (gchar* (*) (ValadocRule*, GObject*)) valadoc_sequence_rule_real_to_string;
	G_OBJECT_CLASS (klass)->finalize = valadoc_sequence_rule_finalize;
}

static void
valadoc_sequence_rule_instance_init (ValadocSequenceRule * self,
                                     gpointer klass)
{
	self->priv = valadoc_sequence_rule_get_instance_private (self);
}

static void
valadoc_sequence_rule_finalize (GObject * obj)
{
	ValadocSequenceRule * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, VALADOC_TYPE_SEQUENCE_RULE, ValadocSequenceRule);
	self->priv->_scheme = (_vala_array_free (self->priv->_scheme, self->priv->_scheme_length1, (GDestroyNotify) g_object_unref), NULL);
	G_OBJECT_CLASS (valadoc_sequence_rule_parent_class)->finalize (obj);
}

G_GNUC_INTERNAL GType
valadoc_sequence_rule_get_type (void)
{
	static volatile gsize valadoc_sequence_rule_type_id__volatile = 0;
	if (g_once_init_enter (&valadoc_sequence_rule_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ValadocSequenceRuleClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) valadoc_sequence_rule_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValadocSequenceRule), 0, (GInstanceInitFunc) valadoc_sequence_rule_instance_init, NULL };
		GType valadoc_sequence_rule_type_id;
		valadoc_sequence_rule_type_id = g_type_register_static (VALADOC_TYPE_RULE, "ValadocSequenceRule", &g_define_type_info, 0);
		ValadocSequenceRule_private_offset = g_type_add_instance_private (valadoc_sequence_rule_type_id, sizeof (ValadocSequenceRulePrivate));
		g_once_init_leave (&valadoc_sequence_rule_type_id__volatile, valadoc_sequence_rule_type_id);
	}
	return valadoc_sequence_rule_type_id__volatile;
}

static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


/* rule.c generated by valac, the Vala compiler
 * generated from rule.vala, do not modify */

/* rule.vala
 *
 * Copyright (C) 2008-2009 Florian Brosch, Didier Villevalois
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Didier 'Ptitjes Villevalois <ptitjes@free.fr>
 */

#include "valadoc.h"
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <glib-object.h>

enum  {
	VALADOC_RULE_0_PROPERTY,
	VALADOC_RULE_NAME_PROPERTY,
	VALADOC_RULE_NUM_PROPERTIES
};
static GParamSpec* valadoc_rule_properties[VALADOC_RULE_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))

#define VALADOC_TYPE_SEQUENCE_RULE (valadoc_sequence_rule_get_type ())
#define VALADOC_SEQUENCE_RULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALADOC_TYPE_SEQUENCE_RULE, ValadocSequenceRule))
#define VALADOC_SEQUENCE_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALADOC_TYPE_SEQUENCE_RULE, ValadocSequenceRuleClass))
#define VALADOC_IS_SEQUENCE_RULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALADOC_TYPE_SEQUENCE_RULE))
#define VALADOC_IS_SEQUENCE_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALADOC_TYPE_SEQUENCE_RULE))
#define VALADOC_SEQUENCE_RULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALADOC_TYPE_SEQUENCE_RULE, ValadocSequenceRuleClass))

typedef struct _ValadocSequenceRule ValadocSequenceRule;
typedef struct _ValadocSequenceRuleClass ValadocSequenceRuleClass;

#define VALADOC_TYPE_ONE_OF_RULE (valadoc_one_of_rule_get_type ())
#define VALADOC_ONE_OF_RULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALADOC_TYPE_ONE_OF_RULE, ValadocOneOfRule))
#define VALADOC_ONE_OF_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALADOC_TYPE_ONE_OF_RULE, ValadocOneOfRuleClass))
#define VALADOC_IS_ONE_OF_RULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALADOC_TYPE_ONE_OF_RULE))
#define VALADOC_IS_ONE_OF_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALADOC_TYPE_ONE_OF_RULE))
#define VALADOC_ONE_OF_RULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALADOC_TYPE_ONE_OF_RULE, ValadocOneOfRuleClass))

typedef struct _ValadocOneOfRule ValadocOneOfRule;
typedef struct _ValadocOneOfRuleClass ValadocOneOfRuleClass;

#define VALADOC_TYPE_MANY_RULE (valadoc_many_rule_get_type ())
#define VALADOC_MANY_RULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALADOC_TYPE_MANY_RULE, ValadocManyRule))
#define VALADOC_MANY_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALADOC_TYPE_MANY_RULE, ValadocManyRuleClass))
#define VALADOC_IS_MANY_RULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALADOC_TYPE_MANY_RULE))
#define VALADOC_IS_MANY_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALADOC_TYPE_MANY_RULE))
#define VALADOC_MANY_RULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALADOC_TYPE_MANY_RULE, ValadocManyRuleClass))

typedef struct _ValadocManyRule ValadocManyRule;
typedef struct _ValadocManyRuleClass ValadocManyRuleClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define VALADOC_TYPE_OPTIONAL_RULE (valadoc_optional_rule_get_type ())
#define VALADOC_OPTIONAL_RULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALADOC_TYPE_OPTIONAL_RULE, ValadocOptionalRule))
#define VALADOC_OPTIONAL_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALADOC_TYPE_OPTIONAL_RULE, ValadocOptionalRuleClass))
#define VALADOC_IS_OPTIONAL_RULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALADOC_TYPE_OPTIONAL_RULE))
#define VALADOC_IS_OPTIONAL_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALADOC_TYPE_OPTIONAL_RULE))
#define VALADOC_OPTIONAL_RULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALADOC_TYPE_OPTIONAL_RULE, ValadocOptionalRuleClass))

typedef struct _ValadocOptionalRule ValadocOptionalRule;
typedef struct _ValadocOptionalRuleClass ValadocOptionalRuleClass;
typedef struct _Block3Data Block3Data;
typedef struct _Block4Data Block4Data;
typedef struct _Block5Data Block5Data;

struct _ValadocRulePrivate {
	gchar* _name;
	ValadocRuleAction _start_action;
	gpointer _start_action_target;
	GDestroyNotify _start_action_target_destroy_notify;
	ValadocRuleAction _reduce_action;
	gpointer _reduce_action_target;
	GDestroyNotify _reduce_action_target_destroy_notify;
	ValadocRuleAction _skip_action;
	gpointer _skip_action_target;
	GDestroyNotify _skip_action_target_destroy_notify;
};

struct _Block3Data {
	int _ref_count_;
	ValadocRule* self;
	ValadocRuleAction action;
	gpointer action_target;
};

struct _Block4Data {
	int _ref_count_;
	ValadocRule* self;
	ValadocRuleAction action;
	gpointer action_target;
};

struct _Block5Data {
	int _ref_count_;
	ValadocRule* self;
	ValadocRuleAction action;
	gpointer action_target;
};

static gint ValadocRule_private_offset;
static gpointer valadoc_rule_parent_class = NULL;

G_GNUC_INTERNAL ValadocSequenceRule* valadoc_sequence_rule_new (GObject** scheme,
                                                gint scheme_length1);
G_GNUC_INTERNAL ValadocSequenceRule* valadoc_sequence_rule_construct (GType object_type,
                                                      GObject** scheme,
                                                      gint scheme_length1);
G_GNUC_INTERNAL GType valadoc_sequence_rule_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ValadocSequenceRule, g_object_unref)
G_GNUC_INTERNAL ValadocOneOfRule* valadoc_one_of_rule_new (GObject** scheme,
                                           gint scheme_length1);
G_GNUC_INTERNAL ValadocOneOfRule* valadoc_one_of_rule_construct (GType object_type,
                                                 GObject** scheme,
                                                 gint scheme_length1);
G_GNUC_INTERNAL GType valadoc_one_of_rule_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ValadocOneOfRule, g_object_unref)
G_GNUC_INTERNAL ValadocManyRule* valadoc_many_rule_new (GObject* scheme);
G_GNUC_INTERNAL ValadocManyRule* valadoc_many_rule_construct (GType object_type,
                                              GObject* scheme);
G_GNUC_INTERNAL GType valadoc_many_rule_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ValadocManyRule, g_object_unref)
G_GNUC_INTERNAL ValadocOptionalRule* valadoc_optional_rule_new (GObject* scheme);
G_GNUC_INTERNAL ValadocOptionalRule* valadoc_optional_rule_construct (GType object_type,
                                                      GObject* scheme);
G_GNUC_INTERNAL GType valadoc_optional_rule_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ValadocOptionalRule, g_object_unref)
static Block3Data* block3_data_ref (Block3Data* _data3_);
static void block3_data_unref (void * _userdata_);
static void __lambda5_ (Block3Data* _data3_,
                 GError** error);
static void ___lambda5__valadoc_rule_action (gpointer self,
                                      GError** error);
static Block4Data* block4_data_ref (Block4Data* _data4_);
static void block4_data_unref (void * _userdata_);
static void __lambda6_ (Block4Data* _data4_,
                 GError** error);
static void ___lambda6__valadoc_rule_action (gpointer self,
                                      GError** error);
static Block5Data* block5_data_ref (Block5Data* _data5_);
static void block5_data_unref (void * _userdata_);
static void __lambda7_ (Block5Data* _data5_,
                 GError** error);
static void ___lambda7__valadoc_rule_action (gpointer self,
                                      GError** error);
static gboolean valadoc_rule_real_is_optional (ValadocRule* self);
static gboolean valadoc_rule_real_starts_with_token (ValadocRule* self,
                                              ValadocToken* token);
static gboolean valadoc_rule_real_accept_token (ValadocRule* self,
                                         ValadocToken* token,
                                         ValadocParserCallback* parser,
                                         ValadocRuleForward forward,
                                         GError** error);
static gboolean valadoc_rule_real_would_accept_token (ValadocRule* self,
                                               ValadocToken* token,
                                               GObject* state);
static gboolean valadoc_rule_real_would_reduce (ValadocRule* self,
                                         ValadocToken* token,
                                         GObject* state);
static gchar* valadoc_rule_real_to_string (ValadocRule* self,
                                    GObject* state);
static void valadoc_rule_finalize (GObject * obj);
static void _vala_valadoc_rule_get_property (GObject * object,
                                      guint property_id,
                                      GValue * value,
                                      GParamSpec * pspec);

static inline gpointer
valadoc_rule_get_instance_private (ValadocRule* self)
{
	return G_STRUCT_MEMBER_P (self, ValadocRule_private_offset);
}

GType
valadoc_rule_forward_get_type (void)
{
	static volatile gsize valadoc_rule_forward_type_id__volatile = 0;
	if (g_once_init_enter (&valadoc_rule_forward_type_id__volatile)) {
		static const GEnumValue values[] = {{VALADOC_RULE_FORWARD_NONE, "VALADOC_RULE_FORWARD_NONE", "none"}, {VALADOC_RULE_FORWARD_PARENT, "VALADOC_RULE_FORWARD_PARENT", "parent"}, {VALADOC_RULE_FORWARD_CHILD, "VALADOC_RULE_FORWARD_CHILD", "child"}, {0, NULL, NULL}};
		GType valadoc_rule_forward_type_id;
		valadoc_rule_forward_type_id = g_enum_register_static ("ValadocRuleForward", values);
		g_once_init_leave (&valadoc_rule_forward_type_id__volatile, valadoc_rule_forward_type_id);
	}
	return valadoc_rule_forward_type_id__volatile;
}

ValadocRule*
valadoc_rule_seq (GObject** scheme,
                  gint scheme_length1)
{
	ValadocSequenceRule* _tmp0_;
	ValadocRule* result = NULL;
	_tmp0_ = valadoc_sequence_rule_new (scheme, scheme_length1);
	result = (ValadocRule*) _tmp0_;
	return result;
}

ValadocRule*
valadoc_rule_one_of (GObject** scheme,
                     gint scheme_length1)
{
	ValadocOneOfRule* _tmp0_;
	ValadocRule* result = NULL;
	_tmp0_ = valadoc_one_of_rule_new (scheme, scheme_length1);
	result = (ValadocRule*) _tmp0_;
	return result;
}

ValadocRule*
valadoc_rule_many (GObject** scheme,
                   gint scheme_length1)
{
	ValadocRule* result = NULL;
	if (scheme_length1 == 1) {
		GObject* _tmp0_;
		ValadocManyRule* _tmp1_;
		_tmp0_ = scheme[0];
		_tmp1_ = valadoc_many_rule_new (_tmp0_);
		result = (ValadocRule*) _tmp1_;
		return result;
	} else {
		ValadocSequenceRule* _tmp2_;
		ValadocSequenceRule* _tmp3_;
		ValadocManyRule* _tmp4_;
		ValadocRule* _tmp5_;
		_tmp2_ = valadoc_sequence_rule_new (scheme, scheme_length1);
		_tmp3_ = _tmp2_;
		_tmp4_ = valadoc_many_rule_new ((GObject*) _tmp3_);
		_tmp5_ = (ValadocRule*) _tmp4_;
		_g_object_unref0 (_tmp3_);
		result = _tmp5_;
		return result;
	}
}

ValadocRule*
valadoc_rule_option (GObject** scheme,
                     gint scheme_length1)
{
	ValadocRule* result = NULL;
	if (scheme_length1 == 1) {
		GObject* _tmp0_;
		ValadocOptionalRule* _tmp1_;
		_tmp0_ = scheme[0];
		_tmp1_ = valadoc_optional_rule_new (_tmp0_);
		result = (ValadocRule*) _tmp1_;
		return result;
	} else {
		ValadocSequenceRule* _tmp2_;
		ValadocSequenceRule* _tmp3_;
		ValadocOptionalRule* _tmp4_;
		ValadocRule* _tmp5_;
		_tmp2_ = valadoc_sequence_rule_new (scheme, scheme_length1);
		_tmp3_ = _tmp2_;
		_tmp4_ = valadoc_optional_rule_new ((GObject*) _tmp3_);
		_tmp5_ = (ValadocRule*) _tmp4_;
		_g_object_unref0 (_tmp3_);
		result = _tmp5_;
		return result;
	}
}

ValadocRule*
valadoc_rule_construct (GType object_type)
{
	ValadocRule * self = NULL;
	self = (ValadocRule*) g_object_new (object_type, NULL);
	return self;
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

ValadocRule*
valadoc_rule_set_name (ValadocRule* self,
                       const gchar* name)
{
	gchar* _tmp0_;
	ValadocRule* _tmp1_;
	ValadocRule* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = g_strdup (name);
	_g_free0 (self->priv->_name);
	self->priv->_name = _tmp0_;
	_tmp1_ = _g_object_ref0 (self);
	result = _tmp1_;
	return result;
}

static Block3Data*
block3_data_ref (Block3Data* _data3_)
{
	g_atomic_int_inc (&_data3_->_ref_count_);
	return _data3_;
}

static void
block3_data_unref (void * _userdata_)
{
	Block3Data* _data3_;
	_data3_ = (Block3Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data3_->_ref_count_)) {
		ValadocRule* self;
		self = _data3_->self;
		_g_object_unref0 (self);
		g_slice_free (Block3Data, _data3_);
	}
}

static void
__lambda5_ (Block3Data* _data3_,
            GError** error)
{
	ValadocRule* self;
	GError* _inner_error0_ = NULL;
	self = _data3_->self;
	_data3_->action (_data3_->action_target, &_inner_error0_);
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		if (_inner_error0_->domain == VALADOC_PARSER_ERROR) {
			g_propagate_error (error, _inner_error0_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
}

static void
___lambda5__valadoc_rule_action (gpointer self,
                                 GError** error)
{
	__lambda5_ (self, error);
}

ValadocRule*
valadoc_rule_set_start (ValadocRule* self,
                        ValadocRuleAction action,
                        gpointer action_target)
{
	Block3Data* _data3_;
	ValadocRule* _tmp0_;
	ValadocRule* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_data3_ = g_slice_new0 (Block3Data);
	_data3_->_ref_count_ = 1;
	_data3_->self = g_object_ref (self);
	_data3_->action = action;
	_data3_->action_target = action_target;
	(self->priv->_start_action_target_destroy_notify == NULL) ? NULL : (self->priv->_start_action_target_destroy_notify (self->priv->_start_action_target), NULL);
	self->priv->_start_action = NULL;
	self->priv->_start_action_target = NULL;
	self->priv->_start_action_target_destroy_notify = NULL;
	self->priv->_start_action = ___lambda5__valadoc_rule_action;
	self->priv->_start_action_target = block3_data_ref (_data3_);
	self->priv->_start_action_target_destroy_notify = block3_data_unref;
	_tmp0_ = _g_object_ref0 (self);
	result = _tmp0_;
	block3_data_unref (_data3_);
	_data3_ = NULL;
	return result;
}

static Block4Data*
block4_data_ref (Block4Data* _data4_)
{
	g_atomic_int_inc (&_data4_->_ref_count_);
	return _data4_;
}

static void
block4_data_unref (void * _userdata_)
{
	Block4Data* _data4_;
	_data4_ = (Block4Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data4_->_ref_count_)) {
		ValadocRule* self;
		self = _data4_->self;
		_g_object_unref0 (self);
		g_slice_free (Block4Data, _data4_);
	}
}

static void
__lambda6_ (Block4Data* _data4_,
            GError** error)
{
	ValadocRule* self;
	GError* _inner_error0_ = NULL;
	self = _data4_->self;
	_data4_->action (_data4_->action_target, &_inner_error0_);
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		if (_inner_error0_->domain == VALADOC_PARSER_ERROR) {
			g_propagate_error (error, _inner_error0_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
}

static void
___lambda6__valadoc_rule_action (gpointer self,
                                 GError** error)
{
	__lambda6_ (self, error);
}

ValadocRule*
valadoc_rule_set_reduce (ValadocRule* self,
                         ValadocRuleAction action,
                         gpointer action_target)
{
	Block4Data* _data4_;
	ValadocRule* _tmp0_;
	ValadocRule* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_data4_ = g_slice_new0 (Block4Data);
	_data4_->_ref_count_ = 1;
	_data4_->self = g_object_ref (self);
	_data4_->action = action;
	_data4_->action_target = action_target;
	(self->priv->_reduce_action_target_destroy_notify == NULL) ? NULL : (self->priv->_reduce_action_target_destroy_notify (self->priv->_reduce_action_target), NULL);
	self->priv->_reduce_action = NULL;
	self->priv->_reduce_action_target = NULL;
	self->priv->_reduce_action_target_destroy_notify = NULL;
	self->priv->_reduce_action = ___lambda6__valadoc_rule_action;
	self->priv->_reduce_action_target = block4_data_ref (_data4_);
	self->priv->_reduce_action_target_destroy_notify = block4_data_unref;
	_tmp0_ = _g_object_ref0 (self);
	result = _tmp0_;
	block4_data_unref (_data4_);
	_data4_ = NULL;
	return result;
}

static Block5Data*
block5_data_ref (Block5Data* _data5_)
{
	g_atomic_int_inc (&_data5_->_ref_count_);
	return _data5_;
}

static void
block5_data_unref (void * _userdata_)
{
	Block5Data* _data5_;
	_data5_ = (Block5Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data5_->_ref_count_)) {
		ValadocRule* self;
		self = _data5_->self;
		_g_object_unref0 (self);
		g_slice_free (Block5Data, _data5_);
	}
}

static void
__lambda7_ (Block5Data* _data5_,
            GError** error)
{
	ValadocRule* self;
	GError* _inner_error0_ = NULL;
	self = _data5_->self;
	_data5_->action (_data5_->action_target, &_inner_error0_);
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		if (_inner_error0_->domain == VALADOC_PARSER_ERROR) {
			g_propagate_error (error, _inner_error0_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
}

static void
___lambda7__valadoc_rule_action (gpointer self,
                                 GError** error)
{
	__lambda7_ (self, error);
}

ValadocRule*
valadoc_rule_set_skip (ValadocRule* self,
                       ValadocRuleAction action,
                       gpointer action_target)
{
	Block5Data* _data5_;
	ValadocRule* _tmp0_;
	ValadocRule* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_data5_ = g_slice_new0 (Block5Data);
	_data5_->_ref_count_ = 1;
	_data5_->self = g_object_ref (self);
	_data5_->action = action;
	_data5_->action_target = action_target;
	(self->priv->_skip_action_target_destroy_notify == NULL) ? NULL : (self->priv->_skip_action_target_destroy_notify (self->priv->_skip_action_target), NULL);
	self->priv->_skip_action = NULL;
	self->priv->_skip_action_target = NULL;
	self->priv->_skip_action_target_destroy_notify = NULL;
	self->priv->_skip_action = ___lambda7__valadoc_rule_action;
	self->priv->_skip_action_target = block5_data_ref (_data5_);
	self->priv->_skip_action_target_destroy_notify = block5_data_unref;
	_tmp0_ = _g_object_ref0 (self);
	result = _tmp0_;
	block5_data_unref (_data5_);
	_data5_ = NULL;
	return result;
}

static gboolean
valadoc_rule_real_is_optional (ValadocRule* self)
{
	gboolean _tmp0_ = FALSE;
	g_critical ("Type `%s' does not implement abstract method `valadoc_rule_is_optional'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return _tmp0_;
}

gboolean
valadoc_rule_is_optional (ValadocRule* self)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return VALADOC_RULE_GET_CLASS (self)->is_optional (self);
}

static gboolean
valadoc_rule_real_starts_with_token (ValadocRule* self,
                                     ValadocToken* token)
{
	gboolean _tmp0_ = FALSE;
	g_critical ("Type `%s' does not implement abstract method `valadoc_rule_starts_with_token'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return _tmp0_;
}

gboolean
valadoc_rule_starts_with_token (ValadocRule* self,
                                ValadocToken* token)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return VALADOC_RULE_GET_CLASS (self)->starts_with_token (self, token);
}

static gboolean
valadoc_rule_real_accept_token (ValadocRule* self,
                                ValadocToken* token,
                                ValadocParserCallback* parser,
                                ValadocRuleForward forward,
                                GError** error)
{
	gboolean _tmp0_ = FALSE;
	g_critical ("Type `%s' does not implement abstract method `valadoc_rule_accept_token'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return _tmp0_;
}

gboolean
valadoc_rule_accept_token (ValadocRule* self,
                           ValadocToken* token,
                           ValadocParserCallback* parser,
                           ValadocRuleForward forward,
                           GError** error)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return VALADOC_RULE_GET_CLASS (self)->accept_token (self, token, parser, forward, error);
}

static gboolean
valadoc_rule_real_would_accept_token (ValadocRule* self,
                                      ValadocToken* token,
                                      GObject* state)
{
	gboolean _tmp0_ = FALSE;
	g_critical ("Type `%s' does not implement abstract method `valadoc_rule_would_accept_token'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return _tmp0_;
}

gboolean
valadoc_rule_would_accept_token (ValadocRule* self,
                                 ValadocToken* token,
                                 GObject* state)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return VALADOC_RULE_GET_CLASS (self)->would_accept_token (self, token, state);
}

static gboolean
valadoc_rule_real_would_reduce (ValadocRule* self,
                                ValadocToken* token,
                                GObject* state)
{
	gboolean _tmp0_ = FALSE;
	g_critical ("Type `%s' does not implement abstract method `valadoc_rule_would_reduce'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return _tmp0_;
}

gboolean
valadoc_rule_would_reduce (ValadocRule* self,
                           ValadocToken* token,
                           GObject* state)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return VALADOC_RULE_GET_CLASS (self)->would_reduce (self, token, state);
}

static gchar*
valadoc_rule_real_to_string (ValadocRule* self,
                             GObject* state)
{
	g_critical ("Type `%s' does not implement abstract method `valadoc_rule_to_string'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}

gchar*
valadoc_rule_to_string (ValadocRule* self,
                        GObject* state)
{
	g_return_val_if_fail (self != NULL, NULL);
	return VALADOC_RULE_GET_CLASS (self)->to_string (self, state);
}

gboolean
valadoc_rule_is_optional_rule (ValadocRule* self,
                               GObject* scheme_element)
{
	ValadocRule* scheme_rule = NULL;
	ValadocRule* _tmp0_;
	ValadocRule* _tmp1_;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = _g_object_ref0 (VALADOC_IS_RULE (scheme_element) ? ((ValadocRule*) scheme_element) : NULL);
	scheme_rule = _tmp0_;
	_tmp1_ = scheme_rule;
	if (_tmp1_ != NULL) {
		ValadocRule* _tmp2_;
		_tmp2_ = scheme_rule;
		result = valadoc_rule_is_optional (_tmp2_);
		_g_object_unref0 (scheme_rule);
		return result;
	}
	result = FALSE;
	_g_object_unref0 (scheme_rule);
	return result;
}

gboolean
valadoc_rule_has_start_token (ValadocRule* self,
                              GObject* scheme_element,
                              ValadocToken* token)
{
	ValadocTokenType* scheme_token_type = NULL;
	ValadocTokenType* _tmp0_;
	ValadocTokenType* _tmp1_;
	ValadocRule* scheme_rule = NULL;
	ValadocRule* _tmp3_;
	ValadocRule* _tmp4_;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (token != NULL, FALSE);
	_tmp0_ = _g_object_ref0 (VALADOC_IS_TOKEN_TYPE (scheme_element) ? ((ValadocTokenType*) scheme_element) : NULL);
	scheme_token_type = _tmp0_;
	_tmp1_ = scheme_token_type;
	if (_tmp1_ != NULL) {
		ValadocTokenType* _tmp2_;
		_tmp2_ = scheme_token_type;
		result = valadoc_token_type_matches (_tmp2_, token);
		_g_object_unref0 (scheme_token_type);
		return result;
	}
	_tmp3_ = _g_object_ref0 (VALADOC_IS_RULE (scheme_element) ? ((ValadocRule*) scheme_element) : NULL);
	scheme_rule = _tmp3_;
	_tmp4_ = scheme_rule;
	if (_tmp4_ != NULL) {
		ValadocRule* _tmp5_;
		_tmp5_ = scheme_rule;
		result = valadoc_rule_starts_with_token (_tmp5_, token);
		_g_object_unref0 (scheme_rule);
		_g_object_unref0 (scheme_token_type);
		return result;
	}
	result = FALSE;
	_g_object_unref0 (scheme_rule);
	_g_object_unref0 (scheme_token_type);
	return result;
}

gboolean
valadoc_rule_try_to_apply (ValadocRule* self,
                           GObject* scheme_element,
                           ValadocToken* token,
                           ValadocParserCallback* parser,
                           gboolean* handled,
                           GError** error)
{
	gboolean _vala_handled = FALSE;
	ValadocTokenType* scheme_token_type = NULL;
	ValadocTokenType* _tmp0_;
	gboolean _tmp1_ = FALSE;
	ValadocTokenType* _tmp2_;
	ValadocRule* scheme_rule = NULL;
	ValadocRule* _tmp7_;
	gboolean _tmp8_ = FALSE;
	ValadocRule* _tmp9_;
	GError* _inner_error0_ = NULL;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (token != NULL, FALSE);
	g_return_val_if_fail (parser != NULL, FALSE);
	_tmp0_ = _g_object_ref0 (VALADOC_IS_TOKEN_TYPE (scheme_element) ? ((ValadocTokenType*) scheme_element) : NULL);
	scheme_token_type = _tmp0_;
	_tmp2_ = scheme_token_type;
	if (_tmp2_ != NULL) {
		ValadocTokenType* _tmp3_;
		_tmp3_ = scheme_token_type;
		_tmp1_ = valadoc_token_type_matches (_tmp3_, token);
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		ValadocTokenType* _tmp4_;
		_tmp4_ = scheme_token_type;
		valadoc_token_type_do_action (_tmp4_, token, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == VALADOC_PARSER_ERROR) {
				gboolean _tmp5_ = FALSE;
				g_propagate_error (error, _inner_error0_);
				_g_object_unref0 (scheme_token_type);
				return _tmp5_;
			} else {
				gboolean _tmp6_ = FALSE;
				_g_object_unref0 (scheme_token_type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return _tmp6_;
			}
		}
		_vala_handled = TRUE;
		result = TRUE;
		_g_object_unref0 (scheme_token_type);
		if (handled) {
			*handled = _vala_handled;
		}
		return result;
	}
	_tmp7_ = _g_object_ref0 (VALADOC_IS_RULE (scheme_element) ? ((ValadocRule*) scheme_element) : NULL);
	scheme_rule = _tmp7_;
	_tmp9_ = scheme_rule;
	if (_tmp9_ != NULL) {
		ValadocRule* _tmp10_;
		_tmp10_ = scheme_rule;
		_tmp8_ = valadoc_rule_starts_with_token (_tmp10_, token);
	} else {
		_tmp8_ = FALSE;
	}
	if (_tmp8_) {
		ValadocRule* _tmp11_;
		_tmp11_ = scheme_rule;
		valadoc_parser_callback_push_rule (parser, _tmp11_);
		_vala_handled = FALSE;
		result = TRUE;
		_g_object_unref0 (scheme_rule);
		_g_object_unref0 (scheme_token_type);
		if (handled) {
			*handled = _vala_handled;
		}
		return result;
	}
	_vala_handled = FALSE;
	result = FALSE;
	_g_object_unref0 (scheme_rule);
	_g_object_unref0 (scheme_token_type);
	if (handled) {
		*handled = _vala_handled;
	}
	return result;
}

void
valadoc_rule_do_start (ValadocRule* self,
                       ValadocParserCallback* parser,
                       GError** error)
{
	ValadocRuleAction _tmp0_;
	gpointer _tmp0__target;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (parser != NULL);
	_tmp0_ = self->priv->_start_action;
	_tmp0__target = self->priv->_start_action_target;
	if (_tmp0_ != NULL) {
		ValadocRuleAction _tmp1_;
		gpointer _tmp1__target;
		_tmp1_ = self->priv->_start_action;
		_tmp1__target = self->priv->_start_action_target;
		_tmp1_ (_tmp1__target, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == VALADOC_PARSER_ERROR) {
				g_propagate_error (error, _inner_error0_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return;
			}
		}
	}
}

void
valadoc_rule_do_reduce (ValadocRule* self,
                        ValadocParserCallback* parser,
                        GError** error)
{
	ValadocRuleAction _tmp0_;
	gpointer _tmp0__target;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (parser != NULL);
	_tmp0_ = self->priv->_reduce_action;
	_tmp0__target = self->priv->_reduce_action_target;
	if (_tmp0_ != NULL) {
		ValadocRuleAction _tmp1_;
		gpointer _tmp1__target;
		_tmp1_ = self->priv->_reduce_action;
		_tmp1__target = self->priv->_reduce_action_target;
		_tmp1_ (_tmp1__target, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == VALADOC_PARSER_ERROR) {
				g_propagate_error (error, _inner_error0_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return;
			}
		}
	}
	valadoc_parser_callback_reduce (parser);
}

void
valadoc_rule_do_skip (ValadocRule* self,
                      ValadocParserCallback* parser,
                      GError** error)
{
	ValadocRuleAction _tmp0_;
	gpointer _tmp0__target;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (parser != NULL);
	_tmp0_ = self->priv->_skip_action;
	_tmp0__target = self->priv->_skip_action_target;
	if (_tmp0_ != NULL) {
		ValadocRuleAction _tmp1_;
		gpointer _tmp1__target;
		_tmp1_ = self->priv->_skip_action;
		_tmp1__target = self->priv->_skip_action_target;
		_tmp1_ (_tmp1__target, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == VALADOC_PARSER_ERROR) {
				g_propagate_error (error, _inner_error0_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return;
			}
		}
	}
}

const gchar*
valadoc_rule_get_name (ValadocRule* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_name;
	result = _tmp0_;
	return result;
}

static void
valadoc_rule_class_init (ValadocRuleClass * klass,
                         gpointer klass_data)
{
	valadoc_rule_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &ValadocRule_private_offset);
	((ValadocRuleClass *) klass)->is_optional = (gboolean (*) (ValadocRule*)) valadoc_rule_real_is_optional;
	((ValadocRuleClass *) klass)->starts_with_token = (gboolean (*) (ValadocRule*, ValadocToken*)) valadoc_rule_real_starts_with_token;
	((ValadocRuleClass *) klass)->accept_token = (gboolean (*) (ValadocRule*, ValadocToken*, ValadocParserCallback*, ValadocRuleForward, GError**)) valadoc_rule_real_accept_token;
	((ValadocRuleClass *) klass)->would_accept_token = (gboolean (*) (ValadocRule*, ValadocToken*, GObject*)) valadoc_rule_real_would_accept_token;
	((ValadocRuleClass *) klass)->would_reduce = (gboolean (*) (ValadocRule*, ValadocToken*, GObject*)) valadoc_rule_real_would_reduce;
	((ValadocRuleClass *) klass)->to_string = (gchar* (*) (ValadocRule*, GObject*)) valadoc_rule_real_to_string;
	G_OBJECT_CLASS (klass)->get_property = _vala_valadoc_rule_get_property;
	G_OBJECT_CLASS (klass)->finalize = valadoc_rule_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), VALADOC_RULE_NAME_PROPERTY, valadoc_rule_properties[VALADOC_RULE_NAME_PROPERTY] = g_param_spec_string ("name", "name", "name", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
}

static void
valadoc_rule_instance_init (ValadocRule * self,
                            gpointer klass)
{
	self->priv = valadoc_rule_get_instance_private (self);
	self->priv->_name = NULL;
}

static void
valadoc_rule_finalize (GObject * obj)
{
	ValadocRule * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, VALADOC_TYPE_RULE, ValadocRule);
	_g_free0 (self->priv->_name);
	(self->priv->_start_action_target_destroy_notify == NULL) ? NULL : (self->priv->_start_action_target_destroy_notify (self->priv->_start_action_target), NULL);
	self->priv->_start_action = NULL;
	self->priv->_start_action_target = NULL;
	self->priv->_start_action_target_destroy_notify = NULL;
	(self->priv->_reduce_action_target_destroy_notify == NULL) ? NULL : (self->priv->_reduce_action_target_destroy_notify (self->priv->_reduce_action_target), NULL);
	self->priv->_reduce_action = NULL;
	self->priv->_reduce_action_target = NULL;
	self->priv->_reduce_action_target_destroy_notify = NULL;
	(self->priv->_skip_action_target_destroy_notify == NULL) ? NULL : (self->priv->_skip_action_target_destroy_notify (self->priv->_skip_action_target), NULL);
	self->priv->_skip_action = NULL;
	self->priv->_skip_action_target = NULL;
	self->priv->_skip_action_target_destroy_notify = NULL;
	G_OBJECT_CLASS (valadoc_rule_parent_class)->finalize (obj);
}

GType
valadoc_rule_get_type (void)
{
	static volatile gsize valadoc_rule_type_id__volatile = 0;
	if (g_once_init_enter (&valadoc_rule_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ValadocRuleClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) valadoc_rule_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValadocRule), 0, (GInstanceInitFunc) valadoc_rule_instance_init, NULL };
		GType valadoc_rule_type_id;
		valadoc_rule_type_id = g_type_register_static (G_TYPE_OBJECT, "ValadocRule", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		ValadocRule_private_offset = g_type_add_instance_private (valadoc_rule_type_id, sizeof (ValadocRulePrivate));
		g_once_init_leave (&valadoc_rule_type_id__volatile, valadoc_rule_type_id);
	}
	return valadoc_rule_type_id__volatile;
}

static void
_vala_valadoc_rule_get_property (GObject * object,
                                 guint property_id,
                                 GValue * value,
                                 GParamSpec * pspec)
{
	ValadocRule * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, VALADOC_TYPE_RULE, ValadocRule);
	switch (property_id) {
		case VALADOC_RULE_NAME_PROPERTY:
		g_value_set_string (value, valadoc_rule_get_name (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


/* commentscanner.c generated by valac, the Vala compiler
 * generated from commentscanner.vala, do not modify */

/* commentscanner.vala
 *
 * Copyright (C) 2008-2009 Florian Brosch, Didier Villevalois
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Didier 'Ptitjes Villevalois <ptitjes@free.fr>
 */

#include "valadoc.h"
#include <glib.h>

enum  {
	VALADOC_COMMENT_SCANNER_0_PROPERTY,
	VALADOC_COMMENT_SCANNER_NUM_PROPERTIES
};
static GParamSpec* valadoc_comment_scanner_properties[VALADOC_COMMENT_SCANNER_NUM_PROPERTIES];

struct _ValadocCommentScannerPrivate {
	gboolean in_line_start;
	gboolean past_star;
	gint start_column;
};

static gint ValadocCommentScanner_private_offset;
static gpointer valadoc_comment_scanner_parent_class = NULL;

static void valadoc_comment_scanner_real_reset (ValadocWikiScanner* base);
static gint valadoc_comment_scanner_real_get_line_start_column (ValadocWikiScanner* base);
static void valadoc_comment_scanner_real_accept (ValadocWikiScanner* base,
                                          gunichar c,
                                          GError** error);
static void valadoc_comment_scanner_finalize (GObject * obj);

static inline gpointer
valadoc_comment_scanner_get_instance_private (ValadocCommentScanner* self)
{
	return G_STRUCT_MEMBER_P (self, ValadocCommentScanner_private_offset);
}

ValadocCommentScanner*
valadoc_comment_scanner_construct (GType object_type,
                                   ValadocSettings* settings)
{
	ValadocCommentScanner * self = NULL;
	g_return_val_if_fail (settings != NULL, NULL);
	self = (ValadocCommentScanner*) valadoc_wiki_scanner_construct (object_type, settings);
	return self;
}

ValadocCommentScanner*
valadoc_comment_scanner_new (ValadocSettings* settings)
{
	return valadoc_comment_scanner_construct (VALADOC_TYPE_COMMENT_SCANNER, settings);
}

static void
valadoc_comment_scanner_real_reset (ValadocWikiScanner* base)
{
	ValadocCommentScanner * self;
	self = (ValadocCommentScanner*) base;
	VALADOC_WIKI_SCANNER_CLASS (valadoc_comment_scanner_parent_class)->reset (G_TYPE_CHECK_INSTANCE_CAST (self, VALADOC_TYPE_WIKI_SCANNER, ValadocWikiScanner));
	self->priv->in_line_start = TRUE;
	self->priv->past_star = FALSE;
	self->priv->start_column = 0;
}

static gint
valadoc_comment_scanner_real_get_line_start_column (ValadocWikiScanner* base)
{
	ValadocCommentScanner * self;
	gint result = 0;
	self = (ValadocCommentScanner*) base;
	result = self->priv->start_column;
	return result;
}

static void
valadoc_comment_scanner_real_accept (ValadocWikiScanner* base,
                                     gunichar c,
                                     GError** error)
{
	ValadocCommentScanner * self;
	GError* _inner_error0_ = NULL;
	self = (ValadocCommentScanner*) base;
	if (self->priv->in_line_start) {
		gint _tmp0_;
		_tmp0_ = self->priv->start_column;
		self->priv->start_column = _tmp0_ + 1;
		if (c == ((gunichar) '*')) {
			self->priv->past_star = TRUE;
		} else {
			if (self->priv->past_star) {
				self->priv->past_star = FALSE;
				if (c == ((gunichar) '\n')) {
					VALADOC_WIKI_SCANNER_CLASS (valadoc_comment_scanner_parent_class)->accept (G_TYPE_CHECK_INSTANCE_CAST (self, VALADOC_TYPE_WIKI_SCANNER, ValadocWikiScanner), c, &_inner_error0_);
					if (G_UNLIKELY (_inner_error0_ != NULL)) {
						if (_inner_error0_->domain == VALADOC_PARSER_ERROR) {
							g_propagate_error (error, _inner_error0_);
							return;
						} else {
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
							g_clear_error (&_inner_error0_);
							return;
						}
					}
					self->priv->in_line_start = TRUE;
					self->priv->start_column = 0;
				} else {
					self->priv->in_line_start = FALSE;
				}
			}
		}
	} else {
		VALADOC_WIKI_SCANNER_CLASS (valadoc_comment_scanner_parent_class)->accept (G_TYPE_CHECK_INSTANCE_CAST (self, VALADOC_TYPE_WIKI_SCANNER, ValadocWikiScanner), c, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == VALADOC_PARSER_ERROR) {
				g_propagate_error (error, _inner_error0_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return;
			}
		}
		if (c == ((gunichar) '\n')) {
			self->priv->in_line_start = TRUE;
			self->priv->start_column = 0;
		}
	}
}

static void
valadoc_comment_scanner_class_init (ValadocCommentScannerClass * klass,
                                    gpointer klass_data)
{
	valadoc_comment_scanner_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &ValadocCommentScanner_private_offset);
	((ValadocWikiScannerClass *) klass)->reset = (void (*) (ValadocWikiScanner*)) valadoc_comment_scanner_real_reset;
	((ValadocWikiScannerClass *) klass)->get_line_start_column = (gint (*) (ValadocWikiScanner*)) valadoc_comment_scanner_real_get_line_start_column;
	((ValadocWikiScannerClass *) klass)->accept = (void (*) (ValadocWikiScanner*, gunichar, GError**)) valadoc_comment_scanner_real_accept;
	G_OBJECT_CLASS (klass)->finalize = valadoc_comment_scanner_finalize;
}

static void
valadoc_comment_scanner_instance_init (ValadocCommentScanner * self,
                                       gpointer klass)
{
	self->priv = valadoc_comment_scanner_get_instance_private (self);
}

static void
valadoc_comment_scanner_finalize (GObject * obj)
{
	ValadocCommentScanner * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, VALADOC_TYPE_COMMENT_SCANNER, ValadocCommentScanner);
	G_OBJECT_CLASS (valadoc_comment_scanner_parent_class)->finalize (obj);
}

GType
valadoc_comment_scanner_get_type (void)
{
	static volatile gsize valadoc_comment_scanner_type_id__volatile = 0;
	if (g_once_init_enter (&valadoc_comment_scanner_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ValadocCommentScannerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) valadoc_comment_scanner_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValadocCommentScanner), 0, (GInstanceInitFunc) valadoc_comment_scanner_instance_init, NULL };
		GType valadoc_comment_scanner_type_id;
		valadoc_comment_scanner_type_id = g_type_register_static (VALADOC_TYPE_WIKI_SCANNER, "ValadocCommentScanner", &g_define_type_info, 0);
		ValadocCommentScanner_private_offset = g_type_add_instance_private (valadoc_comment_scanner_type_id, sizeof (ValadocCommentScannerPrivate));
		g_once_init_leave (&valadoc_comment_scanner_type_id__volatile, valadoc_comment_scanner_type_id);
	}
	return valadoc_comment_scanner_type_id__volatile;
}


/* gio-unix-2.0.vapi generated by vapigen, do not modify. */

[CCode (cprefix = "G", lower_case_cprefix = "g_")]
namespace GLib {
	[CCode (cheader_filename = "gio/gdesktopappinfo.h")]
	public class DesktopAppInfo : GLib.Object, GLib.AppInfo {
		[CCode (has_construct_function = false)]
		public DesktopAppInfo (string desktop_id);
		[CCode (has_construct_function = false)]
		public DesktopAppInfo.from_filename (string filename);
		[CCode (has_construct_function = false)]
		public DesktopAppInfo.from_keyfile (GLib.KeyFile key_file);
		public string get_action_name (string action_name);
		public bool get_boolean (string key);
		public unowned string get_categories ();
		public unowned string get_filename ();
		public unowned string get_generic_name ();
		public static GLib.List<GLib.DesktopAppInfo> get_implementations (string @interface);
		public bool get_is_hidden ();
		[CCode (array_length = false, array_null_terminated = true)]
		public unowned string[] get_keywords ();
		public string? get_locale_string (string key);
		public bool get_nodisplay ();
		public bool get_show_in (string desktop_env);
		public unowned string get_startup_wm_class ();
		public string get_string (string key);
		[CCode (array_length_type = "gsize")]
		public string[] get_string_list (string key);
		public bool has_key (string key);
		public void launch_action (string action_name, GLib.AppLaunchContext launch_context);
		public bool launch_uris_as_manager (GLib.List<string> uris, GLib.AppLaunchContext? launch_context, GLib.SpawnFlags spawn_flags, GLib.SpawnChildSetupFunc? user_setup = null, GLib.DesktopAppLaunchCallback? pid_callback = null) throws GLib.Error;
		public bool launch_uris_as_manager_with_fds (GLib.List<string> uris, GLib.AppLaunchContext? launch_context, GLib.SpawnFlags spawn_flags, GLib.SpawnChildSetupFunc? user_setup = null, GLib.DesktopAppLaunchCallback? pid_callback = null, int stdin_fd = -1, int stdout_fd = -1, int stderr_fd = -1) throws GLib.Error;
		[CCode (array_length = false, array_null_terminated = true)]
		public unowned string[] list_actions ();
		[CCode (array_length = false, array_null_terminated = true)]
		public static string**[] search (string search_string);
		public static void set_desktop_env (string desktop_env);
		public string filename { get; construct; }
	}
	[CCode (cheader_filename = "gio/gunixconnection.h")]
	public class UnixConnection : GLib.SocketConnection {
		[CCode (has_construct_function = false)]
		protected UnixConnection ();
		public GLib.Credentials receive_credentials (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async GLib.Credentials receive_credentials_async (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public int receive_fd (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public bool send_credentials (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool send_credentials_async (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public bool send_fd (int fd, GLib.Cancellable? cancellable = null) throws GLib.Error;
	}
	[CCode (cheader_filename = "gio/gunixcredentialsmessage.h")]
	public class UnixCredentialsMessage : GLib.SocketControlMessage {
		[CCode (has_construct_function = false, type = "GSocketControlMessage*")]
		public UnixCredentialsMessage ();
		public unowned GLib.Credentials get_credentials ();
		public static bool is_supported ();
		[CCode (has_construct_function = false, type = "GSocketControlMessage*")]
		public UnixCredentialsMessage.with_credentials (GLib.Credentials credentials);
		public GLib.Credentials credentials { get; construct; }
	}
	[CCode (cheader_filename = "gio/gunixfdmessage.h")]
	public class UnixFDMessage : GLib.SocketControlMessage {
		[CCode (has_construct_function = false, type = "GSocketControlMessage*")]
		public UnixFDMessage ();
		public bool append_fd (int fd) throws GLib.Error;
		public unowned GLib.UnixFDList get_fd_list ();
		public int[] steal_fds ();
		[CCode (has_construct_function = false, type = "GSocketControlMessage*")]
		public UnixFDMessage.with_fd_list (GLib.UnixFDList fd_list);
		public GLib.UnixFDList fd_list { get; construct; }
	}
	[CCode (cheader_filename = "gio/gunixinputstream.h")]
	public class UnixInputStream : GLib.InputStream, GLib.PollableInputStream, GLib.FileDescriptorBased {
		[CCode (has_construct_function = false, type = "GInputStream*")]
		public UnixInputStream (int fd, bool close_fd);
		public bool get_close_fd ();
		public void set_close_fd (bool close_fd);
		public bool close_fd { get; set; }
		public int fd { get; construct; }
	}
	[CCode (cheader_filename = "gio/gunixmounts.h", cname = "GUnixMountEntry", free_function = "g_unix_mount_free", lower_case_cprefix = "g_unix_mount_")]
	[Compact]
	public class UnixMountEntry {
		[CCode (cname = "g_unix_mount_at")]
		public UnixMountEntry (string mount_path, out uint64 time_read = null);
		public int compare (GLib.UnixMountEntry mount);
		[CCode (cname = "g_unix_mounts_for")]
		[Version (since = "2.52")]
		public static GLib.List<GLib.UnixMountEntry> @for (string file_path, out uint64 time_read = null);
		[CCode (cname = "g_unix_mounts_get")]
		public static GLib.List<GLib.UnixMountEntry> @get (out uint64 time_read = null);
		public unowned string get_device_path ();
		public unowned string get_fs_type ();
		public unowned string get_mount_path ();
		[Version (since = "2.58")]
		public unowned string get_options ();
		[Version (since = "2.60")]
		public unowned string get_root_path ();
		public bool guess_can_eject ();
		public GLib.Icon guess_icon ();
		public string guess_name ();
		public bool guess_should_display ();
		[Version (since = "2.34")]
		public GLib.Icon guess_symbolic_icon ();
		public bool is_readonly ();
		public bool is_system_internal ();
	}
	[CCode (cheader_filename = "gio/gunixmounts.h")]
	public class UnixMountMonitor : GLib.Object {
		[CCode (has_construct_function = false)]
		[Version (deprecated_since = "2.44", replacement = "UnixMountMonitor.get")]
		public UnixMountMonitor ();
		public static GLib.UnixMountMonitor @get ();
		public void set_rate_limit (int limit_msec);
		public virtual signal void mountpoints_changed ();
		public virtual signal void mounts_changed ();
	}
	[CCode (cheader_filename = "gio/gunixmounts.h")]
	[Compact]
	public class UnixMountMonitorClass {
	}
	[CCode (cheader_filename = "gio/gunixmounts.h")]
	[Compact]
	public class UnixMountPoint {
		public int compare (GLib.UnixMountPoint mount2);
		public unowned string get_device_path ();
		public unowned string get_fs_type ();
		public unowned string get_mount_path ();
		public unowned string get_options ();
		public bool guess_can_eject ();
		public GLib.Icon guess_icon ();
		public string guess_name ();
		public GLib.Icon guess_symbolic_icon ();
		public bool is_loopback ();
		public bool is_readonly ();
		public bool is_user_mountable ();
	}
	[CCode (cheader_filename = "gio/gunixoutputstream.h")]
	public class UnixOutputStream : GLib.OutputStream, GLib.PollableOutputStream, GLib.FileDescriptorBased {
		[CCode (has_construct_function = false, type = "GOutputStream*")]
		public UnixOutputStream (int fd, bool close_fd);
		public bool get_close_fd ();
		public void set_close_fd (bool close_fd);
		public bool close_fd { get; set; }
		public int fd { get; construct; }
	}
	[CCode (cheader_filename = "gio/gunixsocketaddress.h")]
	public class UnixSocketAddress : GLib.SocketAddress, GLib.SocketConnectable {
		[CCode (has_construct_function = false, type = "GSocketAddress*")]
		public UnixSocketAddress (string path);
		public static bool abstract_names_supported ();
		[CCode (cname = "g_unix_socket_address_new_abstract", has_construct_function = false, type = "GSocketAddress*")]
		public UnixSocketAddress.as_abstract (string path, int path_len);
		public GLib.UnixSocketAddressType get_address_type ();
		public bool get_is_abstract ();
		public unowned string get_path ();
		public size_t get_path_len ();
		[CCode (has_construct_function = false, type = "GSocketAddress*")]
		public UnixSocketAddress.with_type (string path, int path_len, GLib.UnixSocketAddressType type);
		[NoAccessorMethod]
		public bool @abstract { get; construct; }
		public GLib.UnixSocketAddressType address_type { get; construct; }
		public string path { get; construct; }
		[NoAccessorMethod]
		public GLib.ByteArray path_as_array { owned get; construct; }
	}
	[CCode (cheader_filename = "gio/gdesktopappinfo.h")]
	public interface DesktopAppInfoLookup : GLib.Object {
		public abstract GLib.AppInfo get_default_for_uri_scheme (string uri_scheme);
	}
	[CCode (cheader_filename = "gio/gfiledescriptorbased.h")]
	public interface FileDescriptorBased : GLib.Object {
		public abstract int get_fd ();
	}
	[CCode (cheader_filename = "gio/gdesktopappinfo.h")]
	public delegate void DesktopAppLaunchCallback (GLib.DesktopAppInfo appinfo, GLib.Pid pid);
	[CCode (cheader_filename = "gio/gdesktopappinfo.h")]
	public const string DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME;
	[CCode (cheader_filename = "gio/gunixmounts.h", cname = "g_unix_is_mount_path_system_internal")]
	public static bool is_mount_path_system_internal (string mount_path);
	[CCode (cheader_filename = "gio/gunixmounts.h", cname = "g_unix_is_system_device_path")]
	public static bool is_system_device_path (string device_path);
	[CCode (cheader_filename = "gio/gunixmounts.h", cname = "g_unix_is_system_fs_type")]
	public static bool is_system_fs_type (string fs_type);
	[CCode (cheader_filename = "gio/gunixmounts.h", cname = "g_unix_mount_points_changed_since")]
	public static bool mount_points_changed_since (uint64 time);
	[CCode (cheader_filename = "gio/gunixmounts.h", cname = "g_unix_mounts_changed_since")]
	public static bool mounts_changed_since (uint64 time);
}

/*
 * Generated by gdbus-codegen 2.41.1. DO NOT EDIT.
 *
 * The license of this code is the same as for the source it was derived from.
 */

#ifdef HAVE_CONFIG_H
#  include "config.h"
#endif

#include "gdbus-test-codegen-generated.h"

#include <string.h>
#ifdef G_OS_UNIX
#  include <gio/gunixfdlist.h>
#endif

typedef struct
{
  GDBusArgInfo parent_struct;
  gboolean use_gvariant;
} _ExtendedGDBusArgInfo;

typedef struct
{
  GDBusMethodInfo parent_struct;
  const gchar *signal_name;
  gboolean pass_fdlist;
} _ExtendedGDBusMethodInfo;

typedef struct
{
  GDBusSignalInfo parent_struct;
  const gchar *signal_name;
} _ExtendedGDBusSignalInfo;

typedef struct
{
  GDBusPropertyInfo parent_struct;
  const gchar *hyphen_name;
  gboolean use_gvariant;
} _ExtendedGDBusPropertyInfo;

typedef struct
{
  GDBusInterfaceInfo parent_struct;
  const gchar *hyphen_name;
} _ExtendedGDBusInterfaceInfo;

typedef struct
{
  const _ExtendedGDBusPropertyInfo *info;
  guint prop_id;
  GValue orig_value; /* the value before the change */
} ChangedProperty;

static void
_changed_property_free (ChangedProperty *data)
{
  g_value_unset (&data->orig_value);
  g_free (data);
}

static gboolean
_g_strv_equal0 (gchar **a, gchar **b)
{
  gboolean ret = FALSE;
  guint n;
  if (a == NULL && b == NULL)
    {
      ret = TRUE;
      goto out;
    }
  if (a == NULL || b == NULL)
    goto out;
  if (g_strv_length (a) != g_strv_length (b))
    goto out;
  for (n = 0; a[n] != NULL; n++)
    if (g_strcmp0 (a[n], b[n]) != 0)
      goto out;
  ret = TRUE;
out:
  return ret;
}

static gboolean
_g_variant_equal0 (GVariant *a, GVariant *b)
{
  gboolean ret = FALSE;
  if (a == NULL && b == NULL)
    {
      ret = TRUE;
      goto out;
    }
  if (a == NULL || b == NULL)
    goto out;
  ret = g_variant_equal (a, b);
out:
  return ret;
}

G_GNUC_UNUSED static gboolean
_g_value_equal (const GValue *a, const GValue *b)
{
  gboolean ret = FALSE;
  g_assert (G_VALUE_TYPE (a) == G_VALUE_TYPE (b));
  switch (G_VALUE_TYPE (a))
    {
      case G_TYPE_BOOLEAN:
        ret = (g_value_get_boolean (a) == g_value_get_boolean (b));
        break;
      case G_TYPE_UCHAR:
        ret = (g_value_get_uchar (a) == g_value_get_uchar (b));
        break;
      case G_TYPE_INT:
        ret = (g_value_get_int (a) == g_value_get_int (b));
        break;
      case G_TYPE_UINT:
        ret = (g_value_get_uint (a) == g_value_get_uint (b));
        break;
      case G_TYPE_INT64:
        ret = (g_value_get_int64 (a) == g_value_get_int64 (b));
        break;
      case G_TYPE_UINT64:
        ret = (g_value_get_uint64 (a) == g_value_get_uint64 (b));
        break;
      case G_TYPE_DOUBLE:
        {
          /* Avoid -Wfloat-equal warnings by doing a direct bit compare */
          gdouble da = g_value_get_double (a);
          gdouble db = g_value_get_double (b);
          ret = memcmp (&da, &db, sizeof (gdouble)) == 0;
        }
        break;
      case G_TYPE_STRING:
        ret = (g_strcmp0 (g_value_get_string (a), g_value_get_string (b)) == 0);
        break;
      case G_TYPE_VARIANT:
        ret = _g_variant_equal0 (g_value_get_variant (a), g_value_get_variant (b));
        break;
      default:
        if (G_VALUE_TYPE (a) == G_TYPE_STRV)
          ret = _g_strv_equal0 (g_value_get_boxed (a), g_value_get_boxed (b));
        else
          g_critical ("_g_value_equal() does not handle type %s", g_type_name (G_VALUE_TYPE (a)));
        break;
    }
  return ret;
}

/* ------------------------------------------------------------------------
 * Code for interface org.project.Bar
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenBar
 * @title: FooiGenBar
 * @short_description: Generated C code for the org.project.Bar D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.project.Bar ---- */

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_hello_world_IN_ARG_greeting =
{
  {
    -1,
    (gchar *) "greeting",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bar_method_info_hello_world_IN_ARG_pointers[] =
{
  &_foo_igen_bar_method_info_hello_world_IN_ARG_greeting,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_hello_world_OUT_ARG_response =
{
  {
    -1,
    (gchar *) "response",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bar_method_info_hello_world_OUT_ARG_pointers[] =
{
  &_foo_igen_bar_method_info_hello_world_OUT_ARG_response,
  NULL
};

static const GDBusAnnotationInfo _foo_igen_bar_method_hello_world_annotation_info_0 =
{
  -1,
  (gchar *) "Key3",
  (gchar *) "Value3",
  NULL
};

static const GDBusAnnotationInfo _foo_igen_bar_method_hello_world_annotation_info_1 =
{
  -1,
  (gchar *) "ExistingAnnotation",
  (gchar *) "blah",
  NULL
};

static const GDBusAnnotationInfo * const _foo_igen_bar_method_hello_world_annotation_info_pointers[] =
{
  &_foo_igen_bar_method_hello_world_annotation_info_0,
  &_foo_igen_bar_method_hello_world_annotation_info_1,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_igen_bar_method_info_hello_world =
{
  {
    -1,
    (gchar *) "HelloWorld",
    (GDBusArgInfo **) &_foo_igen_bar_method_info_hello_world_IN_ARG_pointers,
    (GDBusArgInfo **) &_foo_igen_bar_method_info_hello_world_OUT_ARG_pointers,
    (GDBusAnnotationInfo **) &_foo_igen_bar_method_hello_world_annotation_info_pointers
  },
  "handle-hello-world",
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_byte =
{
  {
    -1,
    (gchar *) "val_byte",
    (gchar *) "y",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_boolean =
{
  {
    -1,
    (gchar *) "val_boolean",
    (gchar *) "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_int16 =
{
  {
    -1,
    (gchar *) "val_int16",
    (gchar *) "n",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_uint16 =
{
  {
    -1,
    (gchar *) "val_uint16",
    (gchar *) "q",
    NULL
  },
  FALSE
};

static const GDBusAnnotationInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_arg_val_int32_annotation_info_0 =
{
  -1,
  (gchar *) "Key6",
  (gchar *) "Value6",
  NULL
};

static const GDBusAnnotationInfo * const _foo_igen_bar_method_info_test_primitive_types_IN_ARG_arg_val_int32_annotation_info_pointers[] =
{
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_arg_val_int32_annotation_info_0,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_int32 =
{
  {
    -1,
    (gchar *) "val_int32",
    (gchar *) "i",
    (GDBusAnnotationInfo **) &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_arg_val_int32_annotation_info_pointers
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_uint32 =
{
  {
    -1,
    (gchar *) "val_uint32",
    (gchar *) "u",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_int64 =
{
  {
    -1,
    (gchar *) "val_int64",
    (gchar *) "x",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_uint64 =
{
  {
    -1,
    (gchar *) "val_uint64",
    (gchar *) "t",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_double =
{
  {
    -1,
    (gchar *) "val_double",
    (gchar *) "d",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_string =
{
  {
    -1,
    (gchar *) "val_string",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_objpath =
{
  {
    -1,
    (gchar *) "val_objpath",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_signature =
{
  {
    -1,
    (gchar *) "val_signature",
    (gchar *) "g",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_bytestring =
{
  {
    -1,
    (gchar *) "val_bytestring",
    (gchar *) "ay",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bar_method_info_test_primitive_types_IN_ARG_pointers[] =
{
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_byte,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_boolean,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_int16,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_uint16,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_int32,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_uint32,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_int64,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_uint64,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_double,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_string,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_objpath,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_signature,
  &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_val_bytestring,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_byte =
{
  {
    -1,
    (gchar *) "ret_byte",
    (gchar *) "y",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_boolean =
{
  {
    -1,
    (gchar *) "ret_boolean",
    (gchar *) "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_int16 =
{
  {
    -1,
    (gchar *) "ret_int16",
    (gchar *) "n",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_uint16 =
{
  {
    -1,
    (gchar *) "ret_uint16",
    (gchar *) "q",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_int32 =
{
  {
    -1,
    (gchar *) "ret_int32",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const GDBusAnnotationInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_arg_ret_uint32_annotation_info_0 =
{
  -1,
  (gchar *) "Key7",
  (gchar *) "Value7",
  NULL
};

static const GDBusAnnotationInfo * const _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_arg_ret_uint32_annotation_info_pointers[] =
{
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_arg_ret_uint32_annotation_info_0,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_uint32 =
{
  {
    -1,
    (gchar *) "ret_uint32",
    (gchar *) "u",
    (GDBusAnnotationInfo **) &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_arg_ret_uint32_annotation_info_pointers
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_int64 =
{
  {
    -1,
    (gchar *) "ret_int64",
    (gchar *) "x",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_uint64 =
{
  {
    -1,
    (gchar *) "ret_uint64",
    (gchar *) "t",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_double =
{
  {
    -1,
    (gchar *) "ret_double",
    (gchar *) "d",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_string =
{
  {
    -1,
    (gchar *) "ret_string",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_objpath =
{
  {
    -1,
    (gchar *) "ret_objpath",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_signature =
{
  {
    -1,
    (gchar *) "ret_signature",
    (gchar *) "g",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_bytestring =
{
  {
    -1,
    (gchar *) "ret_bytestring",
    (gchar *) "ay",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bar_method_info_test_primitive_types_OUT_ARG_pointers[] =
{
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_byte,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_boolean,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_int16,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_uint16,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_int32,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_uint32,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_int64,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_uint64,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_double,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_string,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_objpath,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_signature,
  &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_ret_bytestring,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_igen_bar_method_info_test_primitive_types =
{
  {
    -1,
    (gchar *) "TestPrimitiveTypes",
    (GDBusArgInfo **) &_foo_igen_bar_method_info_test_primitive_types_IN_ARG_pointers,
    (GDBusArgInfo **) &_foo_igen_bar_method_info_test_primitive_types_OUT_ARG_pointers,
    NULL
  },
  "handle-test-primitive-types",
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_dict_s_to_s =
{
  {
    -1,
    (gchar *) "dict_s_to_s",
    (gchar *) "a{ss}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_dict_s_to_pairs =
{
  {
    -1,
    (gchar *) "dict_s_to_pairs",
    (gchar *) "a{s(ii)}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_a_struct =
{
  {
    -1,
    (gchar *) "a_struct",
    (gchar *) "(iss)",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_array_of_strings =
{
  {
    -1,
    (gchar *) "array_of_strings",
    (gchar *) "as",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_array_of_objpaths =
{
  {
    -1,
    (gchar *) "array_of_objpaths",
    (gchar *) "ao",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_array_of_signatures =
{
  {
    -1,
    (gchar *) "array_of_signatures",
    (gchar *) "ag",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_array_of_bytestrings =
{
  {
    -1,
    (gchar *) "array_of_bytestrings",
    (gchar *) "aay",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_pointers[] =
{
  &_foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_dict_s_to_s,
  &_foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_dict_s_to_pairs,
  &_foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_a_struct,
  &_foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_array_of_strings,
  &_foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_array_of_objpaths,
  &_foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_array_of_signatures,
  &_foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_array_of_bytestrings,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_test_non_primitive_types_OUT_ARG_result =
{
  {
    -1,
    (gchar *) "result",
    (gchar *) "ay",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bar_method_info_test_non_primitive_types_OUT_ARG_pointers[] =
{
  &_foo_igen_bar_method_info_test_non_primitive_types_OUT_ARG_result,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_igen_bar_method_info_test_non_primitive_types =
{
  {
    -1,
    (gchar *) "TestNonPrimitiveTypes",
    (GDBusArgInfo **) &_foo_igen_bar_method_info_test_non_primitive_types_IN_ARG_pointers,
    (GDBusArgInfo **) &_foo_igen_bar_method_info_test_non_primitive_types_OUT_ARG_pointers,
    NULL
  },
  "handle-test-non-primitive-types",
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_method_info_request_signal_emission_IN_ARG_which_one =
{
  {
    -1,
    (gchar *) "which_one",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bar_method_info_request_signal_emission_IN_ARG_pointers[] =
{
  &_foo_igen_bar_method_info_request_signal_emission_IN_ARG_which_one,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_igen_bar_method_info_request_signal_emission =
{
  {
    -1,
    (gchar *) "RequestSignalEmission",
    (GDBusArgInfo **) &_foo_igen_bar_method_info_request_signal_emission_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-request-signal-emission",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_bar_method_info_request_multi_property_mods =
{
  {
    -1,
    (gchar *) "RequestMultiPropertyMods",
    NULL,
    NULL,
    NULL
  },
  "handle-request-multi-property-mods",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_bar_method_info_unimplemented_method =
{
  {
    -1,
    (gchar *) "UnimplementedMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-unimplemented-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_bar_method_info_property_cancellation =
{
  {
    -1,
    (gchar *) "PropertyCancellation",
    NULL,
    NULL,
    NULL
  },
  "handle-property-cancellation",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_bar_method_info_pointers[] =
{
  &_foo_igen_bar_method_info_hello_world,
  &_foo_igen_bar_method_info_test_primitive_types,
  &_foo_igen_bar_method_info_test_non_primitive_types,
  &_foo_igen_bar_method_info_request_signal_emission,
  &_foo_igen_bar_method_info_request_multi_property_mods,
  &_foo_igen_bar_method_info_unimplemented_method,
  &_foo_igen_bar_method_info_property_cancellation,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_signal_info_test_signal_ARG_val_int32 =
{
  {
    -1,
    (gchar *) "val_int32",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const GDBusAnnotationInfo _foo_igen_bar_signal_info_test_signal_ARG_arg_array_of_strings_annotation_info_0 =
{
  -1,
  (gchar *) "Key8",
  (gchar *) "Value8",
  NULL
};

static const GDBusAnnotationInfo * const _foo_igen_bar_signal_info_test_signal_ARG_arg_array_of_strings_annotation_info_pointers[] =
{
  &_foo_igen_bar_signal_info_test_signal_ARG_arg_array_of_strings_annotation_info_0,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_signal_info_test_signal_ARG_array_of_strings =
{
  {
    -1,
    (gchar *) "array_of_strings",
    (gchar *) "as",
    (GDBusAnnotationInfo **) &_foo_igen_bar_signal_info_test_signal_ARG_arg_array_of_strings_annotation_info_pointers
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_signal_info_test_signal_ARG_array_of_bytestrings =
{
  {
    -1,
    (gchar *) "array_of_bytestrings",
    (gchar *) "aay",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_signal_info_test_signal_ARG_dict_s_to_pairs =
{
  {
    -1,
    (gchar *) "dict_s_to_pairs",
    (gchar *) "a{s(ii)}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bar_signal_info_test_signal_ARG_pointers[] =
{
  &_foo_igen_bar_signal_info_test_signal_ARG_val_int32,
  &_foo_igen_bar_signal_info_test_signal_ARG_array_of_strings,
  &_foo_igen_bar_signal_info_test_signal_ARG_array_of_bytestrings,
  &_foo_igen_bar_signal_info_test_signal_ARG_dict_s_to_pairs,
  NULL
};

static const GDBusAnnotationInfo _foo_igen_bar_signal_test_signal_annotation_info_0 =
{
  -1,
  (gchar *) "Key4",
  (gchar *) "Value4",
  NULL
};

static const GDBusAnnotationInfo * const _foo_igen_bar_signal_test_signal_annotation_info_pointers[] =
{
  &_foo_igen_bar_signal_test_signal_annotation_info_0,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_igen_bar_signal_info_test_signal =
{
  {
    -1,
    (gchar *) "TestSignal",
    (GDBusArgInfo **) &_foo_igen_bar_signal_info_test_signal_ARG_pointers,
    (GDBusAnnotationInfo **) &_foo_igen_bar_signal_test_signal_annotation_info_pointers
  },
  "test-signal"
};

static const _ExtendedGDBusArgInfo _foo_igen_bar_signal_info_another_signal_ARG_word =
{
  {
    -1,
    (gchar *) "word",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bar_signal_info_another_signal_ARG_pointers[] =
{
  &_foo_igen_bar_signal_info_another_signal_ARG_word,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_igen_bar_signal_info_another_signal =
{
  {
    -1,
    (gchar *) "AnotherSignal",
    (GDBusArgInfo **) &_foo_igen_bar_signal_info_another_signal_ARG_pointers,
    NULL
  },
  "another-signal"
};

static const _ExtendedGDBusSignalInfo * const _foo_igen_bar_signal_info_pointers[] =
{
  &_foo_igen_bar_signal_info_test_signal,
  &_foo_igen_bar_signal_info_another_signal,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_y =
{
  {
    -1,
    (gchar *) "y",
    (gchar *) "y",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "y",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_b =
{
  {
    -1,
    (gchar *) "b",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "b",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_n =
{
  {
    -1,
    (gchar *) "n",
    (gchar *) "n",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "n",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_q =
{
  {
    -1,
    (gchar *) "q",
    (gchar *) "q",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "q",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_i =
{
  {
    -1,
    (gchar *) "i",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "i",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_u =
{
  {
    -1,
    (gchar *) "u",
    (gchar *) "u",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "u",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_x =
{
  {
    -1,
    (gchar *) "x",
    (gchar *) "x",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "x",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_t =
{
  {
    -1,
    (gchar *) "t",
    (gchar *) "t",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "t",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_d =
{
  {
    -1,
    (gchar *) "d",
    (gchar *) "d",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "d",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_s =
{
  {
    -1,
    (gchar *) "s",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "s",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_o =
{
  {
    -1,
    (gchar *) "o",
    (gchar *) "o",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "o",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_g =
{
  {
    -1,
    (gchar *) "g",
    (gchar *) "g",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "g",
  FALSE
};

static const GDBusAnnotationInfo _foo_igen_bar_property_ay_annotation_info_0 =
{
  -1,
  (gchar *) "Key5",
  (gchar *) "Value5",
  NULL
};

static const GDBusAnnotationInfo * const _foo_igen_bar_property_ay_annotation_info_pointers[] =
{
  &_foo_igen_bar_property_ay_annotation_info_0,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_ay =
{
  {
    -1,
    (gchar *) "ay",
    (gchar *) "ay",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    (GDBusAnnotationInfo **) &_foo_igen_bar_property_ay_annotation_info_pointers
  },
  "ay",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_as =
{
  {
    -1,
    (gchar *) "as",
    (gchar *) "as",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "as",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_aay =
{
  {
    -1,
    (gchar *) "aay",
    (gchar *) "aay",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "aay",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_ao =
{
  {
    -1,
    (gchar *) "ao",
    (gchar *) "ao",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "ao",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_ag =
{
  {
    -1,
    (gchar *) "ag",
    (gchar *) "ag",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "ag",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_finally_normal_name =
{
  {
    -1,
    (gchar *) "FinallyNormalName",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "finally-normal-name",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_readonly_property =
{
  {
    -1,
    (gchar *) "ReadonlyProperty",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "readonly-property",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_writeonly_property =
{
  {
    -1,
    (gchar *) "WriteonlyProperty",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "writeonly-property",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_unset_i =
{
  {
    -1,
    (gchar *) "unset_i",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-i",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_unset_d =
{
  {
    -1,
    (gchar *) "unset_d",
    (gchar *) "d",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-d",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_unset_s =
{
  {
    -1,
    (gchar *) "unset_s",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-s",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_unset_o =
{
  {
    -1,
    (gchar *) "unset_o",
    (gchar *) "o",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-o",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_unset_g =
{
  {
    -1,
    (gchar *) "unset_g",
    (gchar *) "g",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-g",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_unset_ay =
{
  {
    -1,
    (gchar *) "unset_ay",
    (gchar *) "ay",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-ay",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_unset_as =
{
  {
    -1,
    (gchar *) "unset_as",
    (gchar *) "as",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-as",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_unset_ao =
{
  {
    -1,
    (gchar *) "unset_ao",
    (gchar *) "ao",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-ao",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_unset_ag =
{
  {
    -1,
    (gchar *) "unset_ag",
    (gchar *) "ag",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-ag",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bar_property_info_unset_struct =
{
  {
    -1,
    (gchar *) "unset_struct",
    (gchar *) "(idsogayasaoag)",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-struct",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _foo_igen_bar_property_info_pointers[] =
{
  &_foo_igen_bar_property_info_y,
  &_foo_igen_bar_property_info_b,
  &_foo_igen_bar_property_info_n,
  &_foo_igen_bar_property_info_q,
  &_foo_igen_bar_property_info_i,
  &_foo_igen_bar_property_info_u,
  &_foo_igen_bar_property_info_x,
  &_foo_igen_bar_property_info_t,
  &_foo_igen_bar_property_info_d,
  &_foo_igen_bar_property_info_s,
  &_foo_igen_bar_property_info_o,
  &_foo_igen_bar_property_info_g,
  &_foo_igen_bar_property_info_ay,
  &_foo_igen_bar_property_info_as,
  &_foo_igen_bar_property_info_aay,
  &_foo_igen_bar_property_info_ao,
  &_foo_igen_bar_property_info_ag,
  &_foo_igen_bar_property_info_finally_normal_name,
  &_foo_igen_bar_property_info_readonly_property,
  &_foo_igen_bar_property_info_writeonly_property,
  &_foo_igen_bar_property_info_unset_i,
  &_foo_igen_bar_property_info_unset_d,
  &_foo_igen_bar_property_info_unset_s,
  &_foo_igen_bar_property_info_unset_o,
  &_foo_igen_bar_property_info_unset_g,
  &_foo_igen_bar_property_info_unset_ay,
  &_foo_igen_bar_property_info_unset_as,
  &_foo_igen_bar_property_info_unset_ao,
  &_foo_igen_bar_property_info_unset_ag,
  &_foo_igen_bar_property_info_unset_struct,
  NULL
};

static const GDBusAnnotationInfo _foo_igen_bar_annotation_info_0 =
{
  -1,
  (gchar *) "Key1",
  (gchar *) "Value1",
  NULL
};

static const GDBusAnnotationInfo * const _foo_igen_bar_annotation_info_pointers[] =
{
  &_foo_igen_bar_annotation_info_0,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_bar_interface_info =
{
  {
    -1,
    (gchar *) "org.project.Bar",
    (GDBusMethodInfo **) &_foo_igen_bar_method_info_pointers,
    (GDBusSignalInfo **) &_foo_igen_bar_signal_info_pointers,
    (GDBusPropertyInfo **) &_foo_igen_bar_property_info_pointers,
    (GDBusAnnotationInfo **) &_foo_igen_bar_annotation_info_pointers
  },
  "bar",
};


/**
 * foo_igen_bar_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_bar_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_bar_interface_info.parent_struct;
}

/**
 * foo_igen_bar_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenBar interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_bar_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "y");
  g_object_class_override_property (klass, property_id_begin++, "b");
  g_object_class_override_property (klass, property_id_begin++, "n");
  g_object_class_override_property (klass, property_id_begin++, "q");
  g_object_class_override_property (klass, property_id_begin++, "i");
  g_object_class_override_property (klass, property_id_begin++, "u");
  g_object_class_override_property (klass, property_id_begin++, "x");
  g_object_class_override_property (klass, property_id_begin++, "t");
  g_object_class_override_property (klass, property_id_begin++, "d");
  g_object_class_override_property (klass, property_id_begin++, "s");
  g_object_class_override_property (klass, property_id_begin++, "o");
  g_object_class_override_property (klass, property_id_begin++, "g");
  g_object_class_override_property (klass, property_id_begin++, "ay");
  g_object_class_override_property (klass, property_id_begin++, "as");
  g_object_class_override_property (klass, property_id_begin++, "aay");
  g_object_class_override_property (klass, property_id_begin++, "ao");
  g_object_class_override_property (klass, property_id_begin++, "ag");
  g_object_class_override_property (klass, property_id_begin++, "finally-normal-name");
  g_object_class_override_property (klass, property_id_begin++, "readonly-property");
  g_object_class_override_property (klass, property_id_begin++, "writeonly-property");
  g_object_class_override_property (klass, property_id_begin++, "unset-i");
  g_object_class_override_property (klass, property_id_begin++, "unset-d");
  g_object_class_override_property (klass, property_id_begin++, "unset-s");
  g_object_class_override_property (klass, property_id_begin++, "unset-o");
  g_object_class_override_property (klass, property_id_begin++, "unset-g");
  g_object_class_override_property (klass, property_id_begin++, "unset-ay");
  g_object_class_override_property (klass, property_id_begin++, "unset-as");
  g_object_class_override_property (klass, property_id_begin++, "unset-ao");
  g_object_class_override_property (klass, property_id_begin++, "unset-ag");
  g_object_class_override_property (klass, property_id_begin++, "unset-struct");
  return property_id_begin - 1;
}



/**
 * FooiGenBar:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link>.
 */

/**
 * FooiGenBarIface:
 * @parent_iface: The parent interface.
 * @handle_hello_world: Handler for the #FooiGenBar::handle-hello-world signal.
 * @handle_property_cancellation: Handler for the #FooiGenBar::handle-property-cancellation signal.
 * @handle_request_multi_property_mods: Handler for the #FooiGenBar::handle-request-multi-property-mods signal.
 * @handle_request_signal_emission: Handler for the #FooiGenBar::handle-request-signal-emission signal.
 * @handle_test_non_primitive_types: Handler for the #FooiGenBar::handle-test-non-primitive-types signal.
 * @handle_test_primitive_types: Handler for the #FooiGenBar::handle-test-primitive-types signal.
 * @handle_unimplemented_method: Handler for the #FooiGenBar::handle-unimplemented-method signal.
 * @get_aay: Getter for the #FooiGenBar:aay property.
 * @get_ag: Getter for the #FooiGenBar:ag property.
 * @get_ao: Getter for the #FooiGenBar:ao property.
 * @get_as: Getter for the #FooiGenBar:as property.
 * @get_ay: Getter for the #FooiGenBar:ay property.
 * @get_b: Getter for the #FooiGenBar:b property.
 * @get_d: Getter for the #FooiGenBar:d property.
 * @get_finally_normal_name: Getter for the #FooiGenBar:finally-normal-name property.
 * @get_g: Getter for the #FooiGenBar:g property.
 * @get_i: Getter for the #FooiGenBar:i property.
 * @get_n: Getter for the #FooiGenBar:n property.
 * @get_o: Getter for the #FooiGenBar:o property.
 * @get_q: Getter for the #FooiGenBar:q property.
 * @get_readonly_property: Getter for the #FooiGenBar:readonly-property property.
 * @get_s: Getter for the #FooiGenBar:s property.
 * @get_t: Getter for the #FooiGenBar:t property.
 * @get_u: Getter for the #FooiGenBar:u property.
 * @get_unset_ag: Getter for the #FooiGenBar:unset-ag property.
 * @get_unset_ao: Getter for the #FooiGenBar:unset-ao property.
 * @get_unset_as: Getter for the #FooiGenBar:unset-as property.
 * @get_unset_ay: Getter for the #FooiGenBar:unset-ay property.
 * @get_unset_d: Getter for the #FooiGenBar:unset-d property.
 * @get_unset_g: Getter for the #FooiGenBar:unset-g property.
 * @get_unset_i: Getter for the #FooiGenBar:unset-i property.
 * @get_unset_o: Getter for the #FooiGenBar:unset-o property.
 * @get_unset_s: Getter for the #FooiGenBar:unset-s property.
 * @get_unset_struct: Getter for the #FooiGenBar:unset-struct property.
 * @get_writeonly_property: Getter for the #FooiGenBar:writeonly-property property.
 * @get_x: Getter for the #FooiGenBar:x property.
 * @get_y: Getter for the #FooiGenBar:y property.
 * @another_signal: Handler for the #FooiGenBar::another-signal signal.
 * @test_signal: Handler for the #FooiGenBar::test-signal signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link>.
 */

typedef FooiGenBarIface FooiGenBarInterface;
G_DEFINE_INTERFACE (FooiGenBar, foo_igen_bar, G_TYPE_OBJECT);

static void
foo_igen_bar_default_init (FooiGenBarIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenBar::handle-hello-world:
   * @object: A #FooiGenBar.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_greeting: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar.HelloWorld">HelloWorld()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_bar_complete_hello_world() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-hello-world",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBarIface, handle_hello_world),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * FooiGenBar::handle-test-primitive-types:
   * @object: A #FooiGenBar.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_val_byte: Argument passed by remote caller.
   * @arg_val_boolean: Argument passed by remote caller.
   * @arg_val_int16: Argument passed by remote caller.
   * @arg_val_uint16: Argument passed by remote caller.
   * @arg_val_int32: Argument passed by remote caller.
   * @arg_val_uint32: Argument passed by remote caller.
   * @arg_val_int64: Argument passed by remote caller.
   * @arg_val_uint64: Argument passed by remote caller.
   * @arg_val_double: Argument passed by remote caller.
   * @arg_val_string: Argument passed by remote caller.
   * @arg_val_objpath: Argument passed by remote caller.
   * @arg_val_signature: Argument passed by remote caller.
   * @arg_val_bytestring: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar.TestPrimitiveTypes">TestPrimitiveTypes()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_bar_complete_test_primitive_types() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-test-primitive-types",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBarIface, handle_test_primitive_types),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    14,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_UCHAR, G_TYPE_BOOLEAN, G_TYPE_INT, G_TYPE_UINT, G_TYPE_INT, G_TYPE_UINT, G_TYPE_INT64, G_TYPE_UINT64, G_TYPE_DOUBLE, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);

  /**
   * FooiGenBar::handle-test-non-primitive-types:
   * @object: A #FooiGenBar.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_dict_s_to_s: Argument passed by remote caller.
   * @arg_dict_s_to_pairs: Argument passed by remote caller.
   * @arg_a_struct: Argument passed by remote caller.
   * @arg_array_of_strings: Argument passed by remote caller.
   * @arg_array_of_objpaths: Argument passed by remote caller.
   * @arg_array_of_signatures: Argument passed by remote caller.
   * @arg_array_of_bytestrings: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar.TestNonPrimitiveTypes">TestNonPrimitiveTypes()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_bar_complete_test_non_primitive_types() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-test-non-primitive-types",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBarIface, handle_test_non_primitive_types),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    8,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT, G_TYPE_VARIANT, G_TYPE_VARIANT, G_TYPE_STRV, G_TYPE_STRV, G_TYPE_VARIANT, G_TYPE_STRV);

  /**
   * FooiGenBar::handle-request-signal-emission:
   * @object: A #FooiGenBar.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_which_one: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar.RequestSignalEmission">RequestSignalEmission()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_bar_complete_request_signal_emission() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-request-signal-emission",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBarIface, handle_request_signal_emission),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_INT);

  /**
   * FooiGenBar::handle-request-multi-property-mods:
   * @object: A #FooiGenBar.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar.RequestMultiPropertyMods">RequestMultiPropertyMods()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_bar_complete_request_multi_property_mods() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-request-multi-property-mods",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBarIface, handle_request_multi_property_mods),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooiGenBar::handle-unimplemented-method:
   * @object: A #FooiGenBar.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar.UnimplementedMethod">UnimplementedMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_bar_complete_unimplemented_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-unimplemented-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBarIface, handle_unimplemented_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooiGenBar::handle-property-cancellation:
   * @object: A #FooiGenBar.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar.PropertyCancellation">PropertyCancellation()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_bar_complete_property_cancellation() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-property-cancellation",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBarIface, handle_property_cancellation),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooiGenBar::test-signal:
   * @object: A #FooiGenBar.
   * @arg_val_int32: Argument.
   * @arg_array_of_strings: Argument.
   * @arg_array_of_bytestrings: Argument.
   * @arg_dict_s_to_pairs: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-project-Bar.TestSignal">"TestSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("test-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBarIface, test_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    4, G_TYPE_INT, G_TYPE_STRV, G_TYPE_STRV, G_TYPE_VARIANT);

  /**
   * FooiGenBar::another-signal:
   * @object: A #FooiGenBar.
   * @arg_word: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-project-Bar.AnotherSignal">"AnotherSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("another-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBarIface, another_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  /* GObject properties for D-Bus properties: */
  /**
   * FooiGenBar:y:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.y">"y"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_uchar ("y", "y", "y", 0, 255, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:b:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.b">"b"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("b", "b", "b", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:n:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.n">"n"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("n", "n", "n", G_MININT16, G_MAXINT16, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:q:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.q">"q"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_uint ("q", "q", "q", 0, G_MAXUINT16, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:i:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.i">"i"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("i", "i", "i", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:u:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.u">"u"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_uint ("u", "u", "u", 0, G_MAXUINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:x:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.x">"x"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int64 ("x", "x", "x", G_MININT64, G_MAXINT64, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:t:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.t">"t"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_uint64 ("t", "t", "t", 0, G_MAXUINT64, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:d:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.d">"d"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_double ("d", "d", "d", -G_MAXDOUBLE, G_MAXDOUBLE, 0.0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:s:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.s">"s"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("s", "s", "s", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:o:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.o">"o"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("o", "o", "o", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:g:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.g">"g"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("g", "g", "g", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:ay:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.ay">"ay"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("ay", "ay", "ay", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:as:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.as">"as"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boxed ("as", "as", "as", G_TYPE_STRV, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:aay:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.aay">"aay"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boxed ("aay", "aay", "aay", G_TYPE_STRV, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:ao:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.ao">"ao"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boxed ("ao", "ao", "ao", G_TYPE_STRV, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:ag:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.ag">"ag"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("ag", "ag", "ag", G_VARIANT_TYPE ("ag"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:finally-normal-name:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.FinallyNormalName">"FinallyNormalName"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("finally-normal-name", "FinallyNormalName", "FinallyNormalName", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:readonly-property:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.ReadonlyProperty">"ReadonlyProperty"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("readonly-property", "ReadonlyProperty", "ReadonlyProperty", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:writeonly-property:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.WriteonlyProperty">"WriteonlyProperty"</link>.
   *
   * Since the D-Bus property for this #GObject property is writable but not readable, it is meaningful to write to it on both the client- and service-side. It is only meaningful, however, to read from it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("writeonly-property", "WriteonlyProperty", "WriteonlyProperty", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:unset-i:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_i">"unset_i"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("unset-i", "unset_i", "unset_i", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:unset-d:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_d">"unset_d"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_double ("unset-d", "unset_d", "unset_d", -G_MAXDOUBLE, G_MAXDOUBLE, 0.0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:unset-s:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_s">"unset_s"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("unset-s", "unset_s", "unset_s", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:unset-o:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_o">"unset_o"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("unset-o", "unset_o", "unset_o", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:unset-g:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_g">"unset_g"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("unset-g", "unset_g", "unset_g", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:unset-ay:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_ay">"unset_ay"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("unset-ay", "unset_ay", "unset_ay", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:unset-as:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_as">"unset_as"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boxed ("unset-as", "unset_as", "unset_as", G_TYPE_STRV, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:unset-ao:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_ao">"unset_ao"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boxed ("unset-ao", "unset_ao", "unset_ao", G_TYPE_STRV, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:unset-ag:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_ag">"unset_ag"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("unset-ag", "unset_ag", "unset_ag", G_VARIANT_TYPE ("ag"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBar:unset-struct:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_struct">"unset_struct"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("unset-struct", "unset_struct", "unset_struct", G_VARIANT_TYPE ("(idsogayasaoag)"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * foo_igen_bar_get_y: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.y">"y"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
guchar 
foo_igen_bar_get_y (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_y (object);
}

/**
 * foo_igen_bar_set_y: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.y">"y"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_y (FooiGenBar *object, guchar value)
{
  g_object_set (G_OBJECT (object), "y", value, NULL);
}

/**
 * foo_igen_bar_get_b: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.b">"b"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
foo_igen_bar_get_b (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_b (object);
}

/**
 * foo_igen_bar_set_b: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.b">"b"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_b (FooiGenBar *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "b", value, NULL);
}

/**
 * foo_igen_bar_get_n: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.n">"n"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint16 
foo_igen_bar_get_n (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_n (object);
}

/**
 * foo_igen_bar_set_n: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.n">"n"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_n (FooiGenBar *object, gint16 value)
{
  g_object_set (G_OBJECT (object), "n", value, NULL);
}

/**
 * foo_igen_bar_get_q: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.q">"q"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
guint16 
foo_igen_bar_get_q (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_q (object);
}

/**
 * foo_igen_bar_set_q: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.q">"q"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_q (FooiGenBar *object, guint16 value)
{
  g_object_set (G_OBJECT (object), "q", value, NULL);
}

/**
 * foo_igen_bar_get_i: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.i">"i"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
foo_igen_bar_get_i (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_i (object);
}

/**
 * foo_igen_bar_set_i: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.i">"i"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_i (FooiGenBar *object, gint value)
{
  g_object_set (G_OBJECT (object), "i", value, NULL);
}

/**
 * foo_igen_bar_get_u: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.u">"u"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
guint 
foo_igen_bar_get_u (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_u (object);
}

/**
 * foo_igen_bar_set_u: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.u">"u"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_u (FooiGenBar *object, guint value)
{
  g_object_set (G_OBJECT (object), "u", value, NULL);
}

/**
 * foo_igen_bar_get_x: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.x">"x"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint64 
foo_igen_bar_get_x (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_x (object);
}

/**
 * foo_igen_bar_set_x: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.x">"x"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_x (FooiGenBar *object, gint64 value)
{
  g_object_set (G_OBJECT (object), "x", value, NULL);
}

/**
 * foo_igen_bar_get_t: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.t">"t"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
guint64 
foo_igen_bar_get_t (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_t (object);
}

/**
 * foo_igen_bar_set_t: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.t">"t"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_t (FooiGenBar *object, guint64 value)
{
  g_object_set (G_OBJECT (object), "t", value, NULL);
}

/**
 * foo_igen_bar_get_d: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.d">"d"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gdouble 
foo_igen_bar_get_d (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_d (object);
}

/**
 * foo_igen_bar_set_d: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.d">"d"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_d (FooiGenBar *object, gdouble value)
{
  g_object_set (G_OBJECT (object), "d", value, NULL);
}

/**
 * foo_igen_bar_get_s: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.s">"s"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_s() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_bar_get_s (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_s (object);
}

/**
 * foo_igen_bar_dup_s: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.s">"s"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_bar_dup_s (FooiGenBar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "s", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_s: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.s">"s"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_s (FooiGenBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "s", value, NULL);
}

/**
 * foo_igen_bar_get_o: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.o">"o"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_o() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_bar_get_o (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_o (object);
}

/**
 * foo_igen_bar_dup_o: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.o">"o"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_bar_dup_o (FooiGenBar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "o", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_o: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.o">"o"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_o (FooiGenBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "o", value, NULL);
}

/**
 * foo_igen_bar_get_g: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.g">"g"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_g() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_bar_get_g (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_g (object);
}

/**
 * foo_igen_bar_dup_g: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.g">"g"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_bar_dup_g (FooiGenBar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "g", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_g: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.g">"g"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_g (FooiGenBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "g", value, NULL);
}

/**
 * foo_igen_bar_get_ay: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.ay">"ay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_ay() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_bar_get_ay (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_ay (object);
}

/**
 * foo_igen_bar_dup_ay: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.ay">"ay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_bar_dup_ay (FooiGenBar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "ay", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_ay: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.ay">"ay"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_ay (FooiGenBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "ay", value, NULL);
}

/**
 * foo_igen_bar_get_as: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.as">"as"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_as() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *const *
foo_igen_bar_get_as (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_as (object);
}

/**
 * foo_igen_bar_dup_as: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.as">"as"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_strfreev().
 */
gchar **
foo_igen_bar_dup_as (FooiGenBar *object)
{
  gchar **value;
  g_object_get (G_OBJECT (object), "as", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_as: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.as">"as"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_as (FooiGenBar *object, const gchar *const *value)
{
  g_object_set (G_OBJECT (object), "as", value, NULL);
}

/**
 * foo_igen_bar_get_aay: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.aay">"aay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_aay() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *const *
foo_igen_bar_get_aay (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_aay (object);
}

/**
 * foo_igen_bar_dup_aay: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.aay">"aay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_strfreev().
 */
gchar **
foo_igen_bar_dup_aay (FooiGenBar *object)
{
  gchar **value;
  g_object_get (G_OBJECT (object), "aay", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_aay: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.aay">"aay"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_aay (FooiGenBar *object, const gchar *const *value)
{
  g_object_set (G_OBJECT (object), "aay", value, NULL);
}

/**
 * foo_igen_bar_get_ao: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.ao">"ao"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_ao() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *const *
foo_igen_bar_get_ao (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_ao (object);
}

/**
 * foo_igen_bar_dup_ao: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.ao">"ao"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_strfreev().
 */
gchar **
foo_igen_bar_dup_ao (FooiGenBar *object)
{
  gchar **value;
  g_object_get (G_OBJECT (object), "ao", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_ao: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.ao">"ao"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_ao (FooiGenBar *object, const gchar *const *value)
{
  g_object_set (G_OBJECT (object), "ao", value, NULL);
}

/**
 * foo_igen_bar_get_ag: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.ag">"ag"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_ag() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
foo_igen_bar_get_ag (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_ag (object);
}

/**
 * foo_igen_bar_dup_ag: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.ag">"ag"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
foo_igen_bar_dup_ag (FooiGenBar *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "ag", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_ag: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.ag">"ag"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_ag (FooiGenBar *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "ag", value, NULL);
}

/**
 * foo_igen_bar_get_finally_normal_name: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.FinallyNormalName">"FinallyNormalName"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_finally_normal_name() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_bar_get_finally_normal_name (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_finally_normal_name (object);
}

/**
 * foo_igen_bar_dup_finally_normal_name: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.FinallyNormalName">"FinallyNormalName"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_bar_dup_finally_normal_name (FooiGenBar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "finally-normal-name", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_finally_normal_name: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.FinallyNormalName">"FinallyNormalName"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_finally_normal_name (FooiGenBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "finally-normal-name", value, NULL);
}

/**
 * foo_igen_bar_get_readonly_property: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.ReadonlyProperty">"ReadonlyProperty"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_readonly_property() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_bar_get_readonly_property (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_readonly_property (object);
}

/**
 * foo_igen_bar_dup_readonly_property: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.ReadonlyProperty">"ReadonlyProperty"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_bar_dup_readonly_property (FooiGenBar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "readonly-property", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_readonly_property: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.ReadonlyProperty">"ReadonlyProperty"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_igen_bar_set_readonly_property (FooiGenBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "readonly-property", value, NULL);
}

/**
 * foo_igen_bar_get_writeonly_property: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.WriteonlyProperty">"WriteonlyProperty"</link> D-Bus property.
 *
 * Since this D-Bus property is not readable, it is only meaningful to use this function on the service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_writeonly_property() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_bar_get_writeonly_property (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_writeonly_property (object);
}

/**
 * foo_igen_bar_dup_writeonly_property: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.WriteonlyProperty">"WriteonlyProperty"</link> D-Bus property.
 *
 * Since this D-Bus property is not readable, it is only meaningful to use this function on the service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_bar_dup_writeonly_property (FooiGenBar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "writeonly-property", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_writeonly_property: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.WriteonlyProperty">"WriteonlyProperty"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_writeonly_property (FooiGenBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "writeonly-property", value, NULL);
}

/**
 * foo_igen_bar_get_unset_i: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_i">"unset_i"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
foo_igen_bar_get_unset_i (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_unset_i (object);
}

/**
 * foo_igen_bar_set_unset_i: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_i">"unset_i"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_unset_i (FooiGenBar *object, gint value)
{
  g_object_set (G_OBJECT (object), "unset-i", value, NULL);
}

/**
 * foo_igen_bar_get_unset_d: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_d">"unset_d"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gdouble 
foo_igen_bar_get_unset_d (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_unset_d (object);
}

/**
 * foo_igen_bar_set_unset_d: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_d">"unset_d"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_unset_d (FooiGenBar *object, gdouble value)
{
  g_object_set (G_OBJECT (object), "unset-d", value, NULL);
}

/**
 * foo_igen_bar_get_unset_s: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_s">"unset_s"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_unset_s() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_bar_get_unset_s (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_unset_s (object);
}

/**
 * foo_igen_bar_dup_unset_s: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.unset_s">"unset_s"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_bar_dup_unset_s (FooiGenBar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "unset-s", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_unset_s: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_s">"unset_s"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_unset_s (FooiGenBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "unset-s", value, NULL);
}

/**
 * foo_igen_bar_get_unset_o: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_o">"unset_o"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_unset_o() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_bar_get_unset_o (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_unset_o (object);
}

/**
 * foo_igen_bar_dup_unset_o: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.unset_o">"unset_o"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_bar_dup_unset_o (FooiGenBar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "unset-o", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_unset_o: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_o">"unset_o"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_unset_o (FooiGenBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "unset-o", value, NULL);
}

/**
 * foo_igen_bar_get_unset_g: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_g">"unset_g"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_unset_g() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_bar_get_unset_g (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_unset_g (object);
}

/**
 * foo_igen_bar_dup_unset_g: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.unset_g">"unset_g"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_bar_dup_unset_g (FooiGenBar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "unset-g", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_unset_g: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_g">"unset_g"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_unset_g (FooiGenBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "unset-g", value, NULL);
}

/**
 * foo_igen_bar_get_unset_ay: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_ay">"unset_ay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_unset_ay() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_bar_get_unset_ay (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_unset_ay (object);
}

/**
 * foo_igen_bar_dup_unset_ay: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.unset_ay">"unset_ay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_bar_dup_unset_ay (FooiGenBar *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "unset-ay", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_unset_ay: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_ay">"unset_ay"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_unset_ay (FooiGenBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "unset-ay", value, NULL);
}

/**
 * foo_igen_bar_get_unset_as: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_as">"unset_as"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_unset_as() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *const *
foo_igen_bar_get_unset_as (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_unset_as (object);
}

/**
 * foo_igen_bar_dup_unset_as: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.unset_as">"unset_as"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_strfreev().
 */
gchar **
foo_igen_bar_dup_unset_as (FooiGenBar *object)
{
  gchar **value;
  g_object_get (G_OBJECT (object), "unset-as", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_unset_as: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_as">"unset_as"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_unset_as (FooiGenBar *object, const gchar *const *value)
{
  g_object_set (G_OBJECT (object), "unset-as", value, NULL);
}

/**
 * foo_igen_bar_get_unset_ao: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_ao">"unset_ao"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_unset_ao() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *const *
foo_igen_bar_get_unset_ao (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_unset_ao (object);
}

/**
 * foo_igen_bar_dup_unset_ao: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.unset_ao">"unset_ao"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_strfreev().
 */
gchar **
foo_igen_bar_dup_unset_ao (FooiGenBar *object)
{
  gchar **value;
  g_object_get (G_OBJECT (object), "unset-ao", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_unset_ao: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_ao">"unset_ao"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_unset_ao (FooiGenBar *object, const gchar *const *value)
{
  g_object_set (G_OBJECT (object), "unset-ao", value, NULL);
}

/**
 * foo_igen_bar_get_unset_ag: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_ag">"unset_ag"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_unset_ag() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
foo_igen_bar_get_unset_ag (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_unset_ag (object);
}

/**
 * foo_igen_bar_dup_unset_ag: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.unset_ag">"unset_ag"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
foo_igen_bar_dup_unset_ag (FooiGenBar *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "unset-ag", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_unset_ag: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_ag">"unset_ag"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_unset_ag (FooiGenBar *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "unset-ag", value, NULL);
}

/**
 * foo_igen_bar_get_unset_struct: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_struct">"unset_struct"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bar_dup_unset_struct() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
foo_igen_bar_get_unset_struct (FooiGenBar *object)
{
  return FOO_IGEN_BAR_GET_IFACE (object)->get_unset_struct (object);
}

/**
 * foo_igen_bar_dup_unset_struct: (skip)
 * @object: A #FooiGenBar.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bar.unset_struct">"unset_struct"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
foo_igen_bar_dup_unset_struct (FooiGenBar *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "unset-struct", &value, NULL);
  return value;
}

/**
 * foo_igen_bar_set_unset_struct: (skip)
 * @object: A #FooiGenBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_struct">"unset_struct"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bar_set_unset_struct (FooiGenBar *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "unset-struct", value, NULL);
}

/**
 * foo_igen_bar_emit_test_signal:
 * @object: A #FooiGenBar.
 * @arg_val_int32: Argument to pass with the signal.
 * @arg_array_of_strings: Argument to pass with the signal.
 * @arg_array_of_bytestrings: Argument to pass with the signal.
 * @arg_dict_s_to_pairs: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-project-Bar.TestSignal">"TestSignal"</link> D-Bus signal.
 */
void
foo_igen_bar_emit_test_signal (
    FooiGenBar *object,
    gint arg_val_int32,
    const gchar *const *arg_array_of_strings,
    const gchar *const *arg_array_of_bytestrings,
    GVariant *arg_dict_s_to_pairs)
{
  g_signal_emit_by_name (object, "test-signal", arg_val_int32, arg_array_of_strings, arg_array_of_bytestrings, arg_dict_s_to_pairs);
}

/**
 * foo_igen_bar_emit_another_signal:
 * @object: A #FooiGenBar.
 * @arg_word: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-project-Bar.AnotherSignal">"AnotherSignal"</link> D-Bus signal.
 */
void
foo_igen_bar_emit_another_signal (
    FooiGenBar *object,
    const gchar *arg_word)
{
  g_signal_emit_by_name (object, "another-signal", arg_word);
}

/**
 * foo_igen_bar_call_hello_world:
 * @proxy: A #FooiGenBarProxy.
 * @arg_greeting: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar.HelloWorld">HelloWorld()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_call_hello_world_finish() to get the result of the operation.
 *
 * See foo_igen_bar_call_hello_world_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_bar_call_hello_world (
    FooiGenBar *proxy,
    const gchar *arg_greeting,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "HelloWorld",
    g_variant_new ("(s)",
                   arg_greeting),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_bar_call_hello_world_finish:
 * @proxy: A #FooiGenBarProxy.
 * @out_response: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_call_hello_world().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_bar_call_hello_world().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_hello_world_finish (
    FooiGenBar *proxy,
    gchar **out_response,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_response);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_hello_world_sync:
 * @proxy: A #FooiGenBarProxy.
 * @arg_greeting: Argument to pass with the method invocation.
 * @out_response: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar.HelloWorld">HelloWorld()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_call_hello_world() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_hello_world_sync (
    FooiGenBar *proxy,
    const gchar *arg_greeting,
    gchar **out_response,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "HelloWorld",
    g_variant_new ("(s)",
                   arg_greeting),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_response);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_test_primitive_types:
 * @proxy: A #FooiGenBarProxy.
 * @arg_val_byte: Argument to pass with the method invocation.
 * @arg_val_boolean: Argument to pass with the method invocation.
 * @arg_val_int16: Argument to pass with the method invocation.
 * @arg_val_uint16: Argument to pass with the method invocation.
 * @arg_val_int32: Argument to pass with the method invocation.
 * @arg_val_uint32: Argument to pass with the method invocation.
 * @arg_val_int64: Argument to pass with the method invocation.
 * @arg_val_uint64: Argument to pass with the method invocation.
 * @arg_val_double: Argument to pass with the method invocation.
 * @arg_val_string: Argument to pass with the method invocation.
 * @arg_val_objpath: Argument to pass with the method invocation.
 * @arg_val_signature: Argument to pass with the method invocation.
 * @arg_val_bytestring: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar.TestPrimitiveTypes">TestPrimitiveTypes()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_call_test_primitive_types_finish() to get the result of the operation.
 *
 * See foo_igen_bar_call_test_primitive_types_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_bar_call_test_primitive_types (
    FooiGenBar *proxy,
    guchar arg_val_byte,
    gboolean arg_val_boolean,
    gint16 arg_val_int16,
    guint16 arg_val_uint16,
    gint arg_val_int32,
    guint arg_val_uint32,
    gint64 arg_val_int64,
    guint64 arg_val_uint64,
    gdouble arg_val_double,
    const gchar *arg_val_string,
    const gchar *arg_val_objpath,
    const gchar *arg_val_signature,
    const gchar *arg_val_bytestring,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "TestPrimitiveTypes",
    g_variant_new ("(ybnqiuxtdsog^ay)",
                   arg_val_byte,
                   arg_val_boolean,
                   arg_val_int16,
                   arg_val_uint16,
                   arg_val_int32,
                   arg_val_uint32,
                   arg_val_int64,
                   arg_val_uint64,
                   arg_val_double,
                   arg_val_string,
                   arg_val_objpath,
                   arg_val_signature,
                   arg_val_bytestring),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_bar_call_test_primitive_types_finish:
 * @proxy: A #FooiGenBarProxy.
 * @out_ret_byte: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_boolean: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_int16: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_uint16: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_int32: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_uint32: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_int64: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_uint64: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_double: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_string: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_objpath: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_signature: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_bytestring: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_call_test_primitive_types().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_bar_call_test_primitive_types().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_test_primitive_types_finish (
    FooiGenBar *proxy,
    guchar *out_ret_byte,
    gboolean *out_ret_boolean,
    gint16 *out_ret_int16,
    guint16 *out_ret_uint16,
    gint *out_ret_int32,
    guint *out_ret_uint32,
    gint64 *out_ret_int64,
    guint64 *out_ret_uint64,
    gdouble *out_ret_double,
    gchar **out_ret_string,
    gchar **out_ret_objpath,
    gchar **out_ret_signature,
    gchar **out_ret_bytestring,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(ybnqiuxtdsog^ay)",
                 out_ret_byte,
                 out_ret_boolean,
                 out_ret_int16,
                 out_ret_uint16,
                 out_ret_int32,
                 out_ret_uint32,
                 out_ret_int64,
                 out_ret_uint64,
                 out_ret_double,
                 out_ret_string,
                 out_ret_objpath,
                 out_ret_signature,
                 out_ret_bytestring);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_test_primitive_types_sync:
 * @proxy: A #FooiGenBarProxy.
 * @arg_val_byte: Argument to pass with the method invocation.
 * @arg_val_boolean: Argument to pass with the method invocation.
 * @arg_val_int16: Argument to pass with the method invocation.
 * @arg_val_uint16: Argument to pass with the method invocation.
 * @arg_val_int32: Argument to pass with the method invocation.
 * @arg_val_uint32: Argument to pass with the method invocation.
 * @arg_val_int64: Argument to pass with the method invocation.
 * @arg_val_uint64: Argument to pass with the method invocation.
 * @arg_val_double: Argument to pass with the method invocation.
 * @arg_val_string: Argument to pass with the method invocation.
 * @arg_val_objpath: Argument to pass with the method invocation.
 * @arg_val_signature: Argument to pass with the method invocation.
 * @arg_val_bytestring: Argument to pass with the method invocation.
 * @out_ret_byte: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_boolean: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_int16: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_uint16: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_int32: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_uint32: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_int64: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_uint64: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_double: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_string: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_objpath: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_signature: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_bytestring: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar.TestPrimitiveTypes">TestPrimitiveTypes()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_call_test_primitive_types() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_test_primitive_types_sync (
    FooiGenBar *proxy,
    guchar arg_val_byte,
    gboolean arg_val_boolean,
    gint16 arg_val_int16,
    guint16 arg_val_uint16,
    gint arg_val_int32,
    guint arg_val_uint32,
    gint64 arg_val_int64,
    guint64 arg_val_uint64,
    gdouble arg_val_double,
    const gchar *arg_val_string,
    const gchar *arg_val_objpath,
    const gchar *arg_val_signature,
    const gchar *arg_val_bytestring,
    guchar *out_ret_byte,
    gboolean *out_ret_boolean,
    gint16 *out_ret_int16,
    guint16 *out_ret_uint16,
    gint *out_ret_int32,
    guint *out_ret_uint32,
    gint64 *out_ret_int64,
    guint64 *out_ret_uint64,
    gdouble *out_ret_double,
    gchar **out_ret_string,
    gchar **out_ret_objpath,
    gchar **out_ret_signature,
    gchar **out_ret_bytestring,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "TestPrimitiveTypes",
    g_variant_new ("(ybnqiuxtdsog^ay)",
                   arg_val_byte,
                   arg_val_boolean,
                   arg_val_int16,
                   arg_val_uint16,
                   arg_val_int32,
                   arg_val_uint32,
                   arg_val_int64,
                   arg_val_uint64,
                   arg_val_double,
                   arg_val_string,
                   arg_val_objpath,
                   arg_val_signature,
                   arg_val_bytestring),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(ybnqiuxtdsog^ay)",
                 out_ret_byte,
                 out_ret_boolean,
                 out_ret_int16,
                 out_ret_uint16,
                 out_ret_int32,
                 out_ret_uint32,
                 out_ret_int64,
                 out_ret_uint64,
                 out_ret_double,
                 out_ret_string,
                 out_ret_objpath,
                 out_ret_signature,
                 out_ret_bytestring);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_test_non_primitive_types:
 * @proxy: A #FooiGenBarProxy.
 * @arg_dict_s_to_s: Argument to pass with the method invocation.
 * @arg_dict_s_to_pairs: Argument to pass with the method invocation.
 * @arg_a_struct: Argument to pass with the method invocation.
 * @arg_array_of_strings: Argument to pass with the method invocation.
 * @arg_array_of_objpaths: Argument to pass with the method invocation.
 * @arg_array_of_signatures: Argument to pass with the method invocation.
 * @arg_array_of_bytestrings: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar.TestNonPrimitiveTypes">TestNonPrimitiveTypes()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_call_test_non_primitive_types_finish() to get the result of the operation.
 *
 * See foo_igen_bar_call_test_non_primitive_types_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_bar_call_test_non_primitive_types (
    FooiGenBar *proxy,
    GVariant *arg_dict_s_to_s,
    GVariant *arg_dict_s_to_pairs,
    GVariant *arg_a_struct,
    const gchar *const *arg_array_of_strings,
    const gchar *const *arg_array_of_objpaths,
    GVariant *arg_array_of_signatures,
    const gchar *const *arg_array_of_bytestrings,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "TestNonPrimitiveTypes",
    g_variant_new ("(@a{ss}@a{s(ii)}@(iss)^as^ao@ag^aay)",
                   arg_dict_s_to_s,
                   arg_dict_s_to_pairs,
                   arg_a_struct,
                   arg_array_of_strings,
                   arg_array_of_objpaths,
                   arg_array_of_signatures,
                   arg_array_of_bytestrings),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_bar_call_test_non_primitive_types_finish:
 * @proxy: A #FooiGenBarProxy.
 * @out_result: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_call_test_non_primitive_types().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_bar_call_test_non_primitive_types().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_test_non_primitive_types_finish (
    FooiGenBar *proxy,
    gchar **out_result,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(^ay)",
                 out_result);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_test_non_primitive_types_sync:
 * @proxy: A #FooiGenBarProxy.
 * @arg_dict_s_to_s: Argument to pass with the method invocation.
 * @arg_dict_s_to_pairs: Argument to pass with the method invocation.
 * @arg_a_struct: Argument to pass with the method invocation.
 * @arg_array_of_strings: Argument to pass with the method invocation.
 * @arg_array_of_objpaths: Argument to pass with the method invocation.
 * @arg_array_of_signatures: Argument to pass with the method invocation.
 * @arg_array_of_bytestrings: Argument to pass with the method invocation.
 * @out_result: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar.TestNonPrimitiveTypes">TestNonPrimitiveTypes()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_call_test_non_primitive_types() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_test_non_primitive_types_sync (
    FooiGenBar *proxy,
    GVariant *arg_dict_s_to_s,
    GVariant *arg_dict_s_to_pairs,
    GVariant *arg_a_struct,
    const gchar *const *arg_array_of_strings,
    const gchar *const *arg_array_of_objpaths,
    GVariant *arg_array_of_signatures,
    const gchar *const *arg_array_of_bytestrings,
    gchar **out_result,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "TestNonPrimitiveTypes",
    g_variant_new ("(@a{ss}@a{s(ii)}@(iss)^as^ao@ag^aay)",
                   arg_dict_s_to_s,
                   arg_dict_s_to_pairs,
                   arg_a_struct,
                   arg_array_of_strings,
                   arg_array_of_objpaths,
                   arg_array_of_signatures,
                   arg_array_of_bytestrings),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(^ay)",
                 out_result);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_request_signal_emission:
 * @proxy: A #FooiGenBarProxy.
 * @arg_which_one: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar.RequestSignalEmission">RequestSignalEmission()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_call_request_signal_emission_finish() to get the result of the operation.
 *
 * See foo_igen_bar_call_request_signal_emission_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_bar_call_request_signal_emission (
    FooiGenBar *proxy,
    gint arg_which_one,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "RequestSignalEmission",
    g_variant_new ("(i)",
                   arg_which_one),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_bar_call_request_signal_emission_finish:
 * @proxy: A #FooiGenBarProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_call_request_signal_emission().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_bar_call_request_signal_emission().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_request_signal_emission_finish (
    FooiGenBar *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_request_signal_emission_sync:
 * @proxy: A #FooiGenBarProxy.
 * @arg_which_one: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar.RequestSignalEmission">RequestSignalEmission()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_call_request_signal_emission() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_request_signal_emission_sync (
    FooiGenBar *proxy,
    gint arg_which_one,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "RequestSignalEmission",
    g_variant_new ("(i)",
                   arg_which_one),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_request_multi_property_mods:
 * @proxy: A #FooiGenBarProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar.RequestMultiPropertyMods">RequestMultiPropertyMods()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_call_request_multi_property_mods_finish() to get the result of the operation.
 *
 * See foo_igen_bar_call_request_multi_property_mods_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_bar_call_request_multi_property_mods (
    FooiGenBar *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "RequestMultiPropertyMods",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_bar_call_request_multi_property_mods_finish:
 * @proxy: A #FooiGenBarProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_call_request_multi_property_mods().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_bar_call_request_multi_property_mods().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_request_multi_property_mods_finish (
    FooiGenBar *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_request_multi_property_mods_sync:
 * @proxy: A #FooiGenBarProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar.RequestMultiPropertyMods">RequestMultiPropertyMods()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_call_request_multi_property_mods() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_request_multi_property_mods_sync (
    FooiGenBar *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "RequestMultiPropertyMods",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_unimplemented_method:
 * @proxy: A #FooiGenBarProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar.UnimplementedMethod">UnimplementedMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_call_unimplemented_method_finish() to get the result of the operation.
 *
 * See foo_igen_bar_call_unimplemented_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_bar_call_unimplemented_method (
    FooiGenBar *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "UnimplementedMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_bar_call_unimplemented_method_finish:
 * @proxy: A #FooiGenBarProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_call_unimplemented_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_bar_call_unimplemented_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_unimplemented_method_finish (
    FooiGenBar *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_unimplemented_method_sync:
 * @proxy: A #FooiGenBarProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar.UnimplementedMethod">UnimplementedMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_call_unimplemented_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_unimplemented_method_sync (
    FooiGenBar *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "UnimplementedMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_property_cancellation:
 * @proxy: A #FooiGenBarProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar.PropertyCancellation">PropertyCancellation()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_call_property_cancellation_finish() to get the result of the operation.
 *
 * See foo_igen_bar_call_property_cancellation_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_bar_call_property_cancellation (
    FooiGenBar *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "PropertyCancellation",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_bar_call_property_cancellation_finish:
 * @proxy: A #FooiGenBarProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_call_property_cancellation().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_bar_call_property_cancellation().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_property_cancellation_finish (
    FooiGenBar *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_call_property_cancellation_sync:
 * @proxy: A #FooiGenBarProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar.PropertyCancellation">PropertyCancellation()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_call_property_cancellation() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_call_property_cancellation_sync (
    FooiGenBar *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "PropertyCancellation",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_complete_hello_world:
 * @object: A #FooiGenBar.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @response: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar.HelloWorld">HelloWorld()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_bar_complete_hello_world (
    FooiGenBar *object,
    GDBusMethodInvocation *invocation,
    const gchar *response)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(s)",
                   response));
}

/**
 * foo_igen_bar_complete_test_primitive_types:
 * @object: A #FooiGenBar.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @ret_byte: Parameter to return.
 * @ret_boolean: Parameter to return.
 * @ret_int16: Parameter to return.
 * @ret_uint16: Parameter to return.
 * @ret_int32: Parameter to return.
 * @ret_uint32: Parameter to return.
 * @ret_int64: Parameter to return.
 * @ret_uint64: Parameter to return.
 * @ret_double: Parameter to return.
 * @ret_string: Parameter to return.
 * @ret_objpath: Parameter to return.
 * @ret_signature: Parameter to return.
 * @ret_bytestring: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar.TestPrimitiveTypes">TestPrimitiveTypes()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_bar_complete_test_primitive_types (
    FooiGenBar *object,
    GDBusMethodInvocation *invocation,
    guchar ret_byte,
    gboolean ret_boolean,
    gint16 ret_int16,
    guint16 ret_uint16,
    gint ret_int32,
    guint ret_uint32,
    gint64 ret_int64,
    guint64 ret_uint64,
    gdouble ret_double,
    const gchar *ret_string,
    const gchar *ret_objpath,
    const gchar *ret_signature,
    const gchar *ret_bytestring)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(ybnqiuxtdsog^ay)",
                   ret_byte,
                   ret_boolean,
                   ret_int16,
                   ret_uint16,
                   ret_int32,
                   ret_uint32,
                   ret_int64,
                   ret_uint64,
                   ret_double,
                   ret_string,
                   ret_objpath,
                   ret_signature,
                   ret_bytestring));
}

/**
 * foo_igen_bar_complete_test_non_primitive_types:
 * @object: A #FooiGenBar.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @result: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar.TestNonPrimitiveTypes">TestNonPrimitiveTypes()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_bar_complete_test_non_primitive_types (
    FooiGenBar *object,
    GDBusMethodInvocation *invocation,
    const gchar *result)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(^ay)",
                   result));
}

/**
 * foo_igen_bar_complete_request_signal_emission:
 * @object: A #FooiGenBar.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar.RequestSignalEmission">RequestSignalEmission()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_bar_complete_request_signal_emission (
    FooiGenBar *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_bar_complete_request_multi_property_mods:
 * @object: A #FooiGenBar.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar.RequestMultiPropertyMods">RequestMultiPropertyMods()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_bar_complete_request_multi_property_mods (
    FooiGenBar *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_bar_complete_unimplemented_method:
 * @object: A #FooiGenBar.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar.UnimplementedMethod">UnimplementedMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_bar_complete_unimplemented_method (
    FooiGenBar *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_bar_complete_property_cancellation:
 * @object: A #FooiGenBar.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar.PropertyCancellation">PropertyCancellation()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_bar_complete_property_cancellation (
    FooiGenBar *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenBarProxy:
 *
 * The #FooiGenBarProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenBarProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenBarProxy.
 */

struct _FooiGenBarProxyPrivate
{
  GData *qdata;
};

static void foo_igen_bar_proxy_iface_init (FooiGenBarIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenBarProxy, foo_igen_bar_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (FooiGenBarProxy)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAR, foo_igen_bar_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenBarProxy, foo_igen_bar_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAR, foo_igen_bar_proxy_iface_init));

#endif
static void
foo_igen_bar_proxy_finalize (GObject *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_bar_proxy_parent_class)->finalize (object);
}

static void
foo_igen_bar_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 30);
  info = _foo_igen_bar_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
foo_igen_bar_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.project.Bar: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
foo_igen_bar_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 30);
  info = _foo_igen_bar_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.project.Bar", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) foo_igen_bar_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
foo_igen_bar_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_bar_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_BAR);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_BAR);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_bar_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bar_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bar_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static guchar 
foo_igen_bar_proxy_get_y (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  guchar value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "y");
  if (variant != NULL)
    {
      value = g_variant_get_byte (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
foo_igen_bar_proxy_get_b (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "b");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gint16 
foo_igen_bar_proxy_get_n (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  gint16 value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "n");
  if (variant != NULL)
    {
      value = g_variant_get_int16 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static guint16 
foo_igen_bar_proxy_get_q (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  guint16 value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "q");
  if (variant != NULL)
    {
      value = g_variant_get_uint16 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gint 
foo_igen_bar_proxy_get_i (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "i");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static guint 
foo_igen_bar_proxy_get_u (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  guint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "u");
  if (variant != NULL)
    {
      value = g_variant_get_uint32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gint64 
foo_igen_bar_proxy_get_x (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  gint64 value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "x");
  if (variant != NULL)
    {
      value = g_variant_get_int64 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static guint64 
foo_igen_bar_proxy_get_t (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  guint64 value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "t");
  if (variant != NULL)
    {
      value = g_variant_get_uint64 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gdouble 
foo_igen_bar_proxy_get_d (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  gdouble value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "d");
  if (variant != NULL)
    {
      value = g_variant_get_double (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_bar_proxy_get_s (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "s");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_bar_proxy_get_o (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "o");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_bar_proxy_get_g (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "g");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_bar_proxy_get_ay (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ay");
  if (variant != NULL)
    {
      value = g_variant_get_bytestring (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *const *
foo_igen_bar_proxy_get_as (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *const *value = NULL;
  value = g_datalist_get_data (&proxy->priv->qdata, "as");
  if (value != NULL)
    return value;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "as");
  if (variant != NULL)
    {
      value = g_variant_get_strv (variant, NULL);
      g_datalist_set_data_full (&proxy->priv->qdata, "as", (gpointer) value, g_free);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *const *
foo_igen_bar_proxy_get_aay (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *const *value = NULL;
  value = g_datalist_get_data (&proxy->priv->qdata, "aay");
  if (value != NULL)
    return value;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "aay");
  if (variant != NULL)
    {
      value = g_variant_get_bytestring_array (variant, NULL);
      g_datalist_set_data_full (&proxy->priv->qdata, "aay", (gpointer) value, g_free);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *const *
foo_igen_bar_proxy_get_ao (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *const *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ao");
  if (variant != NULL)
    {
      value = g_variant_get_objv (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static GVariant *
foo_igen_bar_proxy_get_ag (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ag");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static const gchar *
foo_igen_bar_proxy_get_finally_normal_name (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "FinallyNormalName");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_bar_proxy_get_readonly_property (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ReadonlyProperty");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_bar_proxy_get_writeonly_property (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "WriteonlyProperty");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static gint 
foo_igen_bar_proxy_get_unset_i (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "unset_i");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gdouble 
foo_igen_bar_proxy_get_unset_d (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  gdouble value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "unset_d");
  if (variant != NULL)
    {
      value = g_variant_get_double (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_bar_proxy_get_unset_s (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "unset_s");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_bar_proxy_get_unset_o (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "unset_o");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_bar_proxy_get_unset_g (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "unset_g");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_bar_proxy_get_unset_ay (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "unset_ay");
  if (variant != NULL)
    {
      value = g_variant_get_bytestring (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *const *
foo_igen_bar_proxy_get_unset_as (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *const *value = NULL;
  value = g_datalist_get_data (&proxy->priv->qdata, "unset_as");
  if (value != NULL)
    return value;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "unset_as");
  if (variant != NULL)
    {
      value = g_variant_get_strv (variant, NULL);
      g_datalist_set_data_full (&proxy->priv->qdata, "unset_as", (gpointer) value, g_free);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *const *
foo_igen_bar_proxy_get_unset_ao (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  const gchar *const *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "unset_ao");
  if (variant != NULL)
    {
      value = g_variant_get_objv (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static GVariant *
foo_igen_bar_proxy_get_unset_ag (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "unset_ag");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static GVariant *
foo_igen_bar_proxy_get_unset_struct (FooiGenBar *object)
{
  FooiGenBarProxy *proxy = FOO_IGEN_BAR_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "unset_struct");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static void
foo_igen_bar_proxy_init (FooiGenBarProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = foo_igen_bar_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_BAR_PROXY, FooiGenBarProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_bar_interface_info ());
}

static void
foo_igen_bar_proxy_class_init (FooiGenBarProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_bar_proxy_finalize;
  gobject_class->get_property = foo_igen_bar_proxy_get_property;
  gobject_class->set_property = foo_igen_bar_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_bar_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_bar_proxy_g_properties_changed;

  foo_igen_bar_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenBarProxyPrivate));
#endif
}

static void
foo_igen_bar_proxy_iface_init (FooiGenBarIface *iface)
{
  iface->get_y = foo_igen_bar_proxy_get_y;
  iface->get_b = foo_igen_bar_proxy_get_b;
  iface->get_n = foo_igen_bar_proxy_get_n;
  iface->get_q = foo_igen_bar_proxy_get_q;
  iface->get_i = foo_igen_bar_proxy_get_i;
  iface->get_u = foo_igen_bar_proxy_get_u;
  iface->get_x = foo_igen_bar_proxy_get_x;
  iface->get_t = foo_igen_bar_proxy_get_t;
  iface->get_d = foo_igen_bar_proxy_get_d;
  iface->get_s = foo_igen_bar_proxy_get_s;
  iface->get_o = foo_igen_bar_proxy_get_o;
  iface->get_g = foo_igen_bar_proxy_get_g;
  iface->get_ay = foo_igen_bar_proxy_get_ay;
  iface->get_as = foo_igen_bar_proxy_get_as;
  iface->get_aay = foo_igen_bar_proxy_get_aay;
  iface->get_ao = foo_igen_bar_proxy_get_ao;
  iface->get_ag = foo_igen_bar_proxy_get_ag;
  iface->get_finally_normal_name = foo_igen_bar_proxy_get_finally_normal_name;
  iface->get_readonly_property = foo_igen_bar_proxy_get_readonly_property;
  iface->get_writeonly_property = foo_igen_bar_proxy_get_writeonly_property;
  iface->get_unset_i = foo_igen_bar_proxy_get_unset_i;
  iface->get_unset_d = foo_igen_bar_proxy_get_unset_d;
  iface->get_unset_s = foo_igen_bar_proxy_get_unset_s;
  iface->get_unset_o = foo_igen_bar_proxy_get_unset_o;
  iface->get_unset_g = foo_igen_bar_proxy_get_unset_g;
  iface->get_unset_ay = foo_igen_bar_proxy_get_unset_ay;
  iface->get_unset_as = foo_igen_bar_proxy_get_unset_as;
  iface->get_unset_ao = foo_igen_bar_proxy_get_unset_ao;
  iface->get_unset_ag = foo_igen_bar_proxy_get_unset_ag;
  iface->get_unset_struct = foo_igen_bar_proxy_get_unset_struct;
}

/**
 * foo_igen_bar_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_bar_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_bar_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_BAR_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Bar", NULL);
}

/**
 * foo_igen_bar_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_bar_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenBarProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBar *
foo_igen_bar_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_BAR (ret);
  else
    return NULL;
}

/**
 * foo_igen_bar_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenBarProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBar *
foo_igen_bar_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_BAR_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Bar", NULL);
  if (ret != NULL)
    return FOO_IGEN_BAR (ret);
  else
    return NULL;
}


/**
 * foo_igen_bar_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_bar_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_bar_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_bar_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_BAR_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Bar", NULL);
}

/**
 * foo_igen_bar_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_bar_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenBarProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBar *
foo_igen_bar_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_BAR (ret);
  else
    return NULL;
}

/**
 * foo_igen_bar_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_bar_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenBarProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBar *
foo_igen_bar_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_BAR_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Bar", NULL);
  if (ret != NULL)
    return FOO_IGEN_BAR (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenBarSkeleton:
 *
 * The #FooiGenBarSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenBarSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenBarSkeleton.
 */

struct _FooiGenBarSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_foo_igen_bar_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_BAR);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_BAR);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_bar_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bar_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_bar_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bar_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_bar_skeleton_vtable =
{
  _foo_igen_bar_skeleton_handle_method_call,
  _foo_igen_bar_skeleton_handle_get_property,
  _foo_igen_bar_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
foo_igen_bar_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return foo_igen_bar_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_bar_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_foo_igen_bar_skeleton_vtable;
}

static GVariant *
foo_igen_bar_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_bar_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_bar_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_bar_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_bar_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Bar", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _foo_igen_bar_emit_changed (gpointer user_data);

static void
foo_igen_bar_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _foo_igen_bar_emit_changed (skeleton);
}

static void
_foo_igen_bar_on_signal_test_signal (
    FooiGenBar *object,
    gint arg_val_int32,
    const gchar *const *arg_array_of_strings,
    const gchar *const *arg_array_of_bytestrings,
    GVariant *arg_dict_s_to_pairs)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(i^as^aay@a{s(ii)})",
                   arg_val_int32,
                   arg_array_of_strings,
                   arg_array_of_bytestrings,
                   arg_dict_s_to_pairs));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Bar", "TestSignal",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_foo_igen_bar_on_signal_another_signal (
    FooiGenBar *object,
    const gchar *arg_word)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(s)",
                   arg_word));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Bar", "AnotherSignal",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void foo_igen_bar_skeleton_iface_init (FooiGenBarIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenBarSkeleton, foo_igen_bar_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (FooiGenBarSkeleton)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAR, foo_igen_bar_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenBarSkeleton, foo_igen_bar_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAR, foo_igen_bar_skeleton_iface_init));

#endif
static void
foo_igen_bar_skeleton_finalize (GObject *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  guint n;
  for (n = 0; n < 30; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_bar_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_bar_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 30);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_foo_igen_bar_emit_changed (gpointer user_data)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.project.Bar",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_foo_igen_bar_schedule_emit_changed (FooiGenBarSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
foo_igen_bar_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _foo_igen_bar_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _foo_igen_bar_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
foo_igen_bar_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 30);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _foo_igen_bar_schedule_emit_changed (skeleton, _foo_igen_bar_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
foo_igen_bar_skeleton_init (FooiGenBarSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = foo_igen_bar_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_BAR_SKELETON, FooiGenBarSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 30);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_UCHAR);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[2], G_TYPE_INT);
  g_value_init (&skeleton->priv->properties[3], G_TYPE_UINT);
  g_value_init (&skeleton->priv->properties[4], G_TYPE_INT);
  g_value_init (&skeleton->priv->properties[5], G_TYPE_UINT);
  g_value_init (&skeleton->priv->properties[6], G_TYPE_INT64);
  g_value_init (&skeleton->priv->properties[7], G_TYPE_UINT64);
  g_value_init (&skeleton->priv->properties[8], G_TYPE_DOUBLE);
  g_value_init (&skeleton->priv->properties[9], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[10], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[11], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[12], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[13], G_TYPE_STRV);
  g_value_init (&skeleton->priv->properties[14], G_TYPE_STRV);
  g_value_init (&skeleton->priv->properties[15], G_TYPE_STRV);
  g_value_init (&skeleton->priv->properties[16], G_TYPE_VARIANT);
  g_value_init (&skeleton->priv->properties[17], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[18], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[19], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[20], G_TYPE_INT);
  g_value_init (&skeleton->priv->properties[21], G_TYPE_DOUBLE);
  g_value_init (&skeleton->priv->properties[22], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[23], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[24], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[25], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[26], G_TYPE_STRV);
  g_value_init (&skeleton->priv->properties[27], G_TYPE_STRV);
  g_value_init (&skeleton->priv->properties[28], G_TYPE_VARIANT);
  g_value_init (&skeleton->priv->properties[29], G_TYPE_VARIANT);
}

static guchar 
foo_igen_bar_skeleton_get_y (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  guchar value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_uchar (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
foo_igen_bar_skeleton_get_b (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gint16 
foo_igen_bar_skeleton_get_n (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[2]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static guint16 
foo_igen_bar_skeleton_get_q (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  guint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_uint (&(skeleton->priv->properties[3]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gint 
foo_igen_bar_skeleton_get_i (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[4]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static guint 
foo_igen_bar_skeleton_get_u (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  guint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_uint (&(skeleton->priv->properties[5]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gint64 
foo_igen_bar_skeleton_get_x (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  gint64 value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int64 (&(skeleton->priv->properties[6]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static guint64 
foo_igen_bar_skeleton_get_t (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  guint64 value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_uint64 (&(skeleton->priv->properties[7]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gdouble 
foo_igen_bar_skeleton_get_d (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  gdouble value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_double (&(skeleton->priv->properties[8]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_bar_skeleton_get_s (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[9]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_bar_skeleton_get_o (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[10]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_bar_skeleton_get_g (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[11]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_bar_skeleton_get_ay (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[12]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *const *
foo_igen_bar_skeleton_get_as (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *const *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boxed (&(skeleton->priv->properties[13]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *const *
foo_igen_bar_skeleton_get_aay (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *const *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boxed (&(skeleton->priv->properties[14]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *const *
foo_igen_bar_skeleton_get_ao (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *const *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boxed (&(skeleton->priv->properties[15]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static GVariant *
foo_igen_bar_skeleton_get_ag (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  GVariant *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties[16]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_bar_skeleton_get_finally_normal_name (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[17]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_bar_skeleton_get_readonly_property (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[18]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_bar_skeleton_get_writeonly_property (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[19]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gint 
foo_igen_bar_skeleton_get_unset_i (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[20]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gdouble 
foo_igen_bar_skeleton_get_unset_d (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  gdouble value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_double (&(skeleton->priv->properties[21]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_bar_skeleton_get_unset_s (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[22]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_bar_skeleton_get_unset_o (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[23]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_bar_skeleton_get_unset_g (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[24]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_bar_skeleton_get_unset_ay (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[25]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *const *
foo_igen_bar_skeleton_get_unset_as (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *const *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boxed (&(skeleton->priv->properties[26]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *const *
foo_igen_bar_skeleton_get_unset_ao (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  const gchar *const *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boxed (&(skeleton->priv->properties[27]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static GVariant *
foo_igen_bar_skeleton_get_unset_ag (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  GVariant *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties[28]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static GVariant *
foo_igen_bar_skeleton_get_unset_struct (FooiGenBar *object)
{
  FooiGenBarSkeleton *skeleton = FOO_IGEN_BAR_SKELETON (object);
  GVariant *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties[29]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
foo_igen_bar_skeleton_class_init (FooiGenBarSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_bar_skeleton_finalize;
  gobject_class->get_property = foo_igen_bar_skeleton_get_property;
  gobject_class->set_property = foo_igen_bar_skeleton_set_property;
  gobject_class->notify       = foo_igen_bar_skeleton_notify;


  foo_igen_bar_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_bar_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_bar_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_bar_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_bar_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenBarSkeletonPrivate));
#endif
}

static void
foo_igen_bar_skeleton_iface_init (FooiGenBarIface *iface)
{
  iface->test_signal = _foo_igen_bar_on_signal_test_signal;
  iface->another_signal = _foo_igen_bar_on_signal_another_signal;
  iface->get_y = foo_igen_bar_skeleton_get_y;
  iface->get_b = foo_igen_bar_skeleton_get_b;
  iface->get_n = foo_igen_bar_skeleton_get_n;
  iface->get_q = foo_igen_bar_skeleton_get_q;
  iface->get_i = foo_igen_bar_skeleton_get_i;
  iface->get_u = foo_igen_bar_skeleton_get_u;
  iface->get_x = foo_igen_bar_skeleton_get_x;
  iface->get_t = foo_igen_bar_skeleton_get_t;
  iface->get_d = foo_igen_bar_skeleton_get_d;
  iface->get_s = foo_igen_bar_skeleton_get_s;
  iface->get_o = foo_igen_bar_skeleton_get_o;
  iface->get_g = foo_igen_bar_skeleton_get_g;
  iface->get_ay = foo_igen_bar_skeleton_get_ay;
  iface->get_as = foo_igen_bar_skeleton_get_as;
  iface->get_aay = foo_igen_bar_skeleton_get_aay;
  iface->get_ao = foo_igen_bar_skeleton_get_ao;
  iface->get_ag = foo_igen_bar_skeleton_get_ag;
  iface->get_finally_normal_name = foo_igen_bar_skeleton_get_finally_normal_name;
  iface->get_readonly_property = foo_igen_bar_skeleton_get_readonly_property;
  iface->get_writeonly_property = foo_igen_bar_skeleton_get_writeonly_property;
  iface->get_unset_i = foo_igen_bar_skeleton_get_unset_i;
  iface->get_unset_d = foo_igen_bar_skeleton_get_unset_d;
  iface->get_unset_s = foo_igen_bar_skeleton_get_unset_s;
  iface->get_unset_o = foo_igen_bar_skeleton_get_unset_o;
  iface->get_unset_g = foo_igen_bar_skeleton_get_unset_g;
  iface->get_unset_ay = foo_igen_bar_skeleton_get_unset_ay;
  iface->get_unset_as = foo_igen_bar_skeleton_get_unset_as;
  iface->get_unset_ao = foo_igen_bar_skeleton_get_unset_ao;
  iface->get_unset_ag = foo_igen_bar_skeleton_get_unset_ag;
  iface->get_unset_struct = foo_igen_bar_skeleton_get_unset_struct;
}

/**
 * foo_igen_bar_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link>.
 *
 * Returns: (transfer full) (type FooiGenBarSkeleton): The skeleton object.
 */
FooiGenBar *
foo_igen_bar_skeleton_new (void)
{
  return FOO_IGEN_BAR (g_object_new (FOO_IGEN_TYPE_BAR_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.project.Bar.Frobnicator
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenBarFrobnicator
 * @title: FooiGenBarFrobnicator
 * @short_description: Generated C code for the org.project.Bar.Frobnicator D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.project.Bar.Frobnicator ---- */

static const _ExtendedGDBusMethodInfo _foo_igen_bar_frobnicator_method_info_random_method =
{
  {
    -1,
    (gchar *) "RandomMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-random-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_bar_frobnicator_method_info_pointers[] =
{
  &_foo_igen_bar_frobnicator_method_info_random_method,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_bar_frobnicator_interface_info =
{
  {
    -1,
    (gchar *) "org.project.Bar.Frobnicator",
    (GDBusMethodInfo **) &_foo_igen_bar_frobnicator_method_info_pointers,
    NULL,
    NULL,
    NULL
  },
  "bar-frobnicator",
};


/**
 * foo_igen_bar_frobnicator_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_bar_frobnicator_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_bar_frobnicator_interface_info.parent_struct;
}

/**
 * foo_igen_bar_frobnicator_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenBarFrobnicator interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_bar_frobnicator_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * FooiGenBarFrobnicator:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link>.
 */

/**
 * FooiGenBarFrobnicatorIface:
 * @parent_iface: The parent interface.
 * @handle_random_method: Handler for the #FooiGenBarFrobnicator::handle-random-method signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link>.
 */

typedef FooiGenBarFrobnicatorIface FooiGenBarFrobnicatorInterface;
G_DEFINE_INTERFACE (FooiGenBarFrobnicator, foo_igen_bar_frobnicator, G_TYPE_OBJECT);

static void
foo_igen_bar_frobnicator_default_init (FooiGenBarFrobnicatorIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenBarFrobnicator::handle-random-method:
   * @object: A #FooiGenBarFrobnicator.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar-Frobnicator.RandomMethod">RandomMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_bar_frobnicator_complete_random_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-random-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBarFrobnicatorIface, handle_random_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

}

/**
 * foo_igen_bar_frobnicator_call_random_method:
 * @proxy: A #FooiGenBarFrobnicatorProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar-Frobnicator.RandomMethod">RandomMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_frobnicator_call_random_method_finish() to get the result of the operation.
 *
 * See foo_igen_bar_frobnicator_call_random_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_bar_frobnicator_call_random_method (
    FooiGenBarFrobnicator *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "RandomMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_bar_frobnicator_call_random_method_finish:
 * @proxy: A #FooiGenBarFrobnicatorProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_frobnicator_call_random_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_bar_frobnicator_call_random_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_frobnicator_call_random_method_finish (
    FooiGenBarFrobnicator *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_frobnicator_call_random_method_sync:
 * @proxy: A #FooiGenBarFrobnicatorProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar-Frobnicator.RandomMethod">RandomMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_frobnicator_call_random_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bar_frobnicator_call_random_method_sync (
    FooiGenBarFrobnicator *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "RandomMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bar_frobnicator_complete_random_method:
 * @object: A #FooiGenBarFrobnicator.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar-Frobnicator.RandomMethod">RandomMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_bar_frobnicator_complete_random_method (
    FooiGenBarFrobnicator *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenBarFrobnicatorProxy:
 *
 * The #FooiGenBarFrobnicatorProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenBarFrobnicatorProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenBarFrobnicatorProxy.
 */

struct _FooiGenBarFrobnicatorProxyPrivate
{
  GData *qdata;
};

static void foo_igen_bar_frobnicator_proxy_iface_init (FooiGenBarFrobnicatorIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenBarFrobnicatorProxy, foo_igen_bar_frobnicator_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (FooiGenBarFrobnicatorProxy)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAR_FROBNICATOR, foo_igen_bar_frobnicator_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenBarFrobnicatorProxy, foo_igen_bar_frobnicator_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAR_FROBNICATOR, foo_igen_bar_frobnicator_proxy_iface_init));

#endif
static void
foo_igen_bar_frobnicator_proxy_finalize (GObject *object)
{
  FooiGenBarFrobnicatorProxy *proxy = FOO_IGEN_BAR_FROBNICATOR_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_bar_frobnicator_proxy_parent_class)->finalize (object);
}

static void
foo_igen_bar_frobnicator_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
foo_igen_bar_frobnicator_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
foo_igen_bar_frobnicator_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_bar_frobnicator_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_BAR_FROBNICATOR);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_BAR_FROBNICATOR);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_bar_frobnicator_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenBarFrobnicatorProxy *proxy = FOO_IGEN_BAR_FROBNICATOR_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bar_frobnicator_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bar_frobnicator_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_igen_bar_frobnicator_proxy_init (FooiGenBarFrobnicatorProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = foo_igen_bar_frobnicator_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_BAR_FROBNICATOR_PROXY, FooiGenBarFrobnicatorProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_bar_frobnicator_interface_info ());
}

static void
foo_igen_bar_frobnicator_proxy_class_init (FooiGenBarFrobnicatorProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_bar_frobnicator_proxy_finalize;
  gobject_class->get_property = foo_igen_bar_frobnicator_proxy_get_property;
  gobject_class->set_property = foo_igen_bar_frobnicator_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_bar_frobnicator_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_bar_frobnicator_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenBarFrobnicatorProxyPrivate));
#endif
}

static void
foo_igen_bar_frobnicator_proxy_iface_init (FooiGenBarFrobnicatorIface *iface)
{
}

/**
 * foo_igen_bar_frobnicator_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_frobnicator_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_bar_frobnicator_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_bar_frobnicator_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_BAR_FROBNICATOR_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Bar.Frobnicator", NULL);
}

/**
 * foo_igen_bar_frobnicator_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_frobnicator_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_bar_frobnicator_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenBarFrobnicatorProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBarFrobnicator *
foo_igen_bar_frobnicator_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_BAR_FROBNICATOR (ret);
  else
    return NULL;
}

/**
 * foo_igen_bar_frobnicator_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_frobnicator_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenBarFrobnicatorProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBarFrobnicator *
foo_igen_bar_frobnicator_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_BAR_FROBNICATOR_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Bar.Frobnicator", NULL);
  if (ret != NULL)
    return FOO_IGEN_BAR_FROBNICATOR (ret);
  else
    return NULL;
}


/**
 * foo_igen_bar_frobnicator_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_bar_frobnicator_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bar_frobnicator_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_bar_frobnicator_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_bar_frobnicator_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_BAR_FROBNICATOR_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Bar.Frobnicator", NULL);
}

/**
 * foo_igen_bar_frobnicator_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bar_frobnicator_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_bar_frobnicator_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenBarFrobnicatorProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBarFrobnicator *
foo_igen_bar_frobnicator_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_BAR_FROBNICATOR (ret);
  else
    return NULL;
}

/**
 * foo_igen_bar_frobnicator_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_bar_frobnicator_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bar_frobnicator_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenBarFrobnicatorProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBarFrobnicator *
foo_igen_bar_frobnicator_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_BAR_FROBNICATOR_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Bar.Frobnicator", NULL);
  if (ret != NULL)
    return FOO_IGEN_BAR_FROBNICATOR (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenBarFrobnicatorSkeleton:
 *
 * The #FooiGenBarFrobnicatorSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenBarFrobnicatorSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenBarFrobnicatorSkeleton.
 */

struct _FooiGenBarFrobnicatorSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_foo_igen_bar_frobnicator_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenBarFrobnicatorSkeleton *skeleton = FOO_IGEN_BAR_FROBNICATOR_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_BAR_FROBNICATOR);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_BAR_FROBNICATOR);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_bar_frobnicator_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenBarFrobnicatorSkeleton *skeleton = FOO_IGEN_BAR_FROBNICATOR_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bar_frobnicator_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_bar_frobnicator_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenBarFrobnicatorSkeleton *skeleton = FOO_IGEN_BAR_FROBNICATOR_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bar_frobnicator_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_bar_frobnicator_skeleton_vtable =
{
  _foo_igen_bar_frobnicator_skeleton_handle_method_call,
  _foo_igen_bar_frobnicator_skeleton_handle_get_property,
  _foo_igen_bar_frobnicator_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
foo_igen_bar_frobnicator_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return foo_igen_bar_frobnicator_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_bar_frobnicator_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_foo_igen_bar_frobnicator_skeleton_vtable;
}

static GVariant *
foo_igen_bar_frobnicator_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenBarFrobnicatorSkeleton *skeleton = FOO_IGEN_BAR_FROBNICATOR_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_bar_frobnicator_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_bar_frobnicator_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_bar_frobnicator_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_bar_frobnicator_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Bar.Frobnicator", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
foo_igen_bar_frobnicator_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void foo_igen_bar_frobnicator_skeleton_iface_init (FooiGenBarFrobnicatorIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenBarFrobnicatorSkeleton, foo_igen_bar_frobnicator_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (FooiGenBarFrobnicatorSkeleton)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAR_FROBNICATOR, foo_igen_bar_frobnicator_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenBarFrobnicatorSkeleton, foo_igen_bar_frobnicator_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAR_FROBNICATOR, foo_igen_bar_frobnicator_skeleton_iface_init));

#endif
static void
foo_igen_bar_frobnicator_skeleton_finalize (GObject *object)
{
  FooiGenBarFrobnicatorSkeleton *skeleton = FOO_IGEN_BAR_FROBNICATOR_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_bar_frobnicator_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_bar_frobnicator_skeleton_init (FooiGenBarFrobnicatorSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = foo_igen_bar_frobnicator_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_BAR_FROBNICATOR_SKELETON, FooiGenBarFrobnicatorSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
foo_igen_bar_frobnicator_skeleton_class_init (FooiGenBarFrobnicatorSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_bar_frobnicator_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_bar_frobnicator_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_bar_frobnicator_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_bar_frobnicator_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_bar_frobnicator_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenBarFrobnicatorSkeletonPrivate));
#endif
}

static void
foo_igen_bar_frobnicator_skeleton_iface_init (FooiGenBarFrobnicatorIface *iface)
{
}

/**
 * foo_igen_bar_frobnicator_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link>.
 *
 * Returns: (transfer full) (type FooiGenBarFrobnicatorSkeleton): The skeleton object.
 */
FooiGenBarFrobnicator *
foo_igen_bar_frobnicator_skeleton_new (void)
{
  return FOO_IGEN_BAR_FROBNICATOR (g_object_new (FOO_IGEN_TYPE_BAR_FROBNICATOR_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.project.Baz
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenBaz
 * @title: FooiGenBaz
 * @short_description: Generated C code for the org.project.Baz D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.project.Baz ---- */

static const _ExtendedGDBusInterfaceInfo _foo_igen_baz_interface_info =
{
  {
    -1,
    (gchar *) "org.project.Baz",
    NULL,
    NULL,
    NULL,
    NULL
  },
  "baz",
};


/**
 * foo_igen_baz_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_baz_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_baz_interface_info.parent_struct;
}

/**
 * foo_igen_baz_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenBaz interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_baz_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * FooiGenBaz:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link>.
 */

/**
 * FooiGenBazIface:
 * @parent_iface: The parent interface.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link>.
 */

typedef FooiGenBazIface FooiGenBazInterface;
G_DEFINE_INTERFACE (FooiGenBaz, foo_igen_baz, G_TYPE_OBJECT);

static void
foo_igen_baz_default_init (FooiGenBazIface *iface)
{
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenBazProxy:
 *
 * The #FooiGenBazProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenBazProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenBazProxy.
 */

struct _FooiGenBazProxyPrivate
{
  GData *qdata;
};

static void foo_igen_baz_proxy_iface_init (FooiGenBazIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenBazProxy, foo_igen_baz_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (FooiGenBazProxy)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAZ, foo_igen_baz_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenBazProxy, foo_igen_baz_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAZ, foo_igen_baz_proxy_iface_init));

#endif
static void
foo_igen_baz_proxy_finalize (GObject *object)
{
  FooiGenBazProxy *proxy = FOO_IGEN_BAZ_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_baz_proxy_parent_class)->finalize (object);
}

static void
foo_igen_baz_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
foo_igen_baz_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
foo_igen_baz_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_baz_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_BAZ);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_BAZ);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_baz_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenBazProxy *proxy = FOO_IGEN_BAZ_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_baz_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_baz_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_igen_baz_proxy_init (FooiGenBazProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = foo_igen_baz_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_BAZ_PROXY, FooiGenBazProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_baz_interface_info ());
}

static void
foo_igen_baz_proxy_class_init (FooiGenBazProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_baz_proxy_finalize;
  gobject_class->get_property = foo_igen_baz_proxy_get_property;
  gobject_class->set_property = foo_igen_baz_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_baz_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_baz_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenBazProxyPrivate));
#endif
}

static void
foo_igen_baz_proxy_iface_init (FooiGenBazIface *iface)
{
}

/**
 * foo_igen_baz_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_baz_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_baz_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_baz_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_BAZ_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Baz", NULL);
}

/**
 * foo_igen_baz_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_baz_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_baz_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenBazProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBaz *
foo_igen_baz_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_BAZ (ret);
  else
    return NULL;
}

/**
 * foo_igen_baz_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_baz_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenBazProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBaz *
foo_igen_baz_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_BAZ_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Baz", NULL);
  if (ret != NULL)
    return FOO_IGEN_BAZ (ret);
  else
    return NULL;
}


/**
 * foo_igen_baz_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_baz_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_baz_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_baz_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_baz_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_BAZ_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Baz", NULL);
}

/**
 * foo_igen_baz_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_baz_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_baz_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenBazProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBaz *
foo_igen_baz_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_BAZ (ret);
  else
    return NULL;
}

/**
 * foo_igen_baz_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_baz_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_baz_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenBazProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBaz *
foo_igen_baz_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_BAZ_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Baz", NULL);
  if (ret != NULL)
    return FOO_IGEN_BAZ (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenBazSkeleton:
 *
 * The #FooiGenBazSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenBazSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenBazSkeleton.
 */

struct _FooiGenBazSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_foo_igen_baz_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenBazSkeleton *skeleton = FOO_IGEN_BAZ_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_BAZ);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_BAZ);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_baz_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenBazSkeleton *skeleton = FOO_IGEN_BAZ_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_baz_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_baz_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenBazSkeleton *skeleton = FOO_IGEN_BAZ_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_baz_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_baz_skeleton_vtable =
{
  _foo_igen_baz_skeleton_handle_method_call,
  _foo_igen_baz_skeleton_handle_get_property,
  _foo_igen_baz_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
foo_igen_baz_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return foo_igen_baz_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_baz_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_foo_igen_baz_skeleton_vtable;
}

static GVariant *
foo_igen_baz_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenBazSkeleton *skeleton = FOO_IGEN_BAZ_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_baz_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_baz_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_baz_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_baz_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Baz", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
foo_igen_baz_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void foo_igen_baz_skeleton_iface_init (FooiGenBazIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenBazSkeleton, foo_igen_baz_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (FooiGenBazSkeleton)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAZ, foo_igen_baz_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenBazSkeleton, foo_igen_baz_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAZ, foo_igen_baz_skeleton_iface_init));

#endif
static void
foo_igen_baz_skeleton_finalize (GObject *object)
{
  FooiGenBazSkeleton *skeleton = FOO_IGEN_BAZ_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_baz_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_baz_skeleton_init (FooiGenBazSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = foo_igen_baz_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_BAZ_SKELETON, FooiGenBazSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
foo_igen_baz_skeleton_class_init (FooiGenBazSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_baz_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_baz_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_baz_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_baz_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_baz_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenBazSkeletonPrivate));
#endif
}

static void
foo_igen_baz_skeleton_iface_init (FooiGenBazIface *iface)
{
}

/**
 * foo_igen_baz_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link>.
 *
 * Returns: (transfer full) (type FooiGenBazSkeleton): The skeleton object.
 */
FooiGenBaz *
foo_igen_baz_skeleton_new (void)
{
  return FOO_IGEN_BAZ (g_object_new (FOO_IGEN_TYPE_BAZ_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface com.acme.Coyote
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenComAcmeCoyote
 * @title: FooiGenComAcmeCoyote
 * @short_description: Generated C code for the com.acme.Coyote D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link> D-Bus interface in C.
 */

/* ---- Introspection data for com.acme.Coyote ---- */

static const _ExtendedGDBusMethodInfo _foo_igen_com_acme_coyote_method_info_run =
{
  {
    -1,
    (gchar *) "Run",
    NULL,
    NULL,
    NULL
  },
  "handle-run",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_com_acme_coyote_method_info_sleep =
{
  {
    -1,
    (gchar *) "Sleep",
    NULL,
    NULL,
    NULL
  },
  "handle-sleep",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_com_acme_coyote_method_info_attack =
{
  {
    -1,
    (gchar *) "Attack",
    NULL,
    NULL,
    NULL
  },
  "handle-attack",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_com_acme_coyote_method_info_pointers[] =
{
  &_foo_igen_com_acme_coyote_method_info_run,
  &_foo_igen_com_acme_coyote_method_info_sleep,
  &_foo_igen_com_acme_coyote_method_info_attack,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_igen_com_acme_coyote_signal_info_surprised =
{
  {
    -1,
    (gchar *) "Surprised",
    NULL,
    NULL
  },
  "surprised"
};

static const _ExtendedGDBusSignalInfo * const _foo_igen_com_acme_coyote_signal_info_pointers[] =
{
  &_foo_igen_com_acme_coyote_signal_info_surprised,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_igen_com_acme_coyote_property_info_mood =
{
  {
    -1,
    (gchar *) "Mood",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "mood",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _foo_igen_com_acme_coyote_property_info_pointers[] =
{
  &_foo_igen_com_acme_coyote_property_info_mood,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_com_acme_coyote_interface_info =
{
  {
    -1,
    (gchar *) "com.acme.Coyote",
    (GDBusMethodInfo **) &_foo_igen_com_acme_coyote_method_info_pointers,
    (GDBusSignalInfo **) &_foo_igen_com_acme_coyote_signal_info_pointers,
    (GDBusPropertyInfo **) &_foo_igen_com_acme_coyote_property_info_pointers,
    NULL
  },
  "com-acme-coyote",
};


/**
 * foo_igen_com_acme_coyote_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_com_acme_coyote_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_com_acme_coyote_interface_info.parent_struct;
}

/**
 * foo_igen_com_acme_coyote_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenComAcmeCoyote interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_com_acme_coyote_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "mood");
  return property_id_begin - 1;
}



/**
 * FooiGenComAcmeCoyote:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link>.
 */

/**
 * FooiGenComAcmeCoyoteIface:
 * @parent_iface: The parent interface.
 * @handle_attack: Handler for the #FooiGenComAcmeCoyote::handle-attack signal.
 * @handle_run: Handler for the #FooiGenComAcmeCoyote::handle-run signal.
 * @handle_sleep: Handler for the #FooiGenComAcmeCoyote::handle-sleep signal.
 * @get_mood: Getter for the #FooiGenComAcmeCoyote:mood property.
 * @surprised: Handler for the #FooiGenComAcmeCoyote::surprised signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link>.
 */

typedef FooiGenComAcmeCoyoteIface FooiGenComAcmeCoyoteInterface;
G_DEFINE_INTERFACE (FooiGenComAcmeCoyote, foo_igen_com_acme_coyote, G_TYPE_OBJECT);

static void
foo_igen_com_acme_coyote_default_init (FooiGenComAcmeCoyoteIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenComAcmeCoyote::handle-run:
   * @object: A #FooiGenComAcmeCoyote.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-acme-Coyote.Run">Run()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_com_acme_coyote_complete_run() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-run",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenComAcmeCoyoteIface, handle_run),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooiGenComAcmeCoyote::handle-sleep:
   * @object: A #FooiGenComAcmeCoyote.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-acme-Coyote.Sleep">Sleep()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_com_acme_coyote_complete_sleep() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-sleep",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenComAcmeCoyoteIface, handle_sleep),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooiGenComAcmeCoyote::handle-attack:
   * @object: A #FooiGenComAcmeCoyote.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-acme-Coyote.Attack">Attack()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_com_acme_coyote_complete_attack() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-attack",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenComAcmeCoyoteIface, handle_attack),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooiGenComAcmeCoyote::surprised:
   * @object: A #FooiGenComAcmeCoyote.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-com-acme-Coyote.Surprised">"Surprised"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("surprised",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenComAcmeCoyoteIface, surprised),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /* GObject properties for D-Bus properties: */
  /**
   * FooiGenComAcmeCoyote:mood:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-com-acme-Coyote.Mood">"Mood"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("mood", "Mood", "Mood", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * foo_igen_com_acme_coyote_get_mood: (skip)
 * @object: A #FooiGenComAcmeCoyote.
 *
 * Gets the value of the <link linkend="gdbus-property-com-acme-Coyote.Mood">"Mood"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_com_acme_coyote_dup_mood() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_com_acme_coyote_get_mood (FooiGenComAcmeCoyote *object)
{
  return FOO_IGEN_COM_ACME_COYOTE_GET_IFACE (object)->get_mood (object);
}

/**
 * foo_igen_com_acme_coyote_dup_mood: (skip)
 * @object: A #FooiGenComAcmeCoyote.
 *
 * Gets a copy of the <link linkend="gdbus-property-com-acme-Coyote.Mood">"Mood"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_com_acme_coyote_dup_mood (FooiGenComAcmeCoyote *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "mood", &value, NULL);
  return value;
}

/**
 * foo_igen_com_acme_coyote_set_mood: (skip)
 * @object: A #FooiGenComAcmeCoyote.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-com-acme-Coyote.Mood">"Mood"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_igen_com_acme_coyote_set_mood (FooiGenComAcmeCoyote *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "mood", value, NULL);
}

/**
 * foo_igen_com_acme_coyote_emit_surprised:
 * @object: A #FooiGenComAcmeCoyote.
 *
 * Emits the <link linkend="gdbus-signal-com-acme-Coyote.Surprised">"Surprised"</link> D-Bus signal.
 */
void
foo_igen_com_acme_coyote_emit_surprised (
    FooiGenComAcmeCoyote *object)
{
  g_signal_emit_by_name (object, "surprised");
}

/**
 * foo_igen_com_acme_coyote_call_run:
 * @proxy: A #FooiGenComAcmeCoyoteProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-com-acme-Coyote.Run">Run()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_com_acme_coyote_call_run_finish() to get the result of the operation.
 *
 * See foo_igen_com_acme_coyote_call_run_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_com_acme_coyote_call_run (
    FooiGenComAcmeCoyote *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Run",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_com_acme_coyote_call_run_finish:
 * @proxy: A #FooiGenComAcmeCoyoteProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_com_acme_coyote_call_run().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_com_acme_coyote_call_run().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_com_acme_coyote_call_run_finish (
    FooiGenComAcmeCoyote *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_com_acme_coyote_call_run_sync:
 * @proxy: A #FooiGenComAcmeCoyoteProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-com-acme-Coyote.Run">Run()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_com_acme_coyote_call_run() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_com_acme_coyote_call_run_sync (
    FooiGenComAcmeCoyote *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Run",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_com_acme_coyote_call_sleep:
 * @proxy: A #FooiGenComAcmeCoyoteProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-com-acme-Coyote.Sleep">Sleep()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_com_acme_coyote_call_sleep_finish() to get the result of the operation.
 *
 * See foo_igen_com_acme_coyote_call_sleep_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_com_acme_coyote_call_sleep (
    FooiGenComAcmeCoyote *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Sleep",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_com_acme_coyote_call_sleep_finish:
 * @proxy: A #FooiGenComAcmeCoyoteProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_com_acme_coyote_call_sleep().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_com_acme_coyote_call_sleep().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_com_acme_coyote_call_sleep_finish (
    FooiGenComAcmeCoyote *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_com_acme_coyote_call_sleep_sync:
 * @proxy: A #FooiGenComAcmeCoyoteProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-com-acme-Coyote.Sleep">Sleep()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_com_acme_coyote_call_sleep() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_com_acme_coyote_call_sleep_sync (
    FooiGenComAcmeCoyote *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Sleep",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_com_acme_coyote_call_attack:
 * @proxy: A #FooiGenComAcmeCoyoteProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-com-acme-Coyote.Attack">Attack()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_com_acme_coyote_call_attack_finish() to get the result of the operation.
 *
 * See foo_igen_com_acme_coyote_call_attack_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_com_acme_coyote_call_attack (
    FooiGenComAcmeCoyote *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Attack",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_com_acme_coyote_call_attack_finish:
 * @proxy: A #FooiGenComAcmeCoyoteProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_com_acme_coyote_call_attack().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_com_acme_coyote_call_attack().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_com_acme_coyote_call_attack_finish (
    FooiGenComAcmeCoyote *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_com_acme_coyote_call_attack_sync:
 * @proxy: A #FooiGenComAcmeCoyoteProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-com-acme-Coyote.Attack">Attack()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_com_acme_coyote_call_attack() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_com_acme_coyote_call_attack_sync (
    FooiGenComAcmeCoyote *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Attack",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_com_acme_coyote_complete_run:
 * @object: A #FooiGenComAcmeCoyote.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-acme-Coyote.Run">Run()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_com_acme_coyote_complete_run (
    FooiGenComAcmeCoyote *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_com_acme_coyote_complete_sleep:
 * @object: A #FooiGenComAcmeCoyote.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-acme-Coyote.Sleep">Sleep()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_com_acme_coyote_complete_sleep (
    FooiGenComAcmeCoyote *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_com_acme_coyote_complete_attack:
 * @object: A #FooiGenComAcmeCoyote.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-acme-Coyote.Attack">Attack()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_com_acme_coyote_complete_attack (
    FooiGenComAcmeCoyote *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenComAcmeCoyoteProxy:
 *
 * The #FooiGenComAcmeCoyoteProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenComAcmeCoyoteProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenComAcmeCoyoteProxy.
 */

struct _FooiGenComAcmeCoyoteProxyPrivate
{
  GData *qdata;
};

static void foo_igen_com_acme_coyote_proxy_iface_init (FooiGenComAcmeCoyoteIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenComAcmeCoyoteProxy, foo_igen_com_acme_coyote_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (FooiGenComAcmeCoyoteProxy)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_COM_ACME_COYOTE, foo_igen_com_acme_coyote_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenComAcmeCoyoteProxy, foo_igen_com_acme_coyote_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_COM_ACME_COYOTE, foo_igen_com_acme_coyote_proxy_iface_init));

#endif
static void
foo_igen_com_acme_coyote_proxy_finalize (GObject *object)
{
  FooiGenComAcmeCoyoteProxy *proxy = FOO_IGEN_COM_ACME_COYOTE_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_com_acme_coyote_proxy_parent_class)->finalize (object);
}

static void
foo_igen_com_acme_coyote_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = _foo_igen_com_acme_coyote_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
foo_igen_com_acme_coyote_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface com.acme.Coyote: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
foo_igen_com_acme_coyote_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = _foo_igen_com_acme_coyote_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "com.acme.Coyote", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) foo_igen_com_acme_coyote_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
foo_igen_com_acme_coyote_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_com_acme_coyote_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_COM_ACME_COYOTE);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_COM_ACME_COYOTE);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_com_acme_coyote_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenComAcmeCoyoteProxy *proxy = FOO_IGEN_COM_ACME_COYOTE_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_com_acme_coyote_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_com_acme_coyote_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static const gchar *
foo_igen_com_acme_coyote_proxy_get_mood (FooiGenComAcmeCoyote *object)
{
  FooiGenComAcmeCoyoteProxy *proxy = FOO_IGEN_COM_ACME_COYOTE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Mood");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
foo_igen_com_acme_coyote_proxy_init (FooiGenComAcmeCoyoteProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = foo_igen_com_acme_coyote_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_COM_ACME_COYOTE_PROXY, FooiGenComAcmeCoyoteProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_com_acme_coyote_interface_info ());
}

static void
foo_igen_com_acme_coyote_proxy_class_init (FooiGenComAcmeCoyoteProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_com_acme_coyote_proxy_finalize;
  gobject_class->get_property = foo_igen_com_acme_coyote_proxy_get_property;
  gobject_class->set_property = foo_igen_com_acme_coyote_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_com_acme_coyote_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_com_acme_coyote_proxy_g_properties_changed;

  foo_igen_com_acme_coyote_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenComAcmeCoyoteProxyPrivate));
#endif
}

static void
foo_igen_com_acme_coyote_proxy_iface_init (FooiGenComAcmeCoyoteIface *iface)
{
  iface->get_mood = foo_igen_com_acme_coyote_proxy_get_mood;
}

/**
 * foo_igen_com_acme_coyote_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_com_acme_coyote_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_com_acme_coyote_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_com_acme_coyote_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_COM_ACME_COYOTE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "com.acme.Coyote", NULL);
}

/**
 * foo_igen_com_acme_coyote_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_com_acme_coyote_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_com_acme_coyote_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenComAcmeCoyoteProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenComAcmeCoyote *
foo_igen_com_acme_coyote_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_COM_ACME_COYOTE (ret);
  else
    return NULL;
}

/**
 * foo_igen_com_acme_coyote_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_com_acme_coyote_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenComAcmeCoyoteProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenComAcmeCoyote *
foo_igen_com_acme_coyote_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_COM_ACME_COYOTE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "com.acme.Coyote", NULL);
  if (ret != NULL)
    return FOO_IGEN_COM_ACME_COYOTE (ret);
  else
    return NULL;
}


/**
 * foo_igen_com_acme_coyote_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_com_acme_coyote_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_com_acme_coyote_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_com_acme_coyote_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_com_acme_coyote_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_COM_ACME_COYOTE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "com.acme.Coyote", NULL);
}

/**
 * foo_igen_com_acme_coyote_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_com_acme_coyote_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_com_acme_coyote_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenComAcmeCoyoteProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenComAcmeCoyote *
foo_igen_com_acme_coyote_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_COM_ACME_COYOTE (ret);
  else
    return NULL;
}

/**
 * foo_igen_com_acme_coyote_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_com_acme_coyote_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_com_acme_coyote_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenComAcmeCoyoteProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenComAcmeCoyote *
foo_igen_com_acme_coyote_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_COM_ACME_COYOTE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "com.acme.Coyote", NULL);
  if (ret != NULL)
    return FOO_IGEN_COM_ACME_COYOTE (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenComAcmeCoyoteSkeleton:
 *
 * The #FooiGenComAcmeCoyoteSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenComAcmeCoyoteSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenComAcmeCoyoteSkeleton.
 */

struct _FooiGenComAcmeCoyoteSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_foo_igen_com_acme_coyote_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_COM_ACME_COYOTE);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_COM_ACME_COYOTE);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_com_acme_coyote_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_com_acme_coyote_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_com_acme_coyote_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_com_acme_coyote_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_com_acme_coyote_skeleton_vtable =
{
  _foo_igen_com_acme_coyote_skeleton_handle_method_call,
  _foo_igen_com_acme_coyote_skeleton_handle_get_property,
  _foo_igen_com_acme_coyote_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
foo_igen_com_acme_coyote_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return foo_igen_com_acme_coyote_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_com_acme_coyote_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_foo_igen_com_acme_coyote_skeleton_vtable;
}

static GVariant *
foo_igen_com_acme_coyote_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_com_acme_coyote_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_com_acme_coyote_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_com_acme_coyote_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_com_acme_coyote_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "com.acme.Coyote", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _foo_igen_com_acme_coyote_emit_changed (gpointer user_data);

static void
foo_igen_com_acme_coyote_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _foo_igen_com_acme_coyote_emit_changed (skeleton);
}

static void
_foo_igen_com_acme_coyote_on_signal_surprised (
    FooiGenComAcmeCoyote *object)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "com.acme.Coyote", "Surprised",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void foo_igen_com_acme_coyote_skeleton_iface_init (FooiGenComAcmeCoyoteIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenComAcmeCoyoteSkeleton, foo_igen_com_acme_coyote_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (FooiGenComAcmeCoyoteSkeleton)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_COM_ACME_COYOTE, foo_igen_com_acme_coyote_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenComAcmeCoyoteSkeleton, foo_igen_com_acme_coyote_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_COM_ACME_COYOTE, foo_igen_com_acme_coyote_skeleton_iface_init));

#endif
static void
foo_igen_com_acme_coyote_skeleton_finalize (GObject *object)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (object);
  guint n;
  for (n = 0; n < 1; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_com_acme_coyote_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_com_acme_coyote_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_foo_igen_com_acme_coyote_emit_changed (gpointer user_data)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "com.acme.Coyote",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_foo_igen_com_acme_coyote_schedule_emit_changed (FooiGenComAcmeCoyoteSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
foo_igen_com_acme_coyote_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _foo_igen_com_acme_coyote_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _foo_igen_com_acme_coyote_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
foo_igen_com_acme_coyote_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _foo_igen_com_acme_coyote_schedule_emit_changed (skeleton, _foo_igen_com_acme_coyote_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
foo_igen_com_acme_coyote_skeleton_init (FooiGenComAcmeCoyoteSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = foo_igen_com_acme_coyote_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_COM_ACME_COYOTE_SKELETON, FooiGenComAcmeCoyoteSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 1);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_STRING);
}

static const gchar *
foo_igen_com_acme_coyote_skeleton_get_mood (FooiGenComAcmeCoyote *object)
{
  FooiGenComAcmeCoyoteSkeleton *skeleton = FOO_IGEN_COM_ACME_COYOTE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
foo_igen_com_acme_coyote_skeleton_class_init (FooiGenComAcmeCoyoteSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_com_acme_coyote_skeleton_finalize;
  gobject_class->get_property = foo_igen_com_acme_coyote_skeleton_get_property;
  gobject_class->set_property = foo_igen_com_acme_coyote_skeleton_set_property;
  gobject_class->notify       = foo_igen_com_acme_coyote_skeleton_notify;


  foo_igen_com_acme_coyote_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_com_acme_coyote_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_com_acme_coyote_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_com_acme_coyote_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_com_acme_coyote_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenComAcmeCoyoteSkeletonPrivate));
#endif
}

static void
foo_igen_com_acme_coyote_skeleton_iface_init (FooiGenComAcmeCoyoteIface *iface)
{
  iface->surprised = _foo_igen_com_acme_coyote_on_signal_surprised;
  iface->get_mood = foo_igen_com_acme_coyote_skeleton_get_mood;
}

/**
 * foo_igen_com_acme_coyote_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link>.
 *
 * Returns: (transfer full) (type FooiGenComAcmeCoyoteSkeleton): The skeleton object.
 */
FooiGenComAcmeCoyote *
foo_igen_com_acme_coyote_skeleton_new (void)
{
  return FOO_IGEN_COM_ACME_COYOTE (g_object_new (FOO_IGEN_TYPE_COM_ACME_COYOTE_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface com.acme.Rocket
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenRocket123
 * @title: FooiGenRocket123
 * @short_description: Generated C code for the com.acme.Rocket D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link> D-Bus interface in C.
 */

/* ---- Introspection data for com.acme.Rocket ---- */

static const _ExtendedGDBusMethodInfo _foo_igen_rocket123_method_info_ignite_xyz =
{
  {
    -1,
    (gchar *) "Ignite",
    NULL,
    NULL,
    NULL
  },
  "handle-ignite-xyz",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_rocket123_method_info_pointers[] =
{
  &_foo_igen_rocket123_method_info_ignite_xyz,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_igen_rocket123_signal_info_exploded_xyz =
{
  {
    -1,
    (gchar *) "Exploded",
    NULL,
    NULL
  },
  "exploded-xyz"
};

static const _ExtendedGDBusSignalInfo * const _foo_igen_rocket123_signal_info_pointers[] =
{
  &_foo_igen_rocket123_signal_info_exploded_xyz,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_igen_rocket123_property_info_speed_xyz =
{
  {
    -1,
    (gchar *) "Speed",
    (gchar *) "d",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "speed-xyz",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_rocket123_property_info_direction =
{
  {
    -1,
    (gchar *) "Direction",
    (gchar *) "(ddd)",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "direction",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_rocket123_property_info_type_ =
{
  {
    -1,
    (gchar *) "Type",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "type",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _foo_igen_rocket123_property_info_pointers[] =
{
  &_foo_igen_rocket123_property_info_speed_xyz,
  &_foo_igen_rocket123_property_info_direction,
  &_foo_igen_rocket123_property_info_type_,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_rocket123_interface_info =
{
  {
    -1,
    (gchar *) "com.acme.Rocket",
    (GDBusMethodInfo **) &_foo_igen_rocket123_method_info_pointers,
    (GDBusSignalInfo **) &_foo_igen_rocket123_signal_info_pointers,
    (GDBusPropertyInfo **) &_foo_igen_rocket123_property_info_pointers,
    NULL
  },
  "rocket123",
};


/**
 * foo_igen_rocket123_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_rocket123_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_rocket123_interface_info.parent_struct;
}

/**
 * foo_igen_rocket123_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenRocket123 interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_rocket123_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "speed-xyz");
  g_object_class_override_property (klass, property_id_begin++, "direction");
  g_object_class_override_property (klass, property_id_begin++, "type");
  return property_id_begin - 1;
}



/**
 * FooiGenRocket123:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link>.
 */

/**
 * FooiGenRocket123Iface:
 * @parent_iface: The parent interface.
 * @handle_ignite_xyz: Handler for the #FooiGenRocket123::handle-ignite-xyz signal.
 * @get_direction: Getter for the #FooiGenRocket123:direction property.
 * @get_speed_xyz: Getter for the #FooiGenRocket123:speed-xyz property.
 * @get_type_: Getter for the #FooiGenRocket123:type property.
 * @exploded_xyz: Handler for the #FooiGenRocket123::exploded-xyz signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link>.
 */

typedef FooiGenRocket123Iface FooiGenRocket123Interface;
G_DEFINE_INTERFACE (FooiGenRocket123, foo_igen_rocket123, G_TYPE_OBJECT);

static void
foo_igen_rocket123_default_init (FooiGenRocket123Iface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenRocket123::handle-ignite-xyz:
   * @object: A #FooiGenRocket123.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-acme-Rocket.Ignite">Ignite()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_rocket123_complete_ignite_xyz() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-ignite-xyz",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenRocket123Iface, handle_ignite_xyz),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooiGenRocket123::exploded-xyz:
   * @object: A #FooiGenRocket123.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-com-acme-Rocket.Exploded">"Exploded"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("exploded-xyz",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenRocket123Iface, exploded_xyz),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /* GObject properties for D-Bus properties: */
  /**
   * FooiGenRocket123:speed-xyz:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-com-acme-Rocket.Speed">"Speed"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_double ("speed-xyz", "Speed", "Speed", -G_MAXDOUBLE, G_MAXDOUBLE, 0.0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenRocket123:direction:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-com-acme-Rocket.Direction">"Direction"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("direction", "Direction", "Direction", G_VARIANT_TYPE ("(ddd)"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenRocket123:type:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-com-acme-Rocket.Type">"Type"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("type", "Type", "Type", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * foo_igen_rocket123_get_speed_xyz: (skip)
 * @object: A #FooiGenRocket123.
 *
 * Gets the value of the <link linkend="gdbus-property-com-acme-Rocket.Speed">"Speed"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gdouble 
foo_igen_rocket123_get_speed_xyz (FooiGenRocket123 *object)
{
  return FOO_IGEN_ROCKET123_GET_IFACE (object)->get_speed_xyz (object);
}

/**
 * foo_igen_rocket123_set_speed_xyz: (skip)
 * @object: A #FooiGenRocket123.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-com-acme-Rocket.Speed">"Speed"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_igen_rocket123_set_speed_xyz (FooiGenRocket123 *object, gdouble value)
{
  g_object_set (G_OBJECT (object), "speed-xyz", value, NULL);
}

/**
 * foo_igen_rocket123_get_direction: (skip)
 * @object: A #FooiGenRocket123.
 *
 * Gets the value of the <link linkend="gdbus-property-com-acme-Rocket.Direction">"Direction"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_rocket123_dup_direction() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
foo_igen_rocket123_get_direction (FooiGenRocket123 *object)
{
  return FOO_IGEN_ROCKET123_GET_IFACE (object)->get_direction (object);
}

/**
 * foo_igen_rocket123_dup_direction: (skip)
 * @object: A #FooiGenRocket123.
 *
 * Gets a copy of the <link linkend="gdbus-property-com-acme-Rocket.Direction">"Direction"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
foo_igen_rocket123_dup_direction (FooiGenRocket123 *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "direction", &value, NULL);
  return value;
}

/**
 * foo_igen_rocket123_set_direction: (skip)
 * @object: A #FooiGenRocket123.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-com-acme-Rocket.Direction">"Direction"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_igen_rocket123_set_direction (FooiGenRocket123 *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "direction", value, NULL);
}

/**
 * foo_igen_rocket123_get_type_: (skip)
 * @object: A #FooiGenRocket123.
 *
 * Gets the value of the <link linkend="gdbus-property-com-acme-Rocket.Type">"Type"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_rocket123_dup_type_() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_rocket123_get_type_ (FooiGenRocket123 *object)
{
  return FOO_IGEN_ROCKET123_GET_IFACE (object)->get_type_ (object);
}

/**
 * foo_igen_rocket123_dup_type_: (skip)
 * @object: A #FooiGenRocket123.
 *
 * Gets a copy of the <link linkend="gdbus-property-com-acme-Rocket.Type">"Type"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_rocket123_dup_type_ (FooiGenRocket123 *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "type", &value, NULL);
  return value;
}

/**
 * foo_igen_rocket123_set_type_: (skip)
 * @object: A #FooiGenRocket123.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-com-acme-Rocket.Type">"Type"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_igen_rocket123_set_type_ (FooiGenRocket123 *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "type", value, NULL);
}

/**
 * foo_igen_rocket123_emit_exploded_xyz:
 * @object: A #FooiGenRocket123.
 *
 * Emits the <link linkend="gdbus-signal-com-acme-Rocket.Exploded">"Exploded"</link> D-Bus signal.
 */
void
foo_igen_rocket123_emit_exploded_xyz (
    FooiGenRocket123 *object)
{
  g_signal_emit_by_name (object, "exploded-xyz");
}

/**
 * foo_igen_rocket123_call_ignite_xyz:
 * @proxy: A #FooiGenRocket123Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-com-acme-Rocket.Ignite">Ignite()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_rocket123_call_ignite_xyz_finish() to get the result of the operation.
 *
 * See foo_igen_rocket123_call_ignite_xyz_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_rocket123_call_ignite_xyz (
    FooiGenRocket123 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Ignite",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_rocket123_call_ignite_xyz_finish:
 * @proxy: A #FooiGenRocket123Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_rocket123_call_ignite_xyz().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_rocket123_call_ignite_xyz().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_rocket123_call_ignite_xyz_finish (
    FooiGenRocket123 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_rocket123_call_ignite_xyz_sync:
 * @proxy: A #FooiGenRocket123Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-com-acme-Rocket.Ignite">Ignite()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_rocket123_call_ignite_xyz() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_rocket123_call_ignite_xyz_sync (
    FooiGenRocket123 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Ignite",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_rocket123_complete_ignite_xyz:
 * @object: A #FooiGenRocket123.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-acme-Rocket.Ignite">Ignite()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_rocket123_complete_ignite_xyz (
    FooiGenRocket123 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenRocket123Proxy:
 *
 * The #FooiGenRocket123Proxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenRocket123ProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenRocket123Proxy.
 */

struct _FooiGenRocket123ProxyPrivate
{
  GData *qdata;
};

static void foo_igen_rocket123_proxy_iface_init (FooiGenRocket123Iface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenRocket123Proxy, foo_igen_rocket123_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (FooiGenRocket123Proxy)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_ROCKET123, foo_igen_rocket123_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenRocket123Proxy, foo_igen_rocket123_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_ROCKET123, foo_igen_rocket123_proxy_iface_init));

#endif
static void
foo_igen_rocket123_proxy_finalize (GObject *object)
{
  FooiGenRocket123Proxy *proxy = FOO_IGEN_ROCKET123_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_rocket123_proxy_parent_class)->finalize (object);
}

static void
foo_igen_rocket123_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  info = _foo_igen_rocket123_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
foo_igen_rocket123_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface com.acme.Rocket: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
foo_igen_rocket123_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  info = _foo_igen_rocket123_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "com.acme.Rocket", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) foo_igen_rocket123_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
foo_igen_rocket123_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_rocket123_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_ROCKET123);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_ROCKET123);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_rocket123_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenRocket123Proxy *proxy = FOO_IGEN_ROCKET123_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_rocket123_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_rocket123_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static gdouble 
foo_igen_rocket123_proxy_get_speed_xyz (FooiGenRocket123 *object)
{
  FooiGenRocket123Proxy *proxy = FOO_IGEN_ROCKET123_PROXY (object);
  GVariant *variant;
  gdouble value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Speed");
  if (variant != NULL)
    {
      value = g_variant_get_double (variant);
      g_variant_unref (variant);
    }
  return value;
}

static GVariant *
foo_igen_rocket123_proxy_get_direction (FooiGenRocket123 *object)
{
  FooiGenRocket123Proxy *proxy = FOO_IGEN_ROCKET123_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Direction");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static const gchar *
foo_igen_rocket123_proxy_get_type_ (FooiGenRocket123 *object)
{
  FooiGenRocket123Proxy *proxy = FOO_IGEN_ROCKET123_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Type");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
foo_igen_rocket123_proxy_init (FooiGenRocket123Proxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = foo_igen_rocket123_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_ROCKET123_PROXY, FooiGenRocket123ProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_rocket123_interface_info ());
}

static void
foo_igen_rocket123_proxy_class_init (FooiGenRocket123ProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_rocket123_proxy_finalize;
  gobject_class->get_property = foo_igen_rocket123_proxy_get_property;
  gobject_class->set_property = foo_igen_rocket123_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_rocket123_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_rocket123_proxy_g_properties_changed;

  foo_igen_rocket123_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenRocket123ProxyPrivate));
#endif
}

static void
foo_igen_rocket123_proxy_iface_init (FooiGenRocket123Iface *iface)
{
  iface->get_speed_xyz = foo_igen_rocket123_proxy_get_speed_xyz;
  iface->get_direction = foo_igen_rocket123_proxy_get_direction;
  iface->get_type_ = foo_igen_rocket123_proxy_get_type_;
}

/**
 * foo_igen_rocket123_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_rocket123_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_rocket123_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_rocket123_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_ROCKET123_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "com.acme.Rocket", NULL);
}

/**
 * foo_igen_rocket123_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_rocket123_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_rocket123_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenRocket123Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenRocket123 *
foo_igen_rocket123_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_ROCKET123 (ret);
  else
    return NULL;
}

/**
 * foo_igen_rocket123_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_rocket123_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenRocket123Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenRocket123 *
foo_igen_rocket123_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_ROCKET123_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "com.acme.Rocket", NULL);
  if (ret != NULL)
    return FOO_IGEN_ROCKET123 (ret);
  else
    return NULL;
}


/**
 * foo_igen_rocket123_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_rocket123_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_rocket123_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_rocket123_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_rocket123_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_ROCKET123_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "com.acme.Rocket", NULL);
}

/**
 * foo_igen_rocket123_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_rocket123_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_rocket123_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenRocket123Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenRocket123 *
foo_igen_rocket123_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_ROCKET123 (ret);
  else
    return NULL;
}

/**
 * foo_igen_rocket123_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_rocket123_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_rocket123_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenRocket123Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenRocket123 *
foo_igen_rocket123_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_ROCKET123_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "com.acme.Rocket", NULL);
  if (ret != NULL)
    return FOO_IGEN_ROCKET123 (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenRocket123Skeleton:
 *
 * The #FooiGenRocket123Skeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenRocket123SkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenRocket123Skeleton.
 */

struct _FooiGenRocket123SkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_foo_igen_rocket123_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_ROCKET123);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_ROCKET123);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_rocket123_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_rocket123_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_rocket123_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_rocket123_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_rocket123_skeleton_vtable =
{
  _foo_igen_rocket123_skeleton_handle_method_call,
  _foo_igen_rocket123_skeleton_handle_get_property,
  _foo_igen_rocket123_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
foo_igen_rocket123_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return foo_igen_rocket123_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_rocket123_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_foo_igen_rocket123_skeleton_vtable;
}

static GVariant *
foo_igen_rocket123_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_rocket123_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_rocket123_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_rocket123_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_rocket123_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "com.acme.Rocket", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _foo_igen_rocket123_emit_changed (gpointer user_data);

static void
foo_igen_rocket123_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _foo_igen_rocket123_emit_changed (skeleton);
}

static void
_foo_igen_rocket123_on_signal_exploded_xyz (
    FooiGenRocket123 *object)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "com.acme.Rocket", "Exploded",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void foo_igen_rocket123_skeleton_iface_init (FooiGenRocket123Iface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenRocket123Skeleton, foo_igen_rocket123_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (FooiGenRocket123Skeleton)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_ROCKET123, foo_igen_rocket123_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenRocket123Skeleton, foo_igen_rocket123_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_ROCKET123, foo_igen_rocket123_skeleton_iface_init));

#endif
static void
foo_igen_rocket123_skeleton_finalize (GObject *object)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (object);
  guint n;
  for (n = 0; n < 3; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_rocket123_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_rocket123_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_foo_igen_rocket123_emit_changed (gpointer user_data)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "com.acme.Rocket",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_foo_igen_rocket123_schedule_emit_changed (FooiGenRocket123Skeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
foo_igen_rocket123_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _foo_igen_rocket123_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _foo_igen_rocket123_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
foo_igen_rocket123_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _foo_igen_rocket123_schedule_emit_changed (skeleton, _foo_igen_rocket123_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
foo_igen_rocket123_skeleton_init (FooiGenRocket123Skeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = foo_igen_rocket123_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_ROCKET123_SKELETON, FooiGenRocket123SkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 3);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_DOUBLE);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_VARIANT);
  g_value_init (&skeleton->priv->properties[2], G_TYPE_STRING);
}

static gdouble 
foo_igen_rocket123_skeleton_get_speed_xyz (FooiGenRocket123 *object)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (object);
  gdouble value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_double (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static GVariant *
foo_igen_rocket123_skeleton_get_direction (FooiGenRocket123 *object)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (object);
  GVariant *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_rocket123_skeleton_get_type_ (FooiGenRocket123 *object)
{
  FooiGenRocket123Skeleton *skeleton = FOO_IGEN_ROCKET123_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[2]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
foo_igen_rocket123_skeleton_class_init (FooiGenRocket123SkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_rocket123_skeleton_finalize;
  gobject_class->get_property = foo_igen_rocket123_skeleton_get_property;
  gobject_class->set_property = foo_igen_rocket123_skeleton_set_property;
  gobject_class->notify       = foo_igen_rocket123_skeleton_notify;


  foo_igen_rocket123_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_rocket123_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_rocket123_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_rocket123_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_rocket123_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenRocket123SkeletonPrivate));
#endif
}

static void
foo_igen_rocket123_skeleton_iface_init (FooiGenRocket123Iface *iface)
{
  iface->exploded_xyz = _foo_igen_rocket123_on_signal_exploded_xyz;
  iface->get_speed_xyz = foo_igen_rocket123_skeleton_get_speed_xyz;
  iface->get_direction = foo_igen_rocket123_skeleton_get_direction;
  iface->get_type_ = foo_igen_rocket123_skeleton_get_type_;
}

/**
 * foo_igen_rocket123_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link>.
 *
 * Returns: (transfer full) (type FooiGenRocket123Skeleton): The skeleton object.
 */
FooiGenRocket123 *
foo_igen_rocket123_skeleton_new (void)
{
  return FOO_IGEN_ROCKET123 (g_object_new (FOO_IGEN_TYPE_ROCKET123_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.project.Bat
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenBat
 * @title: FooiGenBat
 * @short_description: Generated C code for the org.project.Bat D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.project.Bat ---- */

static const _ExtendedGDBusArgInfo _foo_igen_bat_method_info_force_method_IN_ARG_force_in_i =
{
  {
    -1,
    (gchar *) "force_in_i",
    (gchar *) "i",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_igen_bat_method_info_force_method_IN_ARG_force_in_s =
{
  {
    -1,
    (gchar *) "force_in_s",
    (gchar *) "s",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_igen_bat_method_info_force_method_IN_ARG_force_in_ay =
{
  {
    -1,
    (gchar *) "force_in_ay",
    (gchar *) "ay",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_igen_bat_method_info_force_method_IN_ARG_force_in_struct =
{
  {
    -1,
    (gchar *) "force_in_struct",
    (gchar *) "(i)",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bat_method_info_force_method_IN_ARG_pointers[] =
{
  &_foo_igen_bat_method_info_force_method_IN_ARG_force_in_i,
  &_foo_igen_bat_method_info_force_method_IN_ARG_force_in_s,
  &_foo_igen_bat_method_info_force_method_IN_ARG_force_in_ay,
  &_foo_igen_bat_method_info_force_method_IN_ARG_force_in_struct,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_bat_method_info_force_method_OUT_ARG_force_out_i =
{
  {
    -1,
    (gchar *) "force_out_i",
    (gchar *) "i",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_igen_bat_method_info_force_method_OUT_ARG_force_out_s =
{
  {
    -1,
    (gchar *) "force_out_s",
    (gchar *) "s",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_igen_bat_method_info_force_method_OUT_ARG_force_out_ay =
{
  {
    -1,
    (gchar *) "force_out_ay",
    (gchar *) "ay",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_igen_bat_method_info_force_method_OUT_ARG_force_out_struct =
{
  {
    -1,
    (gchar *) "force_out_struct",
    (gchar *) "(i)",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bat_method_info_force_method_OUT_ARG_pointers[] =
{
  &_foo_igen_bat_method_info_force_method_OUT_ARG_force_out_i,
  &_foo_igen_bat_method_info_force_method_OUT_ARG_force_out_s,
  &_foo_igen_bat_method_info_force_method_OUT_ARG_force_out_ay,
  &_foo_igen_bat_method_info_force_method_OUT_ARG_force_out_struct,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_igen_bat_method_info_force_method =
{
  {
    -1,
    (gchar *) "ForceMethod",
    (GDBusArgInfo **) &_foo_igen_bat_method_info_force_method_IN_ARG_pointers,
    (GDBusArgInfo **) &_foo_igen_bat_method_info_force_method_OUT_ARG_pointers,
    NULL
  },
  "handle-force-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_bat_method_info_pointers[] =
{
  &_foo_igen_bat_method_info_force_method,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_bat_signal_info_force_signal_ARG_force_i =
{
  {
    -1,
    (gchar *) "force_i",
    (gchar *) "i",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_igen_bat_signal_info_force_signal_ARG_force_s =
{
  {
    -1,
    (gchar *) "force_s",
    (gchar *) "s",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_igen_bat_signal_info_force_signal_ARG_force_ay =
{
  {
    -1,
    (gchar *) "force_ay",
    (gchar *) "ay",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_igen_bat_signal_info_force_signal_ARG_force_struct =
{
  {
    -1,
    (gchar *) "force_struct",
    (gchar *) "(i)",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_bat_signal_info_force_signal_ARG_pointers[] =
{
  &_foo_igen_bat_signal_info_force_signal_ARG_force_i,
  &_foo_igen_bat_signal_info_force_signal_ARG_force_s,
  &_foo_igen_bat_signal_info_force_signal_ARG_force_ay,
  &_foo_igen_bat_signal_info_force_signal_ARG_force_struct,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_igen_bat_signal_info_force_signal =
{
  {
    -1,
    (gchar *) "ForceSignal",
    (GDBusArgInfo **) &_foo_igen_bat_signal_info_force_signal_ARG_pointers,
    NULL
  },
  "force-signal"
};

static const _ExtendedGDBusSignalInfo * const _foo_igen_bat_signal_info_pointers[] =
{
  &_foo_igen_bat_signal_info_force_signal,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bat_property_info_force_i =
{
  {
    -1,
    (gchar *) "force_i",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "force-i",
  TRUE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bat_property_info_force_s =
{
  {
    -1,
    (gchar *) "force_s",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "force-s",
  TRUE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bat_property_info_force_ay =
{
  {
    -1,
    (gchar *) "force_ay",
    (gchar *) "ay",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "force-ay",
  TRUE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_bat_property_info_force_struct =
{
  {
    -1,
    (gchar *) "force_struct",
    (gchar *) "(i)",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "force-struct",
  TRUE
};

static const _ExtendedGDBusPropertyInfo * const _foo_igen_bat_property_info_pointers[] =
{
  &_foo_igen_bat_property_info_force_i,
  &_foo_igen_bat_property_info_force_s,
  &_foo_igen_bat_property_info_force_ay,
  &_foo_igen_bat_property_info_force_struct,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_bat_interface_info =
{
  {
    -1,
    (gchar *) "org.project.Bat",
    (GDBusMethodInfo **) &_foo_igen_bat_method_info_pointers,
    (GDBusSignalInfo **) &_foo_igen_bat_signal_info_pointers,
    (GDBusPropertyInfo **) &_foo_igen_bat_property_info_pointers,
    NULL
  },
  "bat",
};


/**
 * foo_igen_bat_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_bat_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_bat_interface_info.parent_struct;
}

/**
 * foo_igen_bat_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenBat interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_bat_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "force-i");
  g_object_class_override_property (klass, property_id_begin++, "force-s");
  g_object_class_override_property (klass, property_id_begin++, "force-ay");
  g_object_class_override_property (klass, property_id_begin++, "force-struct");
  return property_id_begin - 1;
}



/**
 * FooiGenBat:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link>.
 */

/**
 * FooiGenBatIface:
 * @parent_iface: The parent interface.
 * @handle_force_method: Handler for the #FooiGenBat::handle-force-method signal.
 * @get_force_ay: Getter for the #FooiGenBat:force-ay property.
 * @get_force_i: Getter for the #FooiGenBat:force-i property.
 * @get_force_s: Getter for the #FooiGenBat:force-s property.
 * @get_force_struct: Getter for the #FooiGenBat:force-struct property.
 * @force_signal: Handler for the #FooiGenBat::force-signal signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link>.
 */

typedef FooiGenBatIface FooiGenBatInterface;
G_DEFINE_INTERFACE (FooiGenBat, foo_igen_bat, G_TYPE_OBJECT);

static void
foo_igen_bat_default_init (FooiGenBatIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenBat::handle-force-method:
   * @object: A #FooiGenBat.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_force_in_i: Argument passed by remote caller.
   * @arg_force_in_s: Argument passed by remote caller.
   * @arg_force_in_ay: Argument passed by remote caller.
   * @arg_force_in_struct: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bat.ForceMethod">ForceMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_bat_complete_force_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-force-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBatIface, handle_force_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    5,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT, G_TYPE_VARIANT, G_TYPE_VARIANT, G_TYPE_VARIANT);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooiGenBat::force-signal:
   * @object: A #FooiGenBat.
   * @arg_force_i: Argument.
   * @arg_force_s: Argument.
   * @arg_force_ay: Argument.
   * @arg_force_struct: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-project-Bat.ForceSignal">"ForceSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("force-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenBatIface, force_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    4, G_TYPE_VARIANT, G_TYPE_VARIANT, G_TYPE_VARIANT, G_TYPE_VARIANT);

  /* GObject properties for D-Bus properties: */
  /**
   * FooiGenBat:force-i:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bat.force_i">"force_i"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("force-i", "force_i", "force_i", G_VARIANT_TYPE ("i"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBat:force-s:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bat.force_s">"force_s"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("force-s", "force_s", "force_s", G_VARIANT_TYPE ("s"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBat:force-ay:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bat.force_ay">"force_ay"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("force-ay", "force_ay", "force_ay", G_VARIANT_TYPE ("ay"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenBat:force-struct:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bat.force_struct">"force_struct"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("force-struct", "force_struct", "force_struct", G_VARIANT_TYPE ("(i)"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * foo_igen_bat_get_force_i: (skip)
 * @object: A #FooiGenBat.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bat.force_i">"force_i"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bat_dup_force_i() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
foo_igen_bat_get_force_i (FooiGenBat *object)
{
  return FOO_IGEN_BAT_GET_IFACE (object)->get_force_i (object);
}

/**
 * foo_igen_bat_dup_force_i: (skip)
 * @object: A #FooiGenBat.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bat.force_i">"force_i"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
foo_igen_bat_dup_force_i (FooiGenBat *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "force-i", &value, NULL);
  return value;
}

/**
 * foo_igen_bat_set_force_i: (skip)
 * @object: A #FooiGenBat.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bat.force_i">"force_i"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bat_set_force_i (FooiGenBat *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "force-i", value, NULL);
}

/**
 * foo_igen_bat_get_force_s: (skip)
 * @object: A #FooiGenBat.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bat.force_s">"force_s"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bat_dup_force_s() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
foo_igen_bat_get_force_s (FooiGenBat *object)
{
  return FOO_IGEN_BAT_GET_IFACE (object)->get_force_s (object);
}

/**
 * foo_igen_bat_dup_force_s: (skip)
 * @object: A #FooiGenBat.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bat.force_s">"force_s"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
foo_igen_bat_dup_force_s (FooiGenBat *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "force-s", &value, NULL);
  return value;
}

/**
 * foo_igen_bat_set_force_s: (skip)
 * @object: A #FooiGenBat.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bat.force_s">"force_s"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bat_set_force_s (FooiGenBat *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "force-s", value, NULL);
}

/**
 * foo_igen_bat_get_force_ay: (skip)
 * @object: A #FooiGenBat.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bat.force_ay">"force_ay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bat_dup_force_ay() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
foo_igen_bat_get_force_ay (FooiGenBat *object)
{
  return FOO_IGEN_BAT_GET_IFACE (object)->get_force_ay (object);
}

/**
 * foo_igen_bat_dup_force_ay: (skip)
 * @object: A #FooiGenBat.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bat.force_ay">"force_ay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
foo_igen_bat_dup_force_ay (FooiGenBat *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "force-ay", &value, NULL);
  return value;
}

/**
 * foo_igen_bat_set_force_ay: (skip)
 * @object: A #FooiGenBat.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bat.force_ay">"force_ay"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bat_set_force_ay (FooiGenBat *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "force-ay", value, NULL);
}

/**
 * foo_igen_bat_get_force_struct: (skip)
 * @object: A #FooiGenBat.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bat.force_struct">"force_struct"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_bat_dup_force_struct() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
foo_igen_bat_get_force_struct (FooiGenBat *object)
{
  return FOO_IGEN_BAT_GET_IFACE (object)->get_force_struct (object);
}

/**
 * foo_igen_bat_dup_force_struct: (skip)
 * @object: A #FooiGenBat.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-Bat.force_struct">"force_struct"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
foo_igen_bat_dup_force_struct (FooiGenBat *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "force-struct", &value, NULL);
  return value;
}

/**
 * foo_igen_bat_set_force_struct: (skip)
 * @object: A #FooiGenBat.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bat.force_struct">"force_struct"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_bat_set_force_struct (FooiGenBat *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "force-struct", value, NULL);
}

/**
 * foo_igen_bat_emit_force_signal:
 * @object: A #FooiGenBat.
 * @arg_force_i: Argument to pass with the signal.
 * @arg_force_s: Argument to pass with the signal.
 * @arg_force_ay: Argument to pass with the signal.
 * @arg_force_struct: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-project-Bat.ForceSignal">"ForceSignal"</link> D-Bus signal.
 */
void
foo_igen_bat_emit_force_signal (
    FooiGenBat *object,
    GVariant *arg_force_i,
    GVariant *arg_force_s,
    GVariant *arg_force_ay,
    GVariant *arg_force_struct)
{
  g_signal_emit_by_name (object, "force-signal", arg_force_i, arg_force_s, arg_force_ay, arg_force_struct);
}

/**
 * foo_igen_bat_call_force_method:
 * @proxy: A #FooiGenBatProxy.
 * @arg_force_in_i: Argument to pass with the method invocation.
 * @arg_force_in_s: Argument to pass with the method invocation.
 * @arg_force_in_ay: Argument to pass with the method invocation.
 * @arg_force_in_struct: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bat.ForceMethod">ForceMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bat_call_force_method_finish() to get the result of the operation.
 *
 * See foo_igen_bat_call_force_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_bat_call_force_method (
    FooiGenBat *proxy,
    GVariant *arg_force_in_i,
    GVariant *arg_force_in_s,
    GVariant *arg_force_in_ay,
    GVariant *arg_force_in_struct,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "ForceMethod",
    g_variant_new ("(@i@s@ay@(i))",
                   arg_force_in_i,
                   arg_force_in_s,
                   arg_force_in_ay,
                   arg_force_in_struct),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_bat_call_force_method_finish:
 * @proxy: A #FooiGenBatProxy.
 * @out_force_out_i: (out): Return location for return parameter or %NULL to ignore.
 * @out_force_out_s: (out): Return location for return parameter or %NULL to ignore.
 * @out_force_out_ay: (out): Return location for return parameter or %NULL to ignore.
 * @out_force_out_struct: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bat_call_force_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_bat_call_force_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bat_call_force_method_finish (
    FooiGenBat *proxy,
    GVariant **out_force_out_i,
    GVariant **out_force_out_s,
    GVariant **out_force_out_ay,
    GVariant **out_force_out_struct,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(@i@s@ay@(i))",
                 out_force_out_i,
                 out_force_out_s,
                 out_force_out_ay,
                 out_force_out_struct);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bat_call_force_method_sync:
 * @proxy: A #FooiGenBatProxy.
 * @arg_force_in_i: Argument to pass with the method invocation.
 * @arg_force_in_s: Argument to pass with the method invocation.
 * @arg_force_in_ay: Argument to pass with the method invocation.
 * @arg_force_in_struct: Argument to pass with the method invocation.
 * @out_force_out_i: (out): Return location for return parameter or %NULL to ignore.
 * @out_force_out_s: (out): Return location for return parameter or %NULL to ignore.
 * @out_force_out_ay: (out): Return location for return parameter or %NULL to ignore.
 * @out_force_out_struct: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bat.ForceMethod">ForceMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bat_call_force_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_bat_call_force_method_sync (
    FooiGenBat *proxy,
    GVariant *arg_force_in_i,
    GVariant *arg_force_in_s,
    GVariant *arg_force_in_ay,
    GVariant *arg_force_in_struct,
    GVariant **out_force_out_i,
    GVariant **out_force_out_s,
    GVariant **out_force_out_ay,
    GVariant **out_force_out_struct,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "ForceMethod",
    g_variant_new ("(@i@s@ay@(i))",
                   arg_force_in_i,
                   arg_force_in_s,
                   arg_force_in_ay,
                   arg_force_in_struct),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(@i@s@ay@(i))",
                 out_force_out_i,
                 out_force_out_s,
                 out_force_out_ay,
                 out_force_out_struct);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_bat_complete_force_method:
 * @object: A #FooiGenBat.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @force_out_i: Parameter to return.
 * @force_out_s: Parameter to return.
 * @force_out_ay: Parameter to return.
 * @force_out_struct: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bat.ForceMethod">ForceMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_bat_complete_force_method (
    FooiGenBat *object,
    GDBusMethodInvocation *invocation,
    GVariant *force_out_i,
    GVariant *force_out_s,
    GVariant *force_out_ay,
    GVariant *force_out_struct)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(@i@s@ay@(i))",
                   force_out_i,
                   force_out_s,
                   force_out_ay,
                   force_out_struct));
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenBatProxy:
 *
 * The #FooiGenBatProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenBatProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenBatProxy.
 */

struct _FooiGenBatProxyPrivate
{
  GData *qdata;
};

static void foo_igen_bat_proxy_iface_init (FooiGenBatIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenBatProxy, foo_igen_bat_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (FooiGenBatProxy)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAT, foo_igen_bat_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenBatProxy, foo_igen_bat_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAT, foo_igen_bat_proxy_iface_init));

#endif
static void
foo_igen_bat_proxy_finalize (GObject *object)
{
  FooiGenBatProxy *proxy = FOO_IGEN_BAT_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_bat_proxy_parent_class)->finalize (object);
}

static void
foo_igen_bat_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 4);
  info = _foo_igen_bat_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
foo_igen_bat_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.project.Bat: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
foo_igen_bat_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 4);
  info = _foo_igen_bat_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.project.Bat", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) foo_igen_bat_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
foo_igen_bat_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_bat_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_BAT);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_BAT);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_bat_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenBatProxy *proxy = FOO_IGEN_BAT_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bat_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bat_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static GVariant *
foo_igen_bat_proxy_get_force_i (FooiGenBat *object)
{
  FooiGenBatProxy *proxy = FOO_IGEN_BAT_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "force_i");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static GVariant *
foo_igen_bat_proxy_get_force_s (FooiGenBat *object)
{
  FooiGenBatProxy *proxy = FOO_IGEN_BAT_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "force_s");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static GVariant *
foo_igen_bat_proxy_get_force_ay (FooiGenBat *object)
{
  FooiGenBatProxy *proxy = FOO_IGEN_BAT_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "force_ay");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static GVariant *
foo_igen_bat_proxy_get_force_struct (FooiGenBat *object)
{
  FooiGenBatProxy *proxy = FOO_IGEN_BAT_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "force_struct");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static void
foo_igen_bat_proxy_init (FooiGenBatProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = foo_igen_bat_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_BAT_PROXY, FooiGenBatProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_bat_interface_info ());
}

static void
foo_igen_bat_proxy_class_init (FooiGenBatProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_bat_proxy_finalize;
  gobject_class->get_property = foo_igen_bat_proxy_get_property;
  gobject_class->set_property = foo_igen_bat_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_bat_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_bat_proxy_g_properties_changed;

  foo_igen_bat_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenBatProxyPrivate));
#endif
}

static void
foo_igen_bat_proxy_iface_init (FooiGenBatIface *iface)
{
  iface->get_force_i = foo_igen_bat_proxy_get_force_i;
  iface->get_force_s = foo_igen_bat_proxy_get_force_s;
  iface->get_force_ay = foo_igen_bat_proxy_get_force_ay;
  iface->get_force_struct = foo_igen_bat_proxy_get_force_struct;
}

/**
 * foo_igen_bat_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bat_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_bat_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_bat_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_BAT_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Bat", NULL);
}

/**
 * foo_igen_bat_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bat_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_bat_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenBatProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBat *
foo_igen_bat_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_BAT (ret);
  else
    return NULL;
}

/**
 * foo_igen_bat_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bat_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenBatProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBat *
foo_igen_bat_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_BAT_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Bat", NULL);
  if (ret != NULL)
    return FOO_IGEN_BAT (ret);
  else
    return NULL;
}


/**
 * foo_igen_bat_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_bat_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_bat_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_bat_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_bat_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_BAT_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Bat", NULL);
}

/**
 * foo_igen_bat_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_bat_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_bat_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenBatProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBat *
foo_igen_bat_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_BAT (ret);
  else
    return NULL;
}

/**
 * foo_igen_bat_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_bat_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_bat_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenBatProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenBat *
foo_igen_bat_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_BAT_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Bat", NULL);
  if (ret != NULL)
    return FOO_IGEN_BAT (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenBatSkeleton:
 *
 * The #FooiGenBatSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenBatSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenBatSkeleton.
 */

struct _FooiGenBatSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_foo_igen_bat_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_BAT);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_BAT);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_bat_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bat_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_bat_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_bat_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_bat_skeleton_vtable =
{
  _foo_igen_bat_skeleton_handle_method_call,
  _foo_igen_bat_skeleton_handle_get_property,
  _foo_igen_bat_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
foo_igen_bat_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return foo_igen_bat_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_bat_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_foo_igen_bat_skeleton_vtable;
}

static GVariant *
foo_igen_bat_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_bat_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_bat_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_bat_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_bat_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Bat", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _foo_igen_bat_emit_changed (gpointer user_data);

static void
foo_igen_bat_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _foo_igen_bat_emit_changed (skeleton);
}

static void
_foo_igen_bat_on_signal_force_signal (
    FooiGenBat *object,
    GVariant *arg_force_i,
    GVariant *arg_force_s,
    GVariant *arg_force_ay,
    GVariant *arg_force_struct)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(@i@s@ay@(i))",
                   arg_force_i,
                   arg_force_s,
                   arg_force_ay,
                   arg_force_struct));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Bat", "ForceSignal",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void foo_igen_bat_skeleton_iface_init (FooiGenBatIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenBatSkeleton, foo_igen_bat_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (FooiGenBatSkeleton)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAT, foo_igen_bat_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenBatSkeleton, foo_igen_bat_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_BAT, foo_igen_bat_skeleton_iface_init));

#endif
static void
foo_igen_bat_skeleton_finalize (GObject *object)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (object);
  guint n;
  for (n = 0; n < 4; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_bat_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_bat_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 4);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_foo_igen_bat_emit_changed (gpointer user_data)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.project.Bat",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_foo_igen_bat_schedule_emit_changed (FooiGenBatSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
foo_igen_bat_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _foo_igen_bat_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _foo_igen_bat_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
foo_igen_bat_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 4);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _foo_igen_bat_schedule_emit_changed (skeleton, _foo_igen_bat_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
foo_igen_bat_skeleton_init (FooiGenBatSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = foo_igen_bat_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_BAT_SKELETON, FooiGenBatSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 4);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_VARIANT);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_VARIANT);
  g_value_init (&skeleton->priv->properties[2], G_TYPE_VARIANT);
  g_value_init (&skeleton->priv->properties[3], G_TYPE_VARIANT);
}

static GVariant *
foo_igen_bat_skeleton_get_force_i (FooiGenBat *object)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (object);
  GVariant *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static GVariant *
foo_igen_bat_skeleton_get_force_s (FooiGenBat *object)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (object);
  GVariant *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static GVariant *
foo_igen_bat_skeleton_get_force_ay (FooiGenBat *object)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (object);
  GVariant *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties[2]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static GVariant *
foo_igen_bat_skeleton_get_force_struct (FooiGenBat *object)
{
  FooiGenBatSkeleton *skeleton = FOO_IGEN_BAT_SKELETON (object);
  GVariant *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties[3]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
foo_igen_bat_skeleton_class_init (FooiGenBatSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_bat_skeleton_finalize;
  gobject_class->get_property = foo_igen_bat_skeleton_get_property;
  gobject_class->set_property = foo_igen_bat_skeleton_set_property;
  gobject_class->notify       = foo_igen_bat_skeleton_notify;


  foo_igen_bat_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_bat_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_bat_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_bat_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_bat_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenBatSkeletonPrivate));
#endif
}

static void
foo_igen_bat_skeleton_iface_init (FooiGenBatIface *iface)
{
  iface->force_signal = _foo_igen_bat_on_signal_force_signal;
  iface->get_force_i = foo_igen_bat_skeleton_get_force_i;
  iface->get_force_s = foo_igen_bat_skeleton_get_force_s;
  iface->get_force_ay = foo_igen_bat_skeleton_get_force_ay;
  iface->get_force_struct = foo_igen_bat_skeleton_get_force_struct;
}

/**
 * foo_igen_bat_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link>.
 *
 * Returns: (transfer full) (type FooiGenBatSkeleton): The skeleton object.
 */
FooiGenBat *
foo_igen_bat_skeleton_new (void)
{
  return FOO_IGEN_BAT (g_object_new (FOO_IGEN_TYPE_BAT_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.project.Authorize
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenAuthorize
 * @title: FooiGenAuthorize
 * @short_description: Generated C code for the org.project.Authorize D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.project.Authorize ---- */

static const _ExtendedGDBusMethodInfo _foo_igen_authorize_method_info_check_not_authorized =
{
  {
    -1,
    (gchar *) "CheckNotAuthorized",
    NULL,
    NULL,
    NULL
  },
  "handle-check-not-authorized",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_authorize_method_info_check_authorized =
{
  {
    -1,
    (gchar *) "CheckAuthorized",
    NULL,
    NULL,
    NULL
  },
  "handle-check-authorized",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_authorize_method_info_check_not_authorized_from_object =
{
  {
    -1,
    (gchar *) "CheckNotAuthorizedFromObject",
    NULL,
    NULL,
    NULL
  },
  "handle-check-not-authorized-from-object",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_authorize_method_info_pointers[] =
{
  &_foo_igen_authorize_method_info_check_not_authorized,
  &_foo_igen_authorize_method_info_check_authorized,
  &_foo_igen_authorize_method_info_check_not_authorized_from_object,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_authorize_interface_info =
{
  {
    -1,
    (gchar *) "org.project.Authorize",
    (GDBusMethodInfo **) &_foo_igen_authorize_method_info_pointers,
    NULL,
    NULL,
    NULL
  },
  "authorize",
};


/**
 * foo_igen_authorize_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_authorize_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_authorize_interface_info.parent_struct;
}

/**
 * foo_igen_authorize_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenAuthorize interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_authorize_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * FooiGenAuthorize:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link>.
 */

/**
 * FooiGenAuthorizeIface:
 * @parent_iface: The parent interface.
 * @handle_check_authorized: Handler for the #FooiGenAuthorize::handle-check-authorized signal.
 * @handle_check_not_authorized: Handler for the #FooiGenAuthorize::handle-check-not-authorized signal.
 * @handle_check_not_authorized_from_object: Handler for the #FooiGenAuthorize::handle-check-not-authorized-from-object signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link>.
 */

typedef FooiGenAuthorizeIface FooiGenAuthorizeInterface;
G_DEFINE_INTERFACE (FooiGenAuthorize, foo_igen_authorize, G_TYPE_OBJECT);

static void
foo_igen_authorize_default_init (FooiGenAuthorizeIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenAuthorize::handle-check-not-authorized:
   * @object: A #FooiGenAuthorize.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorized">CheckNotAuthorized()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_authorize_complete_check_not_authorized() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-check-not-authorized",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenAuthorizeIface, handle_check_not_authorized),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooiGenAuthorize::handle-check-authorized:
   * @object: A #FooiGenAuthorize.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Authorize.CheckAuthorized">CheckAuthorized()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_authorize_complete_check_authorized() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-check-authorized",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenAuthorizeIface, handle_check_authorized),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooiGenAuthorize::handle-check-not-authorized-from-object:
   * @object: A #FooiGenAuthorize.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorizedFromObject">CheckNotAuthorizedFromObject()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_authorize_complete_check_not_authorized_from_object() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-check-not-authorized-from-object",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenAuthorizeIface, handle_check_not_authorized_from_object),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

}

/**
 * foo_igen_authorize_call_check_not_authorized:
 * @proxy: A #FooiGenAuthorizeProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorized">CheckNotAuthorized()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_authorize_call_check_not_authorized_finish() to get the result of the operation.
 *
 * See foo_igen_authorize_call_check_not_authorized_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_authorize_call_check_not_authorized (
    FooiGenAuthorize *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "CheckNotAuthorized",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_authorize_call_check_not_authorized_finish:
 * @proxy: A #FooiGenAuthorizeProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_authorize_call_check_not_authorized().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_authorize_call_check_not_authorized().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_authorize_call_check_not_authorized_finish (
    FooiGenAuthorize *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_authorize_call_check_not_authorized_sync:
 * @proxy: A #FooiGenAuthorizeProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorized">CheckNotAuthorized()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_authorize_call_check_not_authorized() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_authorize_call_check_not_authorized_sync (
    FooiGenAuthorize *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "CheckNotAuthorized",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_authorize_call_check_authorized:
 * @proxy: A #FooiGenAuthorizeProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Authorize.CheckAuthorized">CheckAuthorized()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_authorize_call_check_authorized_finish() to get the result of the operation.
 *
 * See foo_igen_authorize_call_check_authorized_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_authorize_call_check_authorized (
    FooiGenAuthorize *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "CheckAuthorized",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_authorize_call_check_authorized_finish:
 * @proxy: A #FooiGenAuthorizeProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_authorize_call_check_authorized().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_authorize_call_check_authorized().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_authorize_call_check_authorized_finish (
    FooiGenAuthorize *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_authorize_call_check_authorized_sync:
 * @proxy: A #FooiGenAuthorizeProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Authorize.CheckAuthorized">CheckAuthorized()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_authorize_call_check_authorized() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_authorize_call_check_authorized_sync (
    FooiGenAuthorize *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "CheckAuthorized",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_authorize_call_check_not_authorized_from_object:
 * @proxy: A #FooiGenAuthorizeProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorizedFromObject">CheckNotAuthorizedFromObject()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_authorize_call_check_not_authorized_from_object_finish() to get the result of the operation.
 *
 * See foo_igen_authorize_call_check_not_authorized_from_object_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_authorize_call_check_not_authorized_from_object (
    FooiGenAuthorize *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "CheckNotAuthorizedFromObject",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_authorize_call_check_not_authorized_from_object_finish:
 * @proxy: A #FooiGenAuthorizeProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_authorize_call_check_not_authorized_from_object().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_authorize_call_check_not_authorized_from_object().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_authorize_call_check_not_authorized_from_object_finish (
    FooiGenAuthorize *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_authorize_call_check_not_authorized_from_object_sync:
 * @proxy: A #FooiGenAuthorizeProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorizedFromObject">CheckNotAuthorizedFromObject()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_authorize_call_check_not_authorized_from_object() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_authorize_call_check_not_authorized_from_object_sync (
    FooiGenAuthorize *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "CheckNotAuthorizedFromObject",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_authorize_complete_check_not_authorized:
 * @object: A #FooiGenAuthorize.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorized">CheckNotAuthorized()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_authorize_complete_check_not_authorized (
    FooiGenAuthorize *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_authorize_complete_check_authorized:
 * @object: A #FooiGenAuthorize.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Authorize.CheckAuthorized">CheckAuthorized()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_authorize_complete_check_authorized (
    FooiGenAuthorize *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_authorize_complete_check_not_authorized_from_object:
 * @object: A #FooiGenAuthorize.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorizedFromObject">CheckNotAuthorizedFromObject()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_authorize_complete_check_not_authorized_from_object (
    FooiGenAuthorize *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenAuthorizeProxy:
 *
 * The #FooiGenAuthorizeProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenAuthorizeProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenAuthorizeProxy.
 */

struct _FooiGenAuthorizeProxyPrivate
{
  GData *qdata;
};

static void foo_igen_authorize_proxy_iface_init (FooiGenAuthorizeIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenAuthorizeProxy, foo_igen_authorize_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (FooiGenAuthorizeProxy)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_AUTHORIZE, foo_igen_authorize_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenAuthorizeProxy, foo_igen_authorize_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_AUTHORIZE, foo_igen_authorize_proxy_iface_init));

#endif
static void
foo_igen_authorize_proxy_finalize (GObject *object)
{
  FooiGenAuthorizeProxy *proxy = FOO_IGEN_AUTHORIZE_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_authorize_proxy_parent_class)->finalize (object);
}

static void
foo_igen_authorize_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
foo_igen_authorize_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
foo_igen_authorize_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_authorize_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_AUTHORIZE);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_AUTHORIZE);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_authorize_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenAuthorizeProxy *proxy = FOO_IGEN_AUTHORIZE_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_authorize_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_authorize_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_igen_authorize_proxy_init (FooiGenAuthorizeProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = foo_igen_authorize_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_AUTHORIZE_PROXY, FooiGenAuthorizeProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_authorize_interface_info ());
}

static void
foo_igen_authorize_proxy_class_init (FooiGenAuthorizeProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_authorize_proxy_finalize;
  gobject_class->get_property = foo_igen_authorize_proxy_get_property;
  gobject_class->set_property = foo_igen_authorize_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_authorize_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_authorize_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenAuthorizeProxyPrivate));
#endif
}

static void
foo_igen_authorize_proxy_iface_init (FooiGenAuthorizeIface *iface)
{
}

/**
 * foo_igen_authorize_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_authorize_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_authorize_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_authorize_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_AUTHORIZE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Authorize", NULL);
}

/**
 * foo_igen_authorize_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_authorize_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_authorize_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenAuthorizeProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenAuthorize *
foo_igen_authorize_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_AUTHORIZE (ret);
  else
    return NULL;
}

/**
 * foo_igen_authorize_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_authorize_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenAuthorizeProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenAuthorize *
foo_igen_authorize_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_AUTHORIZE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Authorize", NULL);
  if (ret != NULL)
    return FOO_IGEN_AUTHORIZE (ret);
  else
    return NULL;
}


/**
 * foo_igen_authorize_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_authorize_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_authorize_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_authorize_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_authorize_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_AUTHORIZE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Authorize", NULL);
}

/**
 * foo_igen_authorize_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_authorize_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_authorize_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenAuthorizeProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenAuthorize *
foo_igen_authorize_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_AUTHORIZE (ret);
  else
    return NULL;
}

/**
 * foo_igen_authorize_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_authorize_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_authorize_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenAuthorizeProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenAuthorize *
foo_igen_authorize_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_AUTHORIZE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Authorize", NULL);
  if (ret != NULL)
    return FOO_IGEN_AUTHORIZE (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenAuthorizeSkeleton:
 *
 * The #FooiGenAuthorizeSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenAuthorizeSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenAuthorizeSkeleton.
 */

struct _FooiGenAuthorizeSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_foo_igen_authorize_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenAuthorizeSkeleton *skeleton = FOO_IGEN_AUTHORIZE_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_AUTHORIZE);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_AUTHORIZE);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_authorize_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenAuthorizeSkeleton *skeleton = FOO_IGEN_AUTHORIZE_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_authorize_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_authorize_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenAuthorizeSkeleton *skeleton = FOO_IGEN_AUTHORIZE_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_authorize_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_authorize_skeleton_vtable =
{
  _foo_igen_authorize_skeleton_handle_method_call,
  _foo_igen_authorize_skeleton_handle_get_property,
  _foo_igen_authorize_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
foo_igen_authorize_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return foo_igen_authorize_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_authorize_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_foo_igen_authorize_skeleton_vtable;
}

static GVariant *
foo_igen_authorize_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenAuthorizeSkeleton *skeleton = FOO_IGEN_AUTHORIZE_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_authorize_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_authorize_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_authorize_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_authorize_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Authorize", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
foo_igen_authorize_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void foo_igen_authorize_skeleton_iface_init (FooiGenAuthorizeIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenAuthorizeSkeleton, foo_igen_authorize_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (FooiGenAuthorizeSkeleton)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_AUTHORIZE, foo_igen_authorize_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenAuthorizeSkeleton, foo_igen_authorize_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_AUTHORIZE, foo_igen_authorize_skeleton_iface_init));

#endif
static void
foo_igen_authorize_skeleton_finalize (GObject *object)
{
  FooiGenAuthorizeSkeleton *skeleton = FOO_IGEN_AUTHORIZE_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_authorize_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_authorize_skeleton_init (FooiGenAuthorizeSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = foo_igen_authorize_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_AUTHORIZE_SKELETON, FooiGenAuthorizeSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
foo_igen_authorize_skeleton_class_init (FooiGenAuthorizeSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_authorize_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_authorize_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_authorize_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_authorize_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_authorize_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenAuthorizeSkeletonPrivate));
#endif
}

static void
foo_igen_authorize_skeleton_iface_init (FooiGenAuthorizeIface *iface)
{
}

/**
 * foo_igen_authorize_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link>.
 *
 * Returns: (transfer full) (type FooiGenAuthorizeSkeleton): The skeleton object.
 */
FooiGenAuthorize *
foo_igen_authorize_skeleton_new (void)
{
  return FOO_IGEN_AUTHORIZE (g_object_new (FOO_IGEN_TYPE_AUTHORIZE_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.project.MethodThreads
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenMethodThreads
 * @title: FooiGenMethodThreads
 * @short_description: Generated C code for the org.project.MethodThreads D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.project.MethodThreads ---- */

static const _ExtendedGDBusArgInfo _foo_igen_method_threads_method_info_get_self_OUT_ARG_self_pointer =
{
  {
    -1,
    (gchar *) "self_pointer",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_method_threads_method_info_get_self_OUT_ARG_pointers[] =
{
  &_foo_igen_method_threads_method_info_get_self_OUT_ARG_self_pointer,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_igen_method_threads_method_info_get_self =
{
  {
    -1,
    (gchar *) "GetSelf",
    NULL,
    (GDBusArgInfo **) &_foo_igen_method_threads_method_info_get_self_OUT_ARG_pointers,
    NULL
  },
  "handle-get-self",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_method_threads_method_info_pointers[] =
{
  &_foo_igen_method_threads_method_info_get_self,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_method_threads_interface_info =
{
  {
    -1,
    (gchar *) "org.project.MethodThreads",
    (GDBusMethodInfo **) &_foo_igen_method_threads_method_info_pointers,
    NULL,
    NULL,
    NULL
  },
  "method-threads",
};


/**
 * foo_igen_method_threads_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_method_threads_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_method_threads_interface_info.parent_struct;
}

/**
 * foo_igen_method_threads_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenMethodThreads interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_method_threads_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * FooiGenMethodThreads:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link>.
 */

/**
 * FooiGenMethodThreadsIface:
 * @parent_iface: The parent interface.
 * @handle_get_self: Handler for the #FooiGenMethodThreads::handle-get-self signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link>.
 */

typedef FooiGenMethodThreadsIface FooiGenMethodThreadsInterface;
G_DEFINE_INTERFACE (FooiGenMethodThreads, foo_igen_method_threads, G_TYPE_OBJECT);

static void
foo_igen_method_threads_default_init (FooiGenMethodThreadsIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenMethodThreads::handle-get-self:
   * @object: A #FooiGenMethodThreads.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-MethodThreads.GetSelf">GetSelf()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_method_threads_complete_get_self() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-self",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenMethodThreadsIface, handle_get_self),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

}

/**
 * foo_igen_method_threads_call_get_self:
 * @proxy: A #FooiGenMethodThreadsProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-MethodThreads.GetSelf">GetSelf()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_method_threads_call_get_self_finish() to get the result of the operation.
 *
 * See foo_igen_method_threads_call_get_self_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_method_threads_call_get_self (
    FooiGenMethodThreads *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "GetSelf",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_method_threads_call_get_self_finish:
 * @proxy: A #FooiGenMethodThreadsProxy.
 * @out_self_pointer: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_method_threads_call_get_self().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_method_threads_call_get_self().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_method_threads_call_get_self_finish (
    FooiGenMethodThreads *proxy,
    gchar **out_self_pointer,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_self_pointer);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_method_threads_call_get_self_sync:
 * @proxy: A #FooiGenMethodThreadsProxy.
 * @out_self_pointer: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-MethodThreads.GetSelf">GetSelf()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_method_threads_call_get_self() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_method_threads_call_get_self_sync (
    FooiGenMethodThreads *proxy,
    gchar **out_self_pointer,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "GetSelf",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_self_pointer);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_method_threads_complete_get_self:
 * @object: A #FooiGenMethodThreads.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @self_pointer: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-MethodThreads.GetSelf">GetSelf()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_method_threads_complete_get_self (
    FooiGenMethodThreads *object,
    GDBusMethodInvocation *invocation,
    const gchar *self_pointer)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(s)",
                   self_pointer));
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenMethodThreadsProxy:
 *
 * The #FooiGenMethodThreadsProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenMethodThreadsProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenMethodThreadsProxy.
 */

struct _FooiGenMethodThreadsProxyPrivate
{
  GData *qdata;
};

static void foo_igen_method_threads_proxy_iface_init (FooiGenMethodThreadsIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenMethodThreadsProxy, foo_igen_method_threads_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (FooiGenMethodThreadsProxy)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_METHOD_THREADS, foo_igen_method_threads_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenMethodThreadsProxy, foo_igen_method_threads_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_METHOD_THREADS, foo_igen_method_threads_proxy_iface_init));

#endif
static void
foo_igen_method_threads_proxy_finalize (GObject *object)
{
  FooiGenMethodThreadsProxy *proxy = FOO_IGEN_METHOD_THREADS_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_method_threads_proxy_parent_class)->finalize (object);
}

static void
foo_igen_method_threads_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
foo_igen_method_threads_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
foo_igen_method_threads_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_method_threads_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_METHOD_THREADS);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_METHOD_THREADS);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_method_threads_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenMethodThreadsProxy *proxy = FOO_IGEN_METHOD_THREADS_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_method_threads_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_method_threads_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_igen_method_threads_proxy_init (FooiGenMethodThreadsProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = foo_igen_method_threads_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_METHOD_THREADS_PROXY, FooiGenMethodThreadsProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_method_threads_interface_info ());
}

static void
foo_igen_method_threads_proxy_class_init (FooiGenMethodThreadsProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_method_threads_proxy_finalize;
  gobject_class->get_property = foo_igen_method_threads_proxy_get_property;
  gobject_class->set_property = foo_igen_method_threads_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_method_threads_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_method_threads_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenMethodThreadsProxyPrivate));
#endif
}

static void
foo_igen_method_threads_proxy_iface_init (FooiGenMethodThreadsIface *iface)
{
}

/**
 * foo_igen_method_threads_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_method_threads_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_method_threads_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_method_threads_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_METHOD_THREADS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.MethodThreads", NULL);
}

/**
 * foo_igen_method_threads_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_method_threads_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_method_threads_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenMethodThreadsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenMethodThreads *
foo_igen_method_threads_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_METHOD_THREADS (ret);
  else
    return NULL;
}

/**
 * foo_igen_method_threads_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_method_threads_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenMethodThreadsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenMethodThreads *
foo_igen_method_threads_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_METHOD_THREADS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.MethodThreads", NULL);
  if (ret != NULL)
    return FOO_IGEN_METHOD_THREADS (ret);
  else
    return NULL;
}


/**
 * foo_igen_method_threads_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_method_threads_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_method_threads_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_method_threads_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_method_threads_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_METHOD_THREADS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.MethodThreads", NULL);
}

/**
 * foo_igen_method_threads_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_method_threads_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_method_threads_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenMethodThreadsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenMethodThreads *
foo_igen_method_threads_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_METHOD_THREADS (ret);
  else
    return NULL;
}

/**
 * foo_igen_method_threads_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_method_threads_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_method_threads_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenMethodThreadsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenMethodThreads *
foo_igen_method_threads_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_METHOD_THREADS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.MethodThreads", NULL);
  if (ret != NULL)
    return FOO_IGEN_METHOD_THREADS (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenMethodThreadsSkeleton:
 *
 * The #FooiGenMethodThreadsSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenMethodThreadsSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenMethodThreadsSkeleton.
 */

struct _FooiGenMethodThreadsSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_foo_igen_method_threads_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenMethodThreadsSkeleton *skeleton = FOO_IGEN_METHOD_THREADS_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_METHOD_THREADS);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_METHOD_THREADS);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_method_threads_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenMethodThreadsSkeleton *skeleton = FOO_IGEN_METHOD_THREADS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_method_threads_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_method_threads_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenMethodThreadsSkeleton *skeleton = FOO_IGEN_METHOD_THREADS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_method_threads_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_method_threads_skeleton_vtable =
{
  _foo_igen_method_threads_skeleton_handle_method_call,
  _foo_igen_method_threads_skeleton_handle_get_property,
  _foo_igen_method_threads_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
foo_igen_method_threads_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return foo_igen_method_threads_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_method_threads_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_foo_igen_method_threads_skeleton_vtable;
}

static GVariant *
foo_igen_method_threads_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenMethodThreadsSkeleton *skeleton = FOO_IGEN_METHOD_THREADS_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_method_threads_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_method_threads_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_method_threads_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_method_threads_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.MethodThreads", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
foo_igen_method_threads_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void foo_igen_method_threads_skeleton_iface_init (FooiGenMethodThreadsIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenMethodThreadsSkeleton, foo_igen_method_threads_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (FooiGenMethodThreadsSkeleton)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_METHOD_THREADS, foo_igen_method_threads_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenMethodThreadsSkeleton, foo_igen_method_threads_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_METHOD_THREADS, foo_igen_method_threads_skeleton_iface_init));

#endif
static void
foo_igen_method_threads_skeleton_finalize (GObject *object)
{
  FooiGenMethodThreadsSkeleton *skeleton = FOO_IGEN_METHOD_THREADS_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_method_threads_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_method_threads_skeleton_init (FooiGenMethodThreadsSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = foo_igen_method_threads_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_METHOD_THREADS_SKELETON, FooiGenMethodThreadsSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
foo_igen_method_threads_skeleton_class_init (FooiGenMethodThreadsSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_method_threads_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_method_threads_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_method_threads_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_method_threads_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_method_threads_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenMethodThreadsSkeletonPrivate));
#endif
}

static void
foo_igen_method_threads_skeleton_iface_init (FooiGenMethodThreadsIface *iface)
{
}

/**
 * foo_igen_method_threads_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link>.
 *
 * Returns: (transfer full) (type FooiGenMethodThreadsSkeleton): The skeleton object.
 */
FooiGenMethodThreads *
foo_igen_method_threads_skeleton_new (void)
{
  return FOO_IGEN_METHOD_THREADS (g_object_new (FOO_IGEN_TYPE_METHOD_THREADS_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.project.InlineDocs
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenInlineDocs
 * @title: FooiGenInlineDocs
 * @short_description: Generated C code for the org.project.InlineDocs D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.project.InlineDocs ---- */

static const _ExtendedGDBusArgInfo _foo_igen_inline_docs_method_info_foo_method_IN_ARG_greeting =
{
  {
    -1,
    (gchar *) "greeting",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_inline_docs_method_info_foo_method_IN_ARG_pointers[] =
{
  &_foo_igen_inline_docs_method_info_foo_method_IN_ARG_greeting,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_inline_docs_method_info_foo_method_OUT_ARG_response =
{
  {
    -1,
    (gchar *) "response",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_inline_docs_method_info_foo_method_OUT_ARG_pointers[] =
{
  &_foo_igen_inline_docs_method_info_foo_method_OUT_ARG_response,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_igen_inline_docs_method_info_foo_method =
{
  {
    -1,
    (gchar *) "FooMethod",
    (GDBusArgInfo **) &_foo_igen_inline_docs_method_info_foo_method_IN_ARG_pointers,
    (GDBusArgInfo **) &_foo_igen_inline_docs_method_info_foo_method_OUT_ARG_pointers,
    NULL
  },
  "handle-foo-method",
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_inline_docs_method_info_method2_IN_ARG_greeting =
{
  {
    -1,
    (gchar *) "greeting",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_inline_docs_method_info_method2_IN_ARG_pointers[] =
{
  &_foo_igen_inline_docs_method_info_method2_IN_ARG_greeting,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_inline_docs_method_info_method2_OUT_ARG_response =
{
  {
    -1,
    (gchar *) "response",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_inline_docs_method_info_method2_OUT_ARG_pointers[] =
{
  &_foo_igen_inline_docs_method_info_method2_OUT_ARG_response,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_igen_inline_docs_method_info_method2 =
{
  {
    -1,
    (gchar *) "Method2",
    (GDBusArgInfo **) &_foo_igen_inline_docs_method_info_method2_IN_ARG_pointers,
    (GDBusArgInfo **) &_foo_igen_inline_docs_method_info_method2_OUT_ARG_pointers,
    NULL
  },
  "handle-method2",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_inline_docs_method_info_pointers[] =
{
  &_foo_igen_inline_docs_method_info_foo_method,
  &_foo_igen_inline_docs_method_info_method2,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_inline_docs_signal_info_bar_signal_ARG_blah =
{
  {
    -1,
    (gchar *) "blah",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_igen_inline_docs_signal_info_bar_signal_ARG_boo =
{
  {
    -1,
    (gchar *) "boo",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_inline_docs_signal_info_bar_signal_ARG_pointers[] =
{
  &_foo_igen_inline_docs_signal_info_bar_signal_ARG_blah,
  &_foo_igen_inline_docs_signal_info_bar_signal_ARG_boo,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_igen_inline_docs_signal_info_bar_signal =
{
  {
    -1,
    (gchar *) "BarSignal",
    (GDBusArgInfo **) &_foo_igen_inline_docs_signal_info_bar_signal_ARG_pointers,
    NULL
  },
  "bar-signal"
};

static const _ExtendedGDBusSignalInfo * const _foo_igen_inline_docs_signal_info_pointers[] =
{
  &_foo_igen_inline_docs_signal_info_bar_signal,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_igen_inline_docs_property_info_baz_property =
{
  {
    -1,
    (gchar *) "BazProperty",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "baz-property",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_inline_docs_property_info_property2 =
{
  {
    -1,
    (gchar *) "Property2",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "property2",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_inline_docs_property_info_property3 =
{
  {
    -1,
    (gchar *) "Property3",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "property3",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_inline_docs_property_info_property4 =
{
  {
    -1,
    (gchar *) "Property4",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "property4",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_inline_docs_property_info_property5 =
{
  {
    -1,
    (gchar *) "Property5",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "property5",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_igen_inline_docs_property_info_fancy_property =
{
  {
    -1,
    (gchar *) "FancyProperty",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "fancy-property",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _foo_igen_inline_docs_property_info_pointers[] =
{
  &_foo_igen_inline_docs_property_info_baz_property,
  &_foo_igen_inline_docs_property_info_property2,
  &_foo_igen_inline_docs_property_info_property3,
  &_foo_igen_inline_docs_property_info_property4,
  &_foo_igen_inline_docs_property_info_property5,
  &_foo_igen_inline_docs_property_info_fancy_property,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_inline_docs_interface_info =
{
  {
    -1,
    (gchar *) "org.project.InlineDocs",
    (GDBusMethodInfo **) &_foo_igen_inline_docs_method_info_pointers,
    (GDBusSignalInfo **) &_foo_igen_inline_docs_signal_info_pointers,
    (GDBusPropertyInfo **) &_foo_igen_inline_docs_property_info_pointers,
    NULL
  },
  "inline-docs",
};


/**
 * foo_igen_inline_docs_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_inline_docs_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_inline_docs_interface_info.parent_struct;
}

/**
 * foo_igen_inline_docs_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenInlineDocs interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_inline_docs_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "baz-property");
  g_object_class_override_property (klass, property_id_begin++, "property2");
  g_object_class_override_property (klass, property_id_begin++, "property3");
  g_object_class_override_property (klass, property_id_begin++, "property4");
  g_object_class_override_property (klass, property_id_begin++, "property5");
  g_object_class_override_property (klass, property_id_begin++, "fancy-property");
  return property_id_begin - 1;
}



/**
 * FooiGenInlineDocs:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link>.
 */

/**
 * FooiGenInlineDocsIface:
 * @parent_iface: The parent interface.
 * @handle_foo_method: Handler for the #FooiGenInlineDocs::handle-foo-method signal.
 * @handle_method2: Handler for the #FooiGenInlineDocs::handle-method2 signal.
 * @get_baz_property: Getter for the #FooiGenInlineDocs:baz-property property.
 * @get_fancy_property: Getter for the #FooiGenInlineDocs:fancy-property property.
 * @get_property2: Getter for the #FooiGenInlineDocs:property2 property.
 * @get_property3: Getter for the #FooiGenInlineDocs:property3 property.
 * @get_property4: Getter for the #FooiGenInlineDocs:property4 property.
 * @get_property5: Getter for the #FooiGenInlineDocs:property5 property.
 * @bar_signal: Handler for the #FooiGenInlineDocs::bar-signal signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link>.
 */

typedef FooiGenInlineDocsIface FooiGenInlineDocsInterface;
G_DEFINE_INTERFACE (FooiGenInlineDocs, foo_igen_inline_docs, G_TYPE_OBJECT);

static void
foo_igen_inline_docs_default_init (FooiGenInlineDocsIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenInlineDocs::handle-foo-method:
   * @object: A #FooiGenInlineDocs.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_greeting: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-InlineDocs.FooMethod">FooMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_inline_docs_complete_foo_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-foo-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenInlineDocsIface, handle_foo_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * FooiGenInlineDocs::handle-method2:
   * @object: A #FooiGenInlineDocs.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_greeting: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-InlineDocs.Method2">Method2()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_inline_docs_complete_method2() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-method2",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenInlineDocsIface, handle_method2),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooiGenInlineDocs::bar-signal:
   * @object: A #FooiGenInlineDocs.
   * @arg_blah: Argument.
   * @arg_boo: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-project-InlineDocs.BarSignal">"BarSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("bar-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenInlineDocsIface, bar_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    2, G_TYPE_STRING, G_TYPE_STRING);

  /* GObject properties for D-Bus properties: */
  /**
   * FooiGenInlineDocs:baz-property:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-InlineDocs.BazProperty">"BazProperty"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("baz-property", "BazProperty", "BazProperty", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenInlineDocs:property2:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-InlineDocs.Property2">"Property2"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("property2", "Property2", "Property2", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenInlineDocs:property3:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-InlineDocs.Property3">"Property3"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("property3", "Property3", "Property3", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenInlineDocs:property4:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-InlineDocs.Property4">"Property4"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("property4", "Property4", "Property4", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenInlineDocs:property5:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-InlineDocs.Property5">"Property5"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("property5", "Property5", "Property5", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooiGenInlineDocs:fancy-property:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-InlineDocs.FancyProperty">"FancyProperty"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("fancy-property", "FancyProperty", "FancyProperty", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * foo_igen_inline_docs_get_baz_property: (skip)
 * @object: A #FooiGenInlineDocs.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-InlineDocs.BazProperty">"BazProperty"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_inline_docs_dup_baz_property() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_inline_docs_get_baz_property (FooiGenInlineDocs *object)
{
  return FOO_IGEN_INLINE_DOCS_GET_IFACE (object)->get_baz_property (object);
}

/**
 * foo_igen_inline_docs_dup_baz_property: (skip)
 * @object: A #FooiGenInlineDocs.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-InlineDocs.BazProperty">"BazProperty"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_inline_docs_dup_baz_property (FooiGenInlineDocs *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "baz-property", &value, NULL);
  return value;
}

/**
 * foo_igen_inline_docs_set_baz_property: (skip)
 * @object: A #FooiGenInlineDocs.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-InlineDocs.BazProperty">"BazProperty"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_igen_inline_docs_set_baz_property (FooiGenInlineDocs *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "baz-property", value, NULL);
}

/**
 * foo_igen_inline_docs_get_property2: (skip)
 * @object: A #FooiGenInlineDocs.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-InlineDocs.Property2">"Property2"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_inline_docs_dup_property2() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_inline_docs_get_property2 (FooiGenInlineDocs *object)
{
  return FOO_IGEN_INLINE_DOCS_GET_IFACE (object)->get_property2 (object);
}

/**
 * foo_igen_inline_docs_dup_property2: (skip)
 * @object: A #FooiGenInlineDocs.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-InlineDocs.Property2">"Property2"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_inline_docs_dup_property2 (FooiGenInlineDocs *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "property2", &value, NULL);
  return value;
}

/**
 * foo_igen_inline_docs_set_property2: (skip)
 * @object: A #FooiGenInlineDocs.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-InlineDocs.Property2">"Property2"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_igen_inline_docs_set_property2 (FooiGenInlineDocs *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "property2", value, NULL);
}

/**
 * foo_igen_inline_docs_get_property3: (skip)
 * @object: A #FooiGenInlineDocs.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-InlineDocs.Property3">"Property3"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_inline_docs_dup_property3() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_inline_docs_get_property3 (FooiGenInlineDocs *object)
{
  return FOO_IGEN_INLINE_DOCS_GET_IFACE (object)->get_property3 (object);
}

/**
 * foo_igen_inline_docs_dup_property3: (skip)
 * @object: A #FooiGenInlineDocs.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-InlineDocs.Property3">"Property3"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_inline_docs_dup_property3 (FooiGenInlineDocs *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "property3", &value, NULL);
  return value;
}

/**
 * foo_igen_inline_docs_set_property3: (skip)
 * @object: A #FooiGenInlineDocs.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-InlineDocs.Property3">"Property3"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_igen_inline_docs_set_property3 (FooiGenInlineDocs *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "property3", value, NULL);
}

/**
 * foo_igen_inline_docs_get_property4: (skip)
 * @object: A #FooiGenInlineDocs.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-InlineDocs.Property4">"Property4"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_inline_docs_dup_property4() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_inline_docs_get_property4 (FooiGenInlineDocs *object)
{
  return FOO_IGEN_INLINE_DOCS_GET_IFACE (object)->get_property4 (object);
}

/**
 * foo_igen_inline_docs_dup_property4: (skip)
 * @object: A #FooiGenInlineDocs.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-InlineDocs.Property4">"Property4"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_inline_docs_dup_property4 (FooiGenInlineDocs *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "property4", &value, NULL);
  return value;
}

/**
 * foo_igen_inline_docs_set_property4: (skip)
 * @object: A #FooiGenInlineDocs.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-InlineDocs.Property4">"Property4"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_igen_inline_docs_set_property4 (FooiGenInlineDocs *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "property4", value, NULL);
}

/**
 * foo_igen_inline_docs_get_property5: (skip)
 * @object: A #FooiGenInlineDocs.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-InlineDocs.Property5">"Property5"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_inline_docs_dup_property5() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_inline_docs_get_property5 (FooiGenInlineDocs *object)
{
  return FOO_IGEN_INLINE_DOCS_GET_IFACE (object)->get_property5 (object);
}

/**
 * foo_igen_inline_docs_dup_property5: (skip)
 * @object: A #FooiGenInlineDocs.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-InlineDocs.Property5">"Property5"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_inline_docs_dup_property5 (FooiGenInlineDocs *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "property5", &value, NULL);
  return value;
}

/**
 * foo_igen_inline_docs_set_property5: (skip)
 * @object: A #FooiGenInlineDocs.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-InlineDocs.Property5">"Property5"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_igen_inline_docs_set_property5 (FooiGenInlineDocs *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "property5", value, NULL);
}

/**
 * foo_igen_inline_docs_get_fancy_property: (skip)
 * @object: A #FooiGenInlineDocs.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-InlineDocs.FancyProperty">"FancyProperty"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_inline_docs_dup_fancy_property() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_inline_docs_get_fancy_property (FooiGenInlineDocs *object)
{
  return FOO_IGEN_INLINE_DOCS_GET_IFACE (object)->get_fancy_property (object);
}

/**
 * foo_igen_inline_docs_dup_fancy_property: (skip)
 * @object: A #FooiGenInlineDocs.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-project-InlineDocs.FancyProperty">"FancyProperty"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_inline_docs_dup_fancy_property (FooiGenInlineDocs *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "fancy-property", &value, NULL);
  return value;
}

/**
 * foo_igen_inline_docs_set_fancy_property: (skip)
 * @object: A #FooiGenInlineDocs.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-InlineDocs.FancyProperty">"FancyProperty"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_igen_inline_docs_set_fancy_property (FooiGenInlineDocs *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "fancy-property", value, NULL);
}

/**
 * foo_igen_inline_docs_emit_bar_signal:
 * @object: A #FooiGenInlineDocs.
 * @arg_blah: Argument to pass with the signal.
 * @arg_boo: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-project-InlineDocs.BarSignal">"BarSignal"</link> D-Bus signal.
 */
void
foo_igen_inline_docs_emit_bar_signal (
    FooiGenInlineDocs *object,
    const gchar *arg_blah,
    const gchar *arg_boo)
{
  g_signal_emit_by_name (object, "bar-signal", arg_blah, arg_boo);
}

/**
 * foo_igen_inline_docs_call_foo_method:
 * @proxy: A #FooiGenInlineDocsProxy.
 * @arg_greeting: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-InlineDocs.FooMethod">FooMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_inline_docs_call_foo_method_finish() to get the result of the operation.
 *
 * See foo_igen_inline_docs_call_foo_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_inline_docs_call_foo_method (
    FooiGenInlineDocs *proxy,
    const gchar *arg_greeting,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "FooMethod",
    g_variant_new ("(s)",
                   arg_greeting),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_inline_docs_call_foo_method_finish:
 * @proxy: A #FooiGenInlineDocsProxy.
 * @out_response: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_inline_docs_call_foo_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_inline_docs_call_foo_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_inline_docs_call_foo_method_finish (
    FooiGenInlineDocs *proxy,
    gchar **out_response,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_response);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_inline_docs_call_foo_method_sync:
 * @proxy: A #FooiGenInlineDocsProxy.
 * @arg_greeting: Argument to pass with the method invocation.
 * @out_response: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-InlineDocs.FooMethod">FooMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_inline_docs_call_foo_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_inline_docs_call_foo_method_sync (
    FooiGenInlineDocs *proxy,
    const gchar *arg_greeting,
    gchar **out_response,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "FooMethod",
    g_variant_new ("(s)",
                   arg_greeting),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_response);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_inline_docs_call_method2:
 * @proxy: A #FooiGenInlineDocsProxy.
 * @arg_greeting: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-InlineDocs.Method2">Method2()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_inline_docs_call_method2_finish() to get the result of the operation.
 *
 * See foo_igen_inline_docs_call_method2_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_inline_docs_call_method2 (
    FooiGenInlineDocs *proxy,
    const gchar *arg_greeting,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Method2",
    g_variant_new ("(s)",
                   arg_greeting),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_inline_docs_call_method2_finish:
 * @proxy: A #FooiGenInlineDocsProxy.
 * @out_response: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_inline_docs_call_method2().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_inline_docs_call_method2().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_inline_docs_call_method2_finish (
    FooiGenInlineDocs *proxy,
    gchar **out_response,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_response);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_inline_docs_call_method2_sync:
 * @proxy: A #FooiGenInlineDocsProxy.
 * @arg_greeting: Argument to pass with the method invocation.
 * @out_response: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-InlineDocs.Method2">Method2()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_inline_docs_call_method2() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_inline_docs_call_method2_sync (
    FooiGenInlineDocs *proxy,
    const gchar *arg_greeting,
    gchar **out_response,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Method2",
    g_variant_new ("(s)",
                   arg_greeting),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_response);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_inline_docs_complete_foo_method:
 * @object: A #FooiGenInlineDocs.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @response: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-InlineDocs.FooMethod">FooMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_inline_docs_complete_foo_method (
    FooiGenInlineDocs *object,
    GDBusMethodInvocation *invocation,
    const gchar *response)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(s)",
                   response));
}

/**
 * foo_igen_inline_docs_complete_method2:
 * @object: A #FooiGenInlineDocs.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @response: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-InlineDocs.Method2">Method2()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_inline_docs_complete_method2 (
    FooiGenInlineDocs *object,
    GDBusMethodInvocation *invocation,
    const gchar *response)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(s)",
                   response));
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenInlineDocsProxy:
 *
 * The #FooiGenInlineDocsProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenInlineDocsProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenInlineDocsProxy.
 */

struct _FooiGenInlineDocsProxyPrivate
{
  GData *qdata;
};

static void foo_igen_inline_docs_proxy_iface_init (FooiGenInlineDocsIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenInlineDocsProxy, foo_igen_inline_docs_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (FooiGenInlineDocsProxy)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_INLINE_DOCS, foo_igen_inline_docs_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenInlineDocsProxy, foo_igen_inline_docs_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_INLINE_DOCS, foo_igen_inline_docs_proxy_iface_init));

#endif
static void
foo_igen_inline_docs_proxy_finalize (GObject *object)
{
  FooiGenInlineDocsProxy *proxy = FOO_IGEN_INLINE_DOCS_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_inline_docs_proxy_parent_class)->finalize (object);
}

static void
foo_igen_inline_docs_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 6);
  info = _foo_igen_inline_docs_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
foo_igen_inline_docs_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.project.InlineDocs: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
foo_igen_inline_docs_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 6);
  info = _foo_igen_inline_docs_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.project.InlineDocs", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) foo_igen_inline_docs_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
foo_igen_inline_docs_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_inline_docs_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_INLINE_DOCS);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_INLINE_DOCS);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_inline_docs_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenInlineDocsProxy *proxy = FOO_IGEN_INLINE_DOCS_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_inline_docs_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_inline_docs_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static const gchar *
foo_igen_inline_docs_proxy_get_baz_property (FooiGenInlineDocs *object)
{
  FooiGenInlineDocsProxy *proxy = FOO_IGEN_INLINE_DOCS_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "BazProperty");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_inline_docs_proxy_get_property2 (FooiGenInlineDocs *object)
{
  FooiGenInlineDocsProxy *proxy = FOO_IGEN_INLINE_DOCS_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Property2");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_inline_docs_proxy_get_property3 (FooiGenInlineDocs *object)
{
  FooiGenInlineDocsProxy *proxy = FOO_IGEN_INLINE_DOCS_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Property3");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_inline_docs_proxy_get_property4 (FooiGenInlineDocs *object)
{
  FooiGenInlineDocsProxy *proxy = FOO_IGEN_INLINE_DOCS_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Property4");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_inline_docs_proxy_get_property5 (FooiGenInlineDocs *object)
{
  FooiGenInlineDocsProxy *proxy = FOO_IGEN_INLINE_DOCS_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Property5");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
foo_igen_inline_docs_proxy_get_fancy_property (FooiGenInlineDocs *object)
{
  FooiGenInlineDocsProxy *proxy = FOO_IGEN_INLINE_DOCS_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "FancyProperty");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
foo_igen_inline_docs_proxy_init (FooiGenInlineDocsProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = foo_igen_inline_docs_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_INLINE_DOCS_PROXY, FooiGenInlineDocsProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_inline_docs_interface_info ());
}

static void
foo_igen_inline_docs_proxy_class_init (FooiGenInlineDocsProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_inline_docs_proxy_finalize;
  gobject_class->get_property = foo_igen_inline_docs_proxy_get_property;
  gobject_class->set_property = foo_igen_inline_docs_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_inline_docs_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_inline_docs_proxy_g_properties_changed;

  foo_igen_inline_docs_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenInlineDocsProxyPrivate));
#endif
}

static void
foo_igen_inline_docs_proxy_iface_init (FooiGenInlineDocsIface *iface)
{
  iface->get_baz_property = foo_igen_inline_docs_proxy_get_baz_property;
  iface->get_property2 = foo_igen_inline_docs_proxy_get_property2;
  iface->get_property3 = foo_igen_inline_docs_proxy_get_property3;
  iface->get_property4 = foo_igen_inline_docs_proxy_get_property4;
  iface->get_property5 = foo_igen_inline_docs_proxy_get_property5;
  iface->get_fancy_property = foo_igen_inline_docs_proxy_get_fancy_property;
}

/**
 * foo_igen_inline_docs_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_inline_docs_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_inline_docs_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_inline_docs_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_INLINE_DOCS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.InlineDocs", NULL);
}

/**
 * foo_igen_inline_docs_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_inline_docs_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_inline_docs_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenInlineDocsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenInlineDocs *
foo_igen_inline_docs_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_INLINE_DOCS (ret);
  else
    return NULL;
}

/**
 * foo_igen_inline_docs_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_inline_docs_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenInlineDocsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenInlineDocs *
foo_igen_inline_docs_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_INLINE_DOCS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.InlineDocs", NULL);
  if (ret != NULL)
    return FOO_IGEN_INLINE_DOCS (ret);
  else
    return NULL;
}


/**
 * foo_igen_inline_docs_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_inline_docs_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_inline_docs_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_inline_docs_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_inline_docs_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_INLINE_DOCS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.InlineDocs", NULL);
}

/**
 * foo_igen_inline_docs_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_inline_docs_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_inline_docs_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenInlineDocsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenInlineDocs *
foo_igen_inline_docs_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_INLINE_DOCS (ret);
  else
    return NULL;
}

/**
 * foo_igen_inline_docs_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_inline_docs_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_inline_docs_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenInlineDocsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenInlineDocs *
foo_igen_inline_docs_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_INLINE_DOCS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.InlineDocs", NULL);
  if (ret != NULL)
    return FOO_IGEN_INLINE_DOCS (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenInlineDocsSkeleton:
 *
 * The #FooiGenInlineDocsSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenInlineDocsSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenInlineDocsSkeleton.
 */

struct _FooiGenInlineDocsSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_foo_igen_inline_docs_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenInlineDocsSkeleton *skeleton = FOO_IGEN_INLINE_DOCS_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_INLINE_DOCS);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_INLINE_DOCS);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_inline_docs_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenInlineDocsSkeleton *skeleton = FOO_IGEN_INLINE_DOCS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_inline_docs_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_inline_docs_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenInlineDocsSkeleton *skeleton = FOO_IGEN_INLINE_DOCS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_inline_docs_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_inline_docs_skeleton_vtable =
{
  _foo_igen_inline_docs_skeleton_handle_method_call,
  _foo_igen_inline_docs_skeleton_handle_get_property,
  _foo_igen_inline_docs_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
foo_igen_inline_docs_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return foo_igen_inline_docs_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_inline_docs_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_foo_igen_inline_docs_skeleton_vtable;
}

static GVariant *
foo_igen_inline_docs_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenInlineDocsSkeleton *skeleton = FOO_IGEN_INLINE_DOCS_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_inline_docs_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_inline_docs_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_inline_docs_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_inline_docs_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.InlineDocs", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _foo_igen_inline_docs_emit_changed (gpointer user_data);

static void
foo_igen_inline_docs_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenInlineDocsSkeleton *skeleton = FOO_IGEN_INLINE_DOCS_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _foo_igen_inline_docs_emit_changed (skeleton);
}

static void
_foo_igen_inline_docs_on_signal_bar_signal (
    FooiGenInlineDocs *object,
    const gchar *arg_blah,
    const gchar *arg_boo)
{
  FooiGenInlineDocsSkeleton *skeleton = FOO_IGEN_INLINE_DOCS_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(ss)",
                   arg_blah,
                   arg_boo));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.InlineDocs", "BarSignal",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void foo_igen_inline_docs_skeleton_iface_init (FooiGenInlineDocsIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenInlineDocsSkeleton, foo_igen_inline_docs_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (FooiGenInlineDocsSkeleton)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_INLINE_DOCS, foo_igen_inline_docs_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenInlineDocsSkeleton, foo_igen_inline_docs_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_INLINE_DOCS, foo_igen_inline_docs_skeleton_iface_init));

#endif
static void
foo_igen_inline_docs_skeleton_finalize (GObject *object)
{
  FooiGenInlineDocsSkeleton *skeleton = FOO_IGEN_INLINE_DOCS_SKELETON (object);
  guint n;
  for (n = 0; n < 6; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_inline_docs_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_inline_docs_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  FooiGenInlineDocsSkeleton *skeleton = FOO_IGEN_INLINE_DOCS_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 6);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_foo_igen_inline_docs_emit_changed (gpointer user_data)
{
  FooiGenInlineDocsSkeleton *skeleton = FOO_IGEN_INLINE_DOCS_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.project.InlineDocs",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_foo_igen_inline_docs_schedule_emit_changed (FooiGenInlineDocsSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
foo_igen_inline_docs_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  FooiGenInlineDocsSkeleton *skeleton = FOO_IGEN_INLINE_DOCS_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _foo_igen_inline_docs_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _foo_igen_inline_docs_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
foo_igen_inline_docs_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooiGenInlineDocsSkeleton *skeleton = FOO_IGEN_INLINE_DOCS_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 6);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _foo_igen_inline_docs_schedule_emit_changed (skeleton, _foo_igen_inline_docs_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
foo_igen_inline_docs_skeleton_init (FooiGenInlineDocsSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = foo_igen_inline_docs_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_INLINE_DOCS_SKELETON, FooiGenInlineDocsSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 6);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[2], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[3], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[4], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[5], G_TYPE_STRING);
}

static const gchar *
foo_igen_inline_docs_skeleton_get_baz_property (FooiGenInlineDocs *object)
{
  FooiGenInlineDocsSkeleton *skeleton = FOO_IGEN_INLINE_DOCS_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_inline_docs_skeleton_get_property2 (FooiGenInlineDocs *object)
{
  FooiGenInlineDocsSkeleton *skeleton = FOO_IGEN_INLINE_DOCS_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_inline_docs_skeleton_get_property3 (FooiGenInlineDocs *object)
{
  FooiGenInlineDocsSkeleton *skeleton = FOO_IGEN_INLINE_DOCS_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[2]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_inline_docs_skeleton_get_property4 (FooiGenInlineDocs *object)
{
  FooiGenInlineDocsSkeleton *skeleton = FOO_IGEN_INLINE_DOCS_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[3]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_inline_docs_skeleton_get_property5 (FooiGenInlineDocs *object)
{
  FooiGenInlineDocsSkeleton *skeleton = FOO_IGEN_INLINE_DOCS_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[4]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
foo_igen_inline_docs_skeleton_get_fancy_property (FooiGenInlineDocs *object)
{
  FooiGenInlineDocsSkeleton *skeleton = FOO_IGEN_INLINE_DOCS_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[5]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
foo_igen_inline_docs_skeleton_class_init (FooiGenInlineDocsSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_inline_docs_skeleton_finalize;
  gobject_class->get_property = foo_igen_inline_docs_skeleton_get_property;
  gobject_class->set_property = foo_igen_inline_docs_skeleton_set_property;
  gobject_class->notify       = foo_igen_inline_docs_skeleton_notify;


  foo_igen_inline_docs_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_inline_docs_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_inline_docs_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_inline_docs_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_inline_docs_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenInlineDocsSkeletonPrivate));
#endif
}

static void
foo_igen_inline_docs_skeleton_iface_init (FooiGenInlineDocsIface *iface)
{
  iface->bar_signal = _foo_igen_inline_docs_on_signal_bar_signal;
  iface->get_baz_property = foo_igen_inline_docs_skeleton_get_baz_property;
  iface->get_property2 = foo_igen_inline_docs_skeleton_get_property2;
  iface->get_property3 = foo_igen_inline_docs_skeleton_get_property3;
  iface->get_property4 = foo_igen_inline_docs_skeleton_get_property4;
  iface->get_property5 = foo_igen_inline_docs_skeleton_get_property5;
  iface->get_fancy_property = foo_igen_inline_docs_skeleton_get_fancy_property;
}

/**
 * foo_igen_inline_docs_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link>.
 *
 * Returns: (transfer full) (type FooiGenInlineDocsSkeleton): The skeleton object.
 */
FooiGenInlineDocs *
foo_igen_inline_docs_skeleton_new (void)
{
  return FOO_IGEN_INLINE_DOCS (g_object_new (FOO_IGEN_TYPE_INLINE_DOCS_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface ChangingInterfaceV1
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenChangingInterfaceV1
 * @title: FooiGenChangingInterfaceV1
 * @short_description: Generated C code for the ChangingInterfaceV1 D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-ChangingInterfaceV1.top_of_page">ChangingInterfaceV1</link> D-Bus interface in C.
 */

/* ---- Introspection data for ChangingInterfaceV1 ---- */

static const _ExtendedGDBusMethodInfo _foo_igen_changing_interface_v1_method_info_foo_method =
{
  {
    -1,
    (gchar *) "FooMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-foo-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_changing_interface_v1_method_info_bar_method =
{
  {
    -1,
    (gchar *) "BarMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-bar-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_changing_interface_v1_method_info_baz_method =
{
  {
    -1,
    (gchar *) "BazMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-baz-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_changing_interface_v1_method_info_pointers[] =
{
  &_foo_igen_changing_interface_v1_method_info_foo_method,
  &_foo_igen_changing_interface_v1_method_info_bar_method,
  &_foo_igen_changing_interface_v1_method_info_baz_method,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_igen_changing_interface_v1_signal_info_foo_signal =
{
  {
    -1,
    (gchar *) "FooSignal",
    NULL,
    NULL
  },
  "foo-signal"
};

static const _ExtendedGDBusSignalInfo _foo_igen_changing_interface_v1_signal_info_bar_signal =
{
  {
    -1,
    (gchar *) "BarSignal",
    NULL,
    NULL
  },
  "bar-signal"
};

static const _ExtendedGDBusSignalInfo _foo_igen_changing_interface_v1_signal_info_baz_signal =
{
  {
    -1,
    (gchar *) "BazSignal",
    NULL,
    NULL
  },
  "baz-signal"
};

static const _ExtendedGDBusSignalInfo * const _foo_igen_changing_interface_v1_signal_info_pointers[] =
{
  &_foo_igen_changing_interface_v1_signal_info_foo_signal,
  &_foo_igen_changing_interface_v1_signal_info_bar_signal,
  &_foo_igen_changing_interface_v1_signal_info_baz_signal,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_changing_interface_v1_interface_info =
{
  {
    -1,
    (gchar *) "ChangingInterfaceV1",
    (GDBusMethodInfo **) &_foo_igen_changing_interface_v1_method_info_pointers,
    (GDBusSignalInfo **) &_foo_igen_changing_interface_v1_signal_info_pointers,
    NULL,
    NULL
  },
  "changing-interface-v1",
};


/**
 * foo_igen_changing_interface_v1_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-ChangingInterfaceV1.top_of_page">ChangingInterfaceV1</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_changing_interface_v1_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_changing_interface_v1_interface_info.parent_struct;
}

/**
 * foo_igen_changing_interface_v1_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenChangingInterfaceV1 interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_changing_interface_v1_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * FooiGenChangingInterfaceV1:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV1.top_of_page">ChangingInterfaceV1</link>.
 */

/**
 * FooiGenChangingInterfaceV1Iface:
 * @parent_iface: The parent interface.
 * @handle_bar_method: Handler for the #FooiGenChangingInterfaceV1::handle-bar-method signal.
 * @handle_baz_method: Handler for the #FooiGenChangingInterfaceV1::handle-baz-method signal.
 * @handle_foo_method: Handler for the #FooiGenChangingInterfaceV1::handle-foo-method signal.
 * @bar_signal: Handler for the #FooiGenChangingInterfaceV1::bar-signal signal.
 * @baz_signal: Handler for the #FooiGenChangingInterfaceV1::baz-signal signal.
 * @foo_signal: Handler for the #FooiGenChangingInterfaceV1::foo-signal signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV1.top_of_page">ChangingInterfaceV1</link>.
 */

typedef FooiGenChangingInterfaceV1Iface FooiGenChangingInterfaceV1Interface;
G_DEFINE_INTERFACE (FooiGenChangingInterfaceV1, foo_igen_changing_interface_v1, G_TYPE_OBJECT);

static void
foo_igen_changing_interface_v1_default_init (FooiGenChangingInterfaceV1Iface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenChangingInterfaceV1::handle-foo-method:
   * @object: A #FooiGenChangingInterfaceV1.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV1.FooMethod">FooMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_changing_interface_v1_complete_foo_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-foo-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV1Iface, handle_foo_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooiGenChangingInterfaceV1::handle-bar-method:
   * @object: A #FooiGenChangingInterfaceV1.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV1.BarMethod">BarMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_changing_interface_v1_complete_bar_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-bar-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV1Iface, handle_bar_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooiGenChangingInterfaceV1::handle-baz-method:
   * @object: A #FooiGenChangingInterfaceV1.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV1.BazMethod">BazMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_changing_interface_v1_complete_baz_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-baz-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV1Iface, handle_baz_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooiGenChangingInterfaceV1::foo-signal:
   * @object: A #FooiGenChangingInterfaceV1.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV1.FooSignal">"FooSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("foo-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV1Iface, foo_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * FooiGenChangingInterfaceV1::bar-signal:
   * @object: A #FooiGenChangingInterfaceV1.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV1.BarSignal">"BarSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("bar-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV1Iface, bar_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * FooiGenChangingInterfaceV1::baz-signal:
   * @object: A #FooiGenChangingInterfaceV1.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV1.BazSignal">"BazSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("baz-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV1Iface, baz_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

}

/**
 * foo_igen_changing_interface_v1_emit_foo_signal:
 * @object: A #FooiGenChangingInterfaceV1.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV1.FooSignal">"FooSignal"</link> D-Bus signal.
 */
void
foo_igen_changing_interface_v1_emit_foo_signal (
    FooiGenChangingInterfaceV1 *object)
{
  g_signal_emit_by_name (object, "foo-signal");
}

/**
 * foo_igen_changing_interface_v1_emit_bar_signal:
 * @object: A #FooiGenChangingInterfaceV1.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV1.BarSignal">"BarSignal"</link> D-Bus signal.
 */
void
foo_igen_changing_interface_v1_emit_bar_signal (
    FooiGenChangingInterfaceV1 *object)
{
  g_signal_emit_by_name (object, "bar-signal");
}

/**
 * foo_igen_changing_interface_v1_emit_baz_signal:
 * @object: A #FooiGenChangingInterfaceV1.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV1.BazSignal">"BazSignal"</link> D-Bus signal.
 */
void
foo_igen_changing_interface_v1_emit_baz_signal (
    FooiGenChangingInterfaceV1 *object)
{
  g_signal_emit_by_name (object, "baz-signal");
}

/**
 * foo_igen_changing_interface_v1_call_foo_method:
 * @proxy: A #FooiGenChangingInterfaceV1Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV1.FooMethod">FooMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_changing_interface_v1_call_foo_method_finish() to get the result of the operation.
 *
 * See foo_igen_changing_interface_v1_call_foo_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_changing_interface_v1_call_foo_method (
    FooiGenChangingInterfaceV1 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "FooMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_changing_interface_v1_call_foo_method_finish:
 * @proxy: A #FooiGenChangingInterfaceV1Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_changing_interface_v1_call_foo_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_changing_interface_v1_call_foo_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_changing_interface_v1_call_foo_method_finish (
    FooiGenChangingInterfaceV1 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v1_call_foo_method_sync:
 * @proxy: A #FooiGenChangingInterfaceV1Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV1.FooMethod">FooMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_changing_interface_v1_call_foo_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_changing_interface_v1_call_foo_method_sync (
    FooiGenChangingInterfaceV1 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "FooMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v1_call_bar_method:
 * @proxy: A #FooiGenChangingInterfaceV1Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV1.BarMethod">BarMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_changing_interface_v1_call_bar_method_finish() to get the result of the operation.
 *
 * See foo_igen_changing_interface_v1_call_bar_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_changing_interface_v1_call_bar_method (
    FooiGenChangingInterfaceV1 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "BarMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_changing_interface_v1_call_bar_method_finish:
 * @proxy: A #FooiGenChangingInterfaceV1Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_changing_interface_v1_call_bar_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_changing_interface_v1_call_bar_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_changing_interface_v1_call_bar_method_finish (
    FooiGenChangingInterfaceV1 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v1_call_bar_method_sync:
 * @proxy: A #FooiGenChangingInterfaceV1Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV1.BarMethod">BarMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_changing_interface_v1_call_bar_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_changing_interface_v1_call_bar_method_sync (
    FooiGenChangingInterfaceV1 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "BarMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v1_call_baz_method:
 * @proxy: A #FooiGenChangingInterfaceV1Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV1.BazMethod">BazMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_changing_interface_v1_call_baz_method_finish() to get the result of the operation.
 *
 * See foo_igen_changing_interface_v1_call_baz_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_changing_interface_v1_call_baz_method (
    FooiGenChangingInterfaceV1 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "BazMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_changing_interface_v1_call_baz_method_finish:
 * @proxy: A #FooiGenChangingInterfaceV1Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_changing_interface_v1_call_baz_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_changing_interface_v1_call_baz_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_changing_interface_v1_call_baz_method_finish (
    FooiGenChangingInterfaceV1 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v1_call_baz_method_sync:
 * @proxy: A #FooiGenChangingInterfaceV1Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV1.BazMethod">BazMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_changing_interface_v1_call_baz_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_changing_interface_v1_call_baz_method_sync (
    FooiGenChangingInterfaceV1 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "BazMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v1_complete_foo_method:
 * @object: A #FooiGenChangingInterfaceV1.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV1.FooMethod">FooMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_changing_interface_v1_complete_foo_method (
    FooiGenChangingInterfaceV1 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_changing_interface_v1_complete_bar_method:
 * @object: A #FooiGenChangingInterfaceV1.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV1.BarMethod">BarMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_changing_interface_v1_complete_bar_method (
    FooiGenChangingInterfaceV1 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_changing_interface_v1_complete_baz_method:
 * @object: A #FooiGenChangingInterfaceV1.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV1.BazMethod">BazMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_changing_interface_v1_complete_baz_method (
    FooiGenChangingInterfaceV1 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenChangingInterfaceV1Proxy:
 *
 * The #FooiGenChangingInterfaceV1Proxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenChangingInterfaceV1ProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenChangingInterfaceV1Proxy.
 */

struct _FooiGenChangingInterfaceV1ProxyPrivate
{
  GData *qdata;
};

static void foo_igen_changing_interface_v1_proxy_iface_init (FooiGenChangingInterfaceV1Iface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenChangingInterfaceV1Proxy, foo_igen_changing_interface_v1_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (FooiGenChangingInterfaceV1Proxy)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_CHANGING_INTERFACE_V1, foo_igen_changing_interface_v1_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenChangingInterfaceV1Proxy, foo_igen_changing_interface_v1_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_CHANGING_INTERFACE_V1, foo_igen_changing_interface_v1_proxy_iface_init));

#endif
static void
foo_igen_changing_interface_v1_proxy_finalize (GObject *object)
{
  FooiGenChangingInterfaceV1Proxy *proxy = FOO_IGEN_CHANGING_INTERFACE_V1_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_changing_interface_v1_proxy_parent_class)->finalize (object);
}

static void
foo_igen_changing_interface_v1_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
foo_igen_changing_interface_v1_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
foo_igen_changing_interface_v1_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_changing_interface_v1_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_CHANGING_INTERFACE_V1);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_CHANGING_INTERFACE_V1);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_changing_interface_v1_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenChangingInterfaceV1Proxy *proxy = FOO_IGEN_CHANGING_INTERFACE_V1_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_changing_interface_v1_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_changing_interface_v1_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_igen_changing_interface_v1_proxy_init (FooiGenChangingInterfaceV1Proxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = foo_igen_changing_interface_v1_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_CHANGING_INTERFACE_V1_PROXY, FooiGenChangingInterfaceV1ProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_changing_interface_v1_interface_info ());
}

static void
foo_igen_changing_interface_v1_proxy_class_init (FooiGenChangingInterfaceV1ProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_changing_interface_v1_proxy_finalize;
  gobject_class->get_property = foo_igen_changing_interface_v1_proxy_get_property;
  gobject_class->set_property = foo_igen_changing_interface_v1_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_changing_interface_v1_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_changing_interface_v1_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenChangingInterfaceV1ProxyPrivate));
#endif
}

static void
foo_igen_changing_interface_v1_proxy_iface_init (FooiGenChangingInterfaceV1Iface *iface)
{
}

/**
 * foo_igen_changing_interface_v1_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV1.top_of_page">ChangingInterfaceV1</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_changing_interface_v1_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_changing_interface_v1_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_changing_interface_v1_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_CHANGING_INTERFACE_V1_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV1", NULL);
}

/**
 * foo_igen_changing_interface_v1_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_changing_interface_v1_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_changing_interface_v1_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenChangingInterfaceV1Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenChangingInterfaceV1 *
foo_igen_changing_interface_v1_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_CHANGING_INTERFACE_V1 (ret);
  else
    return NULL;
}

/**
 * foo_igen_changing_interface_v1_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV1.top_of_page">ChangingInterfaceV1</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_changing_interface_v1_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenChangingInterfaceV1Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenChangingInterfaceV1 *
foo_igen_changing_interface_v1_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_CHANGING_INTERFACE_V1_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV1", NULL);
  if (ret != NULL)
    return FOO_IGEN_CHANGING_INTERFACE_V1 (ret);
  else
    return NULL;
}


/**
 * foo_igen_changing_interface_v1_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_changing_interface_v1_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_changing_interface_v1_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_changing_interface_v1_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_changing_interface_v1_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_CHANGING_INTERFACE_V1_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV1", NULL);
}

/**
 * foo_igen_changing_interface_v1_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_changing_interface_v1_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_changing_interface_v1_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenChangingInterfaceV1Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenChangingInterfaceV1 *
foo_igen_changing_interface_v1_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_CHANGING_INTERFACE_V1 (ret);
  else
    return NULL;
}

/**
 * foo_igen_changing_interface_v1_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_changing_interface_v1_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_changing_interface_v1_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenChangingInterfaceV1Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenChangingInterfaceV1 *
foo_igen_changing_interface_v1_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_CHANGING_INTERFACE_V1_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV1", NULL);
  if (ret != NULL)
    return FOO_IGEN_CHANGING_INTERFACE_V1 (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenChangingInterfaceV1Skeleton:
 *
 * The #FooiGenChangingInterfaceV1Skeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenChangingInterfaceV1SkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenChangingInterfaceV1Skeleton.
 */

struct _FooiGenChangingInterfaceV1SkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_foo_igen_changing_interface_v1_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenChangingInterfaceV1Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V1_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_CHANGING_INTERFACE_V1);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_CHANGING_INTERFACE_V1);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_changing_interface_v1_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenChangingInterfaceV1Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V1_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_changing_interface_v1_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_changing_interface_v1_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenChangingInterfaceV1Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V1_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_changing_interface_v1_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_changing_interface_v1_skeleton_vtable =
{
  _foo_igen_changing_interface_v1_skeleton_handle_method_call,
  _foo_igen_changing_interface_v1_skeleton_handle_get_property,
  _foo_igen_changing_interface_v1_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
foo_igen_changing_interface_v1_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return foo_igen_changing_interface_v1_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_changing_interface_v1_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_foo_igen_changing_interface_v1_skeleton_vtable;
}

static GVariant *
foo_igen_changing_interface_v1_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenChangingInterfaceV1Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V1_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_changing_interface_v1_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_changing_interface_v1_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_changing_interface_v1_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_changing_interface_v1_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV1", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
foo_igen_changing_interface_v1_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void
_foo_igen_changing_interface_v1_on_signal_foo_signal (
    FooiGenChangingInterfaceV1 *object)
{
  FooiGenChangingInterfaceV1Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V1_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV1", "FooSignal",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_foo_igen_changing_interface_v1_on_signal_bar_signal (
    FooiGenChangingInterfaceV1 *object)
{
  FooiGenChangingInterfaceV1Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V1_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV1", "BarSignal",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_foo_igen_changing_interface_v1_on_signal_baz_signal (
    FooiGenChangingInterfaceV1 *object)
{
  FooiGenChangingInterfaceV1Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V1_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV1", "BazSignal",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void foo_igen_changing_interface_v1_skeleton_iface_init (FooiGenChangingInterfaceV1Iface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenChangingInterfaceV1Skeleton, foo_igen_changing_interface_v1_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (FooiGenChangingInterfaceV1Skeleton)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_CHANGING_INTERFACE_V1, foo_igen_changing_interface_v1_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenChangingInterfaceV1Skeleton, foo_igen_changing_interface_v1_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_CHANGING_INTERFACE_V1, foo_igen_changing_interface_v1_skeleton_iface_init));

#endif
static void
foo_igen_changing_interface_v1_skeleton_finalize (GObject *object)
{
  FooiGenChangingInterfaceV1Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V1_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_changing_interface_v1_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_changing_interface_v1_skeleton_init (FooiGenChangingInterfaceV1Skeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = foo_igen_changing_interface_v1_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_CHANGING_INTERFACE_V1_SKELETON, FooiGenChangingInterfaceV1SkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
foo_igen_changing_interface_v1_skeleton_class_init (FooiGenChangingInterfaceV1SkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_changing_interface_v1_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_changing_interface_v1_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_changing_interface_v1_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_changing_interface_v1_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_changing_interface_v1_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenChangingInterfaceV1SkeletonPrivate));
#endif
}

static void
foo_igen_changing_interface_v1_skeleton_iface_init (FooiGenChangingInterfaceV1Iface *iface)
{
  iface->foo_signal = _foo_igen_changing_interface_v1_on_signal_foo_signal;
  iface->bar_signal = _foo_igen_changing_interface_v1_on_signal_bar_signal;
  iface->baz_signal = _foo_igen_changing_interface_v1_on_signal_baz_signal;
}

/**
 * foo_igen_changing_interface_v1_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV1.top_of_page">ChangingInterfaceV1</link>.
 *
 * Returns: (transfer full) (type FooiGenChangingInterfaceV1Skeleton): The skeleton object.
 */
FooiGenChangingInterfaceV1 *
foo_igen_changing_interface_v1_skeleton_new (void)
{
  return FOO_IGEN_CHANGING_INTERFACE_V1 (g_object_new (FOO_IGEN_TYPE_CHANGING_INTERFACE_V1_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface ChangingInterfaceV2
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenChangingInterfaceV2
 * @title: FooiGenChangingInterfaceV2
 * @short_description: Generated C code for the ChangingInterfaceV2 D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-ChangingInterfaceV2.top_of_page">ChangingInterfaceV2</link> D-Bus interface in C.
 */

/* ---- Introspection data for ChangingInterfaceV2 ---- */

static const _ExtendedGDBusMethodInfo _foo_igen_changing_interface_v2_method_info_new_method_in2 =
{
  {
    -1,
    (gchar *) "NewMethodIn2",
    NULL,
    NULL,
    NULL
  },
  "handle-new-method-in2",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_changing_interface_v2_method_info_baz_method =
{
  {
    -1,
    (gchar *) "BazMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-baz-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_changing_interface_v2_method_info_bar_method =
{
  {
    -1,
    (gchar *) "BarMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-bar-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_changing_interface_v2_method_info_foo_method =
{
  {
    -1,
    (gchar *) "FooMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-foo-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_changing_interface_v2_method_info_pointers[] =
{
  &_foo_igen_changing_interface_v2_method_info_new_method_in2,
  &_foo_igen_changing_interface_v2_method_info_baz_method,
  &_foo_igen_changing_interface_v2_method_info_bar_method,
  &_foo_igen_changing_interface_v2_method_info_foo_method,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_igen_changing_interface_v2_signal_info_new_signal_in2 =
{
  {
    -1,
    (gchar *) "NewSignalIn2",
    NULL,
    NULL
  },
  "new-signal-in2"
};

static const _ExtendedGDBusSignalInfo _foo_igen_changing_interface_v2_signal_info_baz_signal =
{
  {
    -1,
    (gchar *) "BazSignal",
    NULL,
    NULL
  },
  "baz-signal"
};

static const _ExtendedGDBusSignalInfo _foo_igen_changing_interface_v2_signal_info_bar_signal =
{
  {
    -1,
    (gchar *) "BarSignal",
    NULL,
    NULL
  },
  "bar-signal"
};

static const _ExtendedGDBusSignalInfo _foo_igen_changing_interface_v2_signal_info_foo_signal =
{
  {
    -1,
    (gchar *) "FooSignal",
    NULL,
    NULL
  },
  "foo-signal"
};

static const _ExtendedGDBusSignalInfo * const _foo_igen_changing_interface_v2_signal_info_pointers[] =
{
  &_foo_igen_changing_interface_v2_signal_info_new_signal_in2,
  &_foo_igen_changing_interface_v2_signal_info_baz_signal,
  &_foo_igen_changing_interface_v2_signal_info_bar_signal,
  &_foo_igen_changing_interface_v2_signal_info_foo_signal,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_changing_interface_v2_interface_info =
{
  {
    -1,
    (gchar *) "ChangingInterfaceV2",
    (GDBusMethodInfo **) &_foo_igen_changing_interface_v2_method_info_pointers,
    (GDBusSignalInfo **) &_foo_igen_changing_interface_v2_signal_info_pointers,
    NULL,
    NULL
  },
  "changing-interface-v2",
};


/**
 * foo_igen_changing_interface_v2_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-ChangingInterfaceV2.top_of_page">ChangingInterfaceV2</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_changing_interface_v2_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_changing_interface_v2_interface_info.parent_struct;
}

/**
 * foo_igen_changing_interface_v2_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenChangingInterfaceV2 interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_changing_interface_v2_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * FooiGenChangingInterfaceV2:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV2.top_of_page">ChangingInterfaceV2</link>.
 */

/**
 * FooiGenChangingInterfaceV2Iface:
 * @parent_iface: The parent interface.
 * @handle_bar_method: Handler for the #FooiGenChangingInterfaceV2::handle-bar-method signal.
 * @handle_baz_method: Handler for the #FooiGenChangingInterfaceV2::handle-baz-method signal.
 * @handle_foo_method: Handler for the #FooiGenChangingInterfaceV2::handle-foo-method signal.
 * @bar_signal: Handler for the #FooiGenChangingInterfaceV2::bar-signal signal.
 * @baz_signal: Handler for the #FooiGenChangingInterfaceV2::baz-signal signal.
 * @foo_signal: Handler for the #FooiGenChangingInterfaceV2::foo-signal signal.
 * @handle_new_method_in2: Handler for the #FooiGenChangingInterfaceV2::handle-new-method-in2 signal.
 * @new_signal_in2: Handler for the #FooiGenChangingInterfaceV2::new-signal-in2 signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV2.top_of_page">ChangingInterfaceV2</link>.
 */

typedef FooiGenChangingInterfaceV2Iface FooiGenChangingInterfaceV2Interface;
G_DEFINE_INTERFACE (FooiGenChangingInterfaceV2, foo_igen_changing_interface_v2, G_TYPE_OBJECT);

static void
foo_igen_changing_interface_v2_default_init (FooiGenChangingInterfaceV2Iface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenChangingInterfaceV2::handle-new-method-in2:
   * @object: A #FooiGenChangingInterfaceV2.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV2.NewMethodIn2">NewMethodIn2()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_changing_interface_v2_complete_new_method_in2() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   *
   * Since: 2.0
   */
  g_signal_new ("handle-new-method-in2",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV2Iface, handle_new_method_in2),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooiGenChangingInterfaceV2::handle-baz-method:
   * @object: A #FooiGenChangingInterfaceV2.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV2.BazMethod">BazMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_changing_interface_v2_complete_baz_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-baz-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV2Iface, handle_baz_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooiGenChangingInterfaceV2::handle-bar-method:
   * @object: A #FooiGenChangingInterfaceV2.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV2.BarMethod">BarMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_changing_interface_v2_complete_bar_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-bar-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV2Iface, handle_bar_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooiGenChangingInterfaceV2::handle-foo-method:
   * @object: A #FooiGenChangingInterfaceV2.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV2.FooMethod">FooMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_changing_interface_v2_complete_foo_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-foo-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV2Iface, handle_foo_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooiGenChangingInterfaceV2::new-signal-in2:
   * @object: A #FooiGenChangingInterfaceV2.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV2.NewSignalIn2">"NewSignalIn2"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   *
   * Since: 2.0
   */
  g_signal_new ("new-signal-in2",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV2Iface, new_signal_in2),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * FooiGenChangingInterfaceV2::baz-signal:
   * @object: A #FooiGenChangingInterfaceV2.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV2.BazSignal">"BazSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("baz-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV2Iface, baz_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * FooiGenChangingInterfaceV2::bar-signal:
   * @object: A #FooiGenChangingInterfaceV2.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV2.BarSignal">"BarSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("bar-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV2Iface, bar_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * FooiGenChangingInterfaceV2::foo-signal:
   * @object: A #FooiGenChangingInterfaceV2.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV2.FooSignal">"FooSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("foo-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV2Iface, foo_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

}

/**
 * foo_igen_changing_interface_v2_emit_new_signal_in2:
 * @object: A #FooiGenChangingInterfaceV2.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV2.NewSignalIn2">"NewSignalIn2"</link> D-Bus signal.
 *
 * Since: 2.0
 */
void
foo_igen_changing_interface_v2_emit_new_signal_in2 (
    FooiGenChangingInterfaceV2 *object)
{
  g_signal_emit_by_name (object, "new-signal-in2");
}

/**
 * foo_igen_changing_interface_v2_emit_baz_signal:
 * @object: A #FooiGenChangingInterfaceV2.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV2.BazSignal">"BazSignal"</link> D-Bus signal.
 */
void
foo_igen_changing_interface_v2_emit_baz_signal (
    FooiGenChangingInterfaceV2 *object)
{
  g_signal_emit_by_name (object, "baz-signal");
}

/**
 * foo_igen_changing_interface_v2_emit_bar_signal:
 * @object: A #FooiGenChangingInterfaceV2.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV2.BarSignal">"BarSignal"</link> D-Bus signal.
 */
void
foo_igen_changing_interface_v2_emit_bar_signal (
    FooiGenChangingInterfaceV2 *object)
{
  g_signal_emit_by_name (object, "bar-signal");
}

/**
 * foo_igen_changing_interface_v2_emit_foo_signal:
 * @object: A #FooiGenChangingInterfaceV2.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV2.FooSignal">"FooSignal"</link> D-Bus signal.
 */
void
foo_igen_changing_interface_v2_emit_foo_signal (
    FooiGenChangingInterfaceV2 *object)
{
  g_signal_emit_by_name (object, "foo-signal");
}

/**
 * foo_igen_changing_interface_v2_call_new_method_in2:
 * @proxy: A #FooiGenChangingInterfaceV2Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV2.NewMethodIn2">NewMethodIn2()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_changing_interface_v2_call_new_method_in2_finish() to get the result of the operation.
 *
 * See foo_igen_changing_interface_v2_call_new_method_in2_sync() for the synchronous, blocking version of this method.
 *
 * Since: 2.0
 */
void
foo_igen_changing_interface_v2_call_new_method_in2 (
    FooiGenChangingInterfaceV2 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "NewMethodIn2",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_changing_interface_v2_call_new_method_in2_finish:
 * @proxy: A #FooiGenChangingInterfaceV2Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_changing_interface_v2_call_new_method_in2().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_changing_interface_v2_call_new_method_in2().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 *
 * Since: 2.0
 */
gboolean
foo_igen_changing_interface_v2_call_new_method_in2_finish (
    FooiGenChangingInterfaceV2 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v2_call_new_method_in2_sync:
 * @proxy: A #FooiGenChangingInterfaceV2Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV2.NewMethodIn2">NewMethodIn2()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_changing_interface_v2_call_new_method_in2() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 *
 * Since: 2.0
 */
gboolean
foo_igen_changing_interface_v2_call_new_method_in2_sync (
    FooiGenChangingInterfaceV2 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "NewMethodIn2",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v2_call_baz_method:
 * @proxy: A #FooiGenChangingInterfaceV2Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV2.BazMethod">BazMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_changing_interface_v2_call_baz_method_finish() to get the result of the operation.
 *
 * See foo_igen_changing_interface_v2_call_baz_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_changing_interface_v2_call_baz_method (
    FooiGenChangingInterfaceV2 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "BazMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_changing_interface_v2_call_baz_method_finish:
 * @proxy: A #FooiGenChangingInterfaceV2Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_changing_interface_v2_call_baz_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_changing_interface_v2_call_baz_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_changing_interface_v2_call_baz_method_finish (
    FooiGenChangingInterfaceV2 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v2_call_baz_method_sync:
 * @proxy: A #FooiGenChangingInterfaceV2Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV2.BazMethod">BazMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_changing_interface_v2_call_baz_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_changing_interface_v2_call_baz_method_sync (
    FooiGenChangingInterfaceV2 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "BazMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v2_call_bar_method:
 * @proxy: A #FooiGenChangingInterfaceV2Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV2.BarMethod">BarMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_changing_interface_v2_call_bar_method_finish() to get the result of the operation.
 *
 * See foo_igen_changing_interface_v2_call_bar_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_changing_interface_v2_call_bar_method (
    FooiGenChangingInterfaceV2 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "BarMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_changing_interface_v2_call_bar_method_finish:
 * @proxy: A #FooiGenChangingInterfaceV2Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_changing_interface_v2_call_bar_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_changing_interface_v2_call_bar_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_changing_interface_v2_call_bar_method_finish (
    FooiGenChangingInterfaceV2 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v2_call_bar_method_sync:
 * @proxy: A #FooiGenChangingInterfaceV2Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV2.BarMethod">BarMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_changing_interface_v2_call_bar_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_changing_interface_v2_call_bar_method_sync (
    FooiGenChangingInterfaceV2 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "BarMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v2_call_foo_method:
 * @proxy: A #FooiGenChangingInterfaceV2Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV2.FooMethod">FooMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_changing_interface_v2_call_foo_method_finish() to get the result of the operation.
 *
 * See foo_igen_changing_interface_v2_call_foo_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_changing_interface_v2_call_foo_method (
    FooiGenChangingInterfaceV2 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "FooMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_changing_interface_v2_call_foo_method_finish:
 * @proxy: A #FooiGenChangingInterfaceV2Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_changing_interface_v2_call_foo_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_changing_interface_v2_call_foo_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_changing_interface_v2_call_foo_method_finish (
    FooiGenChangingInterfaceV2 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v2_call_foo_method_sync:
 * @proxy: A #FooiGenChangingInterfaceV2Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV2.FooMethod">FooMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_changing_interface_v2_call_foo_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_changing_interface_v2_call_foo_method_sync (
    FooiGenChangingInterfaceV2 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "FooMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v2_complete_new_method_in2:
 * @object: A #FooiGenChangingInterfaceV2.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV2.NewMethodIn2">NewMethodIn2()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 *
 * Since: 2.0
 */
void
foo_igen_changing_interface_v2_complete_new_method_in2 (
    FooiGenChangingInterfaceV2 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_changing_interface_v2_complete_baz_method:
 * @object: A #FooiGenChangingInterfaceV2.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV2.BazMethod">BazMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_changing_interface_v2_complete_baz_method (
    FooiGenChangingInterfaceV2 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_changing_interface_v2_complete_bar_method:
 * @object: A #FooiGenChangingInterfaceV2.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV2.BarMethod">BarMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_changing_interface_v2_complete_bar_method (
    FooiGenChangingInterfaceV2 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_changing_interface_v2_complete_foo_method:
 * @object: A #FooiGenChangingInterfaceV2.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV2.FooMethod">FooMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_changing_interface_v2_complete_foo_method (
    FooiGenChangingInterfaceV2 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenChangingInterfaceV2Proxy:
 *
 * The #FooiGenChangingInterfaceV2Proxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenChangingInterfaceV2ProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenChangingInterfaceV2Proxy.
 */

struct _FooiGenChangingInterfaceV2ProxyPrivate
{
  GData *qdata;
};

static void foo_igen_changing_interface_v2_proxy_iface_init (FooiGenChangingInterfaceV2Iface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenChangingInterfaceV2Proxy, foo_igen_changing_interface_v2_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (FooiGenChangingInterfaceV2Proxy)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_CHANGING_INTERFACE_V2, foo_igen_changing_interface_v2_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenChangingInterfaceV2Proxy, foo_igen_changing_interface_v2_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_CHANGING_INTERFACE_V2, foo_igen_changing_interface_v2_proxy_iface_init));

#endif
static void
foo_igen_changing_interface_v2_proxy_finalize (GObject *object)
{
  FooiGenChangingInterfaceV2Proxy *proxy = FOO_IGEN_CHANGING_INTERFACE_V2_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_changing_interface_v2_proxy_parent_class)->finalize (object);
}

static void
foo_igen_changing_interface_v2_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
foo_igen_changing_interface_v2_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
foo_igen_changing_interface_v2_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_changing_interface_v2_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_CHANGING_INTERFACE_V2);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_CHANGING_INTERFACE_V2);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_changing_interface_v2_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenChangingInterfaceV2Proxy *proxy = FOO_IGEN_CHANGING_INTERFACE_V2_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_changing_interface_v2_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_changing_interface_v2_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_igen_changing_interface_v2_proxy_init (FooiGenChangingInterfaceV2Proxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = foo_igen_changing_interface_v2_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_CHANGING_INTERFACE_V2_PROXY, FooiGenChangingInterfaceV2ProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_changing_interface_v2_interface_info ());
}

static void
foo_igen_changing_interface_v2_proxy_class_init (FooiGenChangingInterfaceV2ProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_changing_interface_v2_proxy_finalize;
  gobject_class->get_property = foo_igen_changing_interface_v2_proxy_get_property;
  gobject_class->set_property = foo_igen_changing_interface_v2_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_changing_interface_v2_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_changing_interface_v2_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenChangingInterfaceV2ProxyPrivate));
#endif
}

static void
foo_igen_changing_interface_v2_proxy_iface_init (FooiGenChangingInterfaceV2Iface *iface)
{
}

/**
 * foo_igen_changing_interface_v2_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV2.top_of_page">ChangingInterfaceV2</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_changing_interface_v2_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_changing_interface_v2_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_changing_interface_v2_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_CHANGING_INTERFACE_V2_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV2", NULL);
}

/**
 * foo_igen_changing_interface_v2_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_changing_interface_v2_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_changing_interface_v2_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenChangingInterfaceV2Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenChangingInterfaceV2 *
foo_igen_changing_interface_v2_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_CHANGING_INTERFACE_V2 (ret);
  else
    return NULL;
}

/**
 * foo_igen_changing_interface_v2_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV2.top_of_page">ChangingInterfaceV2</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_changing_interface_v2_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenChangingInterfaceV2Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenChangingInterfaceV2 *
foo_igen_changing_interface_v2_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_CHANGING_INTERFACE_V2_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV2", NULL);
  if (ret != NULL)
    return FOO_IGEN_CHANGING_INTERFACE_V2 (ret);
  else
    return NULL;
}


/**
 * foo_igen_changing_interface_v2_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_changing_interface_v2_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_changing_interface_v2_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_changing_interface_v2_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_changing_interface_v2_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_CHANGING_INTERFACE_V2_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV2", NULL);
}

/**
 * foo_igen_changing_interface_v2_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_changing_interface_v2_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_changing_interface_v2_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenChangingInterfaceV2Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenChangingInterfaceV2 *
foo_igen_changing_interface_v2_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_CHANGING_INTERFACE_V2 (ret);
  else
    return NULL;
}

/**
 * foo_igen_changing_interface_v2_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_changing_interface_v2_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_changing_interface_v2_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenChangingInterfaceV2Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenChangingInterfaceV2 *
foo_igen_changing_interface_v2_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_CHANGING_INTERFACE_V2_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV2", NULL);
  if (ret != NULL)
    return FOO_IGEN_CHANGING_INTERFACE_V2 (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenChangingInterfaceV2Skeleton:
 *
 * The #FooiGenChangingInterfaceV2Skeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenChangingInterfaceV2SkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenChangingInterfaceV2Skeleton.
 */

struct _FooiGenChangingInterfaceV2SkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_foo_igen_changing_interface_v2_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenChangingInterfaceV2Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V2_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_CHANGING_INTERFACE_V2);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_CHANGING_INTERFACE_V2);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_changing_interface_v2_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenChangingInterfaceV2Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V2_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_changing_interface_v2_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_changing_interface_v2_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenChangingInterfaceV2Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V2_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_changing_interface_v2_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_changing_interface_v2_skeleton_vtable =
{
  _foo_igen_changing_interface_v2_skeleton_handle_method_call,
  _foo_igen_changing_interface_v2_skeleton_handle_get_property,
  _foo_igen_changing_interface_v2_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
foo_igen_changing_interface_v2_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return foo_igen_changing_interface_v2_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_changing_interface_v2_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_foo_igen_changing_interface_v2_skeleton_vtable;
}

static GVariant *
foo_igen_changing_interface_v2_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenChangingInterfaceV2Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V2_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_changing_interface_v2_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_changing_interface_v2_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_changing_interface_v2_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_changing_interface_v2_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV2", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
foo_igen_changing_interface_v2_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void
_foo_igen_changing_interface_v2_on_signal_new_signal_in2 (
    FooiGenChangingInterfaceV2 *object)
{
  FooiGenChangingInterfaceV2Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V2_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV2", "NewSignalIn2",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_foo_igen_changing_interface_v2_on_signal_baz_signal (
    FooiGenChangingInterfaceV2 *object)
{
  FooiGenChangingInterfaceV2Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V2_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV2", "BazSignal",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_foo_igen_changing_interface_v2_on_signal_bar_signal (
    FooiGenChangingInterfaceV2 *object)
{
  FooiGenChangingInterfaceV2Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V2_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV2", "BarSignal",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_foo_igen_changing_interface_v2_on_signal_foo_signal (
    FooiGenChangingInterfaceV2 *object)
{
  FooiGenChangingInterfaceV2Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V2_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV2", "FooSignal",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void foo_igen_changing_interface_v2_skeleton_iface_init (FooiGenChangingInterfaceV2Iface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenChangingInterfaceV2Skeleton, foo_igen_changing_interface_v2_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (FooiGenChangingInterfaceV2Skeleton)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_CHANGING_INTERFACE_V2, foo_igen_changing_interface_v2_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenChangingInterfaceV2Skeleton, foo_igen_changing_interface_v2_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_CHANGING_INTERFACE_V2, foo_igen_changing_interface_v2_skeleton_iface_init));

#endif
static void
foo_igen_changing_interface_v2_skeleton_finalize (GObject *object)
{
  FooiGenChangingInterfaceV2Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V2_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_changing_interface_v2_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_changing_interface_v2_skeleton_init (FooiGenChangingInterfaceV2Skeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = foo_igen_changing_interface_v2_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_CHANGING_INTERFACE_V2_SKELETON, FooiGenChangingInterfaceV2SkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
foo_igen_changing_interface_v2_skeleton_class_init (FooiGenChangingInterfaceV2SkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_changing_interface_v2_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_changing_interface_v2_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_changing_interface_v2_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_changing_interface_v2_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_changing_interface_v2_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenChangingInterfaceV2SkeletonPrivate));
#endif
}

static void
foo_igen_changing_interface_v2_skeleton_iface_init (FooiGenChangingInterfaceV2Iface *iface)
{
  iface->new_signal_in2 = _foo_igen_changing_interface_v2_on_signal_new_signal_in2;
  iface->baz_signal = _foo_igen_changing_interface_v2_on_signal_baz_signal;
  iface->bar_signal = _foo_igen_changing_interface_v2_on_signal_bar_signal;
  iface->foo_signal = _foo_igen_changing_interface_v2_on_signal_foo_signal;
}

/**
 * foo_igen_changing_interface_v2_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV2.top_of_page">ChangingInterfaceV2</link>.
 *
 * Returns: (transfer full) (type FooiGenChangingInterfaceV2Skeleton): The skeleton object.
 */
FooiGenChangingInterfaceV2 *
foo_igen_changing_interface_v2_skeleton_new (void)
{
  return FOO_IGEN_CHANGING_INTERFACE_V2 (g_object_new (FOO_IGEN_TYPE_CHANGING_INTERFACE_V2_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface ChangingInterfaceV10
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenChangingInterfaceV10
 * @title: FooiGenChangingInterfaceV10
 * @short_description: Generated C code for the ChangingInterfaceV10 D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-ChangingInterfaceV10.top_of_page">ChangingInterfaceV10</link> D-Bus interface in C.
 */

/* ---- Introspection data for ChangingInterfaceV10 ---- */

static const _ExtendedGDBusMethodInfo _foo_igen_changing_interface_v10_method_info_added_method_in10 =
{
  {
    -1,
    (gchar *) "AddedMethodIn10",
    NULL,
    NULL,
    NULL
  },
  "handle-added-method-in10",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_changing_interface_v10_method_info_new_method_in2 =
{
  {
    -1,
    (gchar *) "NewMethodIn2",
    NULL,
    NULL,
    NULL
  },
  "handle-new-method-in2",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_changing_interface_v10_method_info_baz_method =
{
  {
    -1,
    (gchar *) "BazMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-baz-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_changing_interface_v10_method_info_bar_method =
{
  {
    -1,
    (gchar *) "BarMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-bar-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_igen_changing_interface_v10_method_info_foo_method =
{
  {
    -1,
    (gchar *) "FooMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-foo-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_changing_interface_v10_method_info_pointers[] =
{
  &_foo_igen_changing_interface_v10_method_info_added_method_in10,
  &_foo_igen_changing_interface_v10_method_info_new_method_in2,
  &_foo_igen_changing_interface_v10_method_info_baz_method,
  &_foo_igen_changing_interface_v10_method_info_bar_method,
  &_foo_igen_changing_interface_v10_method_info_foo_method,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_igen_changing_interface_v10_signal_info_added_signal_in10 =
{
  {
    -1,
    (gchar *) "AddedSignalIn10",
    NULL,
    NULL
  },
  "added-signal-in10"
};

static const _ExtendedGDBusSignalInfo _foo_igen_changing_interface_v10_signal_info_new_signal_in2 =
{
  {
    -1,
    (gchar *) "NewSignalIn2",
    NULL,
    NULL
  },
  "new-signal-in2"
};

static const _ExtendedGDBusSignalInfo _foo_igen_changing_interface_v10_signal_info_baz_signal =
{
  {
    -1,
    (gchar *) "BazSignal",
    NULL,
    NULL
  },
  "baz-signal"
};

static const _ExtendedGDBusSignalInfo _foo_igen_changing_interface_v10_signal_info_bar_signal =
{
  {
    -1,
    (gchar *) "BarSignal",
    NULL,
    NULL
  },
  "bar-signal"
};

static const _ExtendedGDBusSignalInfo _foo_igen_changing_interface_v10_signal_info_foo_signal =
{
  {
    -1,
    (gchar *) "FooSignal",
    NULL,
    NULL
  },
  "foo-signal"
};

static const _ExtendedGDBusSignalInfo * const _foo_igen_changing_interface_v10_signal_info_pointers[] =
{
  &_foo_igen_changing_interface_v10_signal_info_added_signal_in10,
  &_foo_igen_changing_interface_v10_signal_info_new_signal_in2,
  &_foo_igen_changing_interface_v10_signal_info_baz_signal,
  &_foo_igen_changing_interface_v10_signal_info_bar_signal,
  &_foo_igen_changing_interface_v10_signal_info_foo_signal,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_changing_interface_v10_interface_info =
{
  {
    -1,
    (gchar *) "ChangingInterfaceV10",
    (GDBusMethodInfo **) &_foo_igen_changing_interface_v10_method_info_pointers,
    (GDBusSignalInfo **) &_foo_igen_changing_interface_v10_signal_info_pointers,
    NULL,
    NULL
  },
  "changing-interface-v10",
};


/**
 * foo_igen_changing_interface_v10_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-ChangingInterfaceV10.top_of_page">ChangingInterfaceV10</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_changing_interface_v10_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_changing_interface_v10_interface_info.parent_struct;
}

/**
 * foo_igen_changing_interface_v10_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenChangingInterfaceV10 interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_changing_interface_v10_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * FooiGenChangingInterfaceV10:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV10.top_of_page">ChangingInterfaceV10</link>.
 */

/**
 * FooiGenChangingInterfaceV10Iface:
 * @parent_iface: The parent interface.
 * @handle_bar_method: Handler for the #FooiGenChangingInterfaceV10::handle-bar-method signal.
 * @handle_baz_method: Handler for the #FooiGenChangingInterfaceV10::handle-baz-method signal.
 * @handle_foo_method: Handler for the #FooiGenChangingInterfaceV10::handle-foo-method signal.
 * @bar_signal: Handler for the #FooiGenChangingInterfaceV10::bar-signal signal.
 * @baz_signal: Handler for the #FooiGenChangingInterfaceV10::baz-signal signal.
 * @foo_signal: Handler for the #FooiGenChangingInterfaceV10::foo-signal signal.
 * @handle_new_method_in2: Handler for the #FooiGenChangingInterfaceV10::handle-new-method-in2 signal.
 * @new_signal_in2: Handler for the #FooiGenChangingInterfaceV10::new-signal-in2 signal.
 * @handle_added_method_in10: Handler for the #FooiGenChangingInterfaceV10::handle-added-method-in10 signal.
 * @added_signal_in10: Handler for the #FooiGenChangingInterfaceV10::added-signal-in10 signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV10.top_of_page">ChangingInterfaceV10</link>.
 */

typedef FooiGenChangingInterfaceV10Iface FooiGenChangingInterfaceV10Interface;
G_DEFINE_INTERFACE (FooiGenChangingInterfaceV10, foo_igen_changing_interface_v10, G_TYPE_OBJECT);

static void
foo_igen_changing_interface_v10_default_init (FooiGenChangingInterfaceV10Iface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenChangingInterfaceV10::handle-added-method-in10:
   * @object: A #FooiGenChangingInterfaceV10.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV10.AddedMethodIn10">AddedMethodIn10()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_changing_interface_v10_complete_added_method_in10() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   *
   * Since: 10.0
   */
  g_signal_new ("handle-added-method-in10",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV10Iface, handle_added_method_in10),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooiGenChangingInterfaceV10::handle-new-method-in2:
   * @object: A #FooiGenChangingInterfaceV10.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV10.NewMethodIn2">NewMethodIn2()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_changing_interface_v10_complete_new_method_in2() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   *
   * Since: 2.0
   */
  g_signal_new ("handle-new-method-in2",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV10Iface, handle_new_method_in2),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooiGenChangingInterfaceV10::handle-baz-method:
   * @object: A #FooiGenChangingInterfaceV10.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV10.BazMethod">BazMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_changing_interface_v10_complete_baz_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-baz-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV10Iface, handle_baz_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooiGenChangingInterfaceV10::handle-bar-method:
   * @object: A #FooiGenChangingInterfaceV10.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV10.BarMethod">BarMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_changing_interface_v10_complete_bar_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-bar-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV10Iface, handle_bar_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooiGenChangingInterfaceV10::handle-foo-method:
   * @object: A #FooiGenChangingInterfaceV10.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV10.FooMethod">FooMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_changing_interface_v10_complete_foo_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-foo-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV10Iface, handle_foo_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooiGenChangingInterfaceV10::added-signal-in10:
   * @object: A #FooiGenChangingInterfaceV10.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV10.AddedSignalIn10">"AddedSignalIn10"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   *
   * Since: 10.0
   */
  g_signal_new ("added-signal-in10",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV10Iface, added_signal_in10),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * FooiGenChangingInterfaceV10::new-signal-in2:
   * @object: A #FooiGenChangingInterfaceV10.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV10.NewSignalIn2">"NewSignalIn2"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   *
   * Since: 2.0
   */
  g_signal_new ("new-signal-in2",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV10Iface, new_signal_in2),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * FooiGenChangingInterfaceV10::baz-signal:
   * @object: A #FooiGenChangingInterfaceV10.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV10.BazSignal">"BazSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("baz-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV10Iface, baz_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * FooiGenChangingInterfaceV10::bar-signal:
   * @object: A #FooiGenChangingInterfaceV10.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV10.BarSignal">"BarSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("bar-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV10Iface, bar_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * FooiGenChangingInterfaceV10::foo-signal:
   * @object: A #FooiGenChangingInterfaceV10.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV10.FooSignal">"FooSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("foo-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenChangingInterfaceV10Iface, foo_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

}

/**
 * foo_igen_changing_interface_v10_emit_added_signal_in10:
 * @object: A #FooiGenChangingInterfaceV10.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV10.AddedSignalIn10">"AddedSignalIn10"</link> D-Bus signal.
 *
 * Since: 10.0
 */
void
foo_igen_changing_interface_v10_emit_added_signal_in10 (
    FooiGenChangingInterfaceV10 *object)
{
  g_signal_emit_by_name (object, "added-signal-in10");
}

/**
 * foo_igen_changing_interface_v10_emit_new_signal_in2:
 * @object: A #FooiGenChangingInterfaceV10.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV10.NewSignalIn2">"NewSignalIn2"</link> D-Bus signal.
 *
 * Since: 2.0
 */
void
foo_igen_changing_interface_v10_emit_new_signal_in2 (
    FooiGenChangingInterfaceV10 *object)
{
  g_signal_emit_by_name (object, "new-signal-in2");
}

/**
 * foo_igen_changing_interface_v10_emit_baz_signal:
 * @object: A #FooiGenChangingInterfaceV10.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV10.BazSignal">"BazSignal"</link> D-Bus signal.
 */
void
foo_igen_changing_interface_v10_emit_baz_signal (
    FooiGenChangingInterfaceV10 *object)
{
  g_signal_emit_by_name (object, "baz-signal");
}

/**
 * foo_igen_changing_interface_v10_emit_bar_signal:
 * @object: A #FooiGenChangingInterfaceV10.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV10.BarSignal">"BarSignal"</link> D-Bus signal.
 */
void
foo_igen_changing_interface_v10_emit_bar_signal (
    FooiGenChangingInterfaceV10 *object)
{
  g_signal_emit_by_name (object, "bar-signal");
}

/**
 * foo_igen_changing_interface_v10_emit_foo_signal:
 * @object: A #FooiGenChangingInterfaceV10.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV10.FooSignal">"FooSignal"</link> D-Bus signal.
 */
void
foo_igen_changing_interface_v10_emit_foo_signal (
    FooiGenChangingInterfaceV10 *object)
{
  g_signal_emit_by_name (object, "foo-signal");
}

/**
 * foo_igen_changing_interface_v10_call_added_method_in10:
 * @proxy: A #FooiGenChangingInterfaceV10Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV10.AddedMethodIn10">AddedMethodIn10()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_changing_interface_v10_call_added_method_in10_finish() to get the result of the operation.
 *
 * See foo_igen_changing_interface_v10_call_added_method_in10_sync() for the synchronous, blocking version of this method.
 *
 * Since: 10.0
 */
void
foo_igen_changing_interface_v10_call_added_method_in10 (
    FooiGenChangingInterfaceV10 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "AddedMethodIn10",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_changing_interface_v10_call_added_method_in10_finish:
 * @proxy: A #FooiGenChangingInterfaceV10Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_changing_interface_v10_call_added_method_in10().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_changing_interface_v10_call_added_method_in10().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 *
 * Since: 10.0
 */
gboolean
foo_igen_changing_interface_v10_call_added_method_in10_finish (
    FooiGenChangingInterfaceV10 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v10_call_added_method_in10_sync:
 * @proxy: A #FooiGenChangingInterfaceV10Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV10.AddedMethodIn10">AddedMethodIn10()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_changing_interface_v10_call_added_method_in10() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 *
 * Since: 10.0
 */
gboolean
foo_igen_changing_interface_v10_call_added_method_in10_sync (
    FooiGenChangingInterfaceV10 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "AddedMethodIn10",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v10_call_new_method_in2:
 * @proxy: A #FooiGenChangingInterfaceV10Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV10.NewMethodIn2">NewMethodIn2()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_changing_interface_v10_call_new_method_in2_finish() to get the result of the operation.
 *
 * See foo_igen_changing_interface_v10_call_new_method_in2_sync() for the synchronous, blocking version of this method.
 *
 * Since: 2.0
 */
void
foo_igen_changing_interface_v10_call_new_method_in2 (
    FooiGenChangingInterfaceV10 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "NewMethodIn2",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_changing_interface_v10_call_new_method_in2_finish:
 * @proxy: A #FooiGenChangingInterfaceV10Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_changing_interface_v10_call_new_method_in2().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_changing_interface_v10_call_new_method_in2().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 *
 * Since: 2.0
 */
gboolean
foo_igen_changing_interface_v10_call_new_method_in2_finish (
    FooiGenChangingInterfaceV10 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v10_call_new_method_in2_sync:
 * @proxy: A #FooiGenChangingInterfaceV10Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV10.NewMethodIn2">NewMethodIn2()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_changing_interface_v10_call_new_method_in2() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 *
 * Since: 2.0
 */
gboolean
foo_igen_changing_interface_v10_call_new_method_in2_sync (
    FooiGenChangingInterfaceV10 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "NewMethodIn2",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v10_call_baz_method:
 * @proxy: A #FooiGenChangingInterfaceV10Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV10.BazMethod">BazMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_changing_interface_v10_call_baz_method_finish() to get the result of the operation.
 *
 * See foo_igen_changing_interface_v10_call_baz_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_changing_interface_v10_call_baz_method (
    FooiGenChangingInterfaceV10 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "BazMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_changing_interface_v10_call_baz_method_finish:
 * @proxy: A #FooiGenChangingInterfaceV10Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_changing_interface_v10_call_baz_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_changing_interface_v10_call_baz_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_changing_interface_v10_call_baz_method_finish (
    FooiGenChangingInterfaceV10 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v10_call_baz_method_sync:
 * @proxy: A #FooiGenChangingInterfaceV10Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV10.BazMethod">BazMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_changing_interface_v10_call_baz_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_changing_interface_v10_call_baz_method_sync (
    FooiGenChangingInterfaceV10 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "BazMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v10_call_bar_method:
 * @proxy: A #FooiGenChangingInterfaceV10Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV10.BarMethod">BarMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_changing_interface_v10_call_bar_method_finish() to get the result of the operation.
 *
 * See foo_igen_changing_interface_v10_call_bar_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_changing_interface_v10_call_bar_method (
    FooiGenChangingInterfaceV10 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "BarMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_changing_interface_v10_call_bar_method_finish:
 * @proxy: A #FooiGenChangingInterfaceV10Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_changing_interface_v10_call_bar_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_changing_interface_v10_call_bar_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_changing_interface_v10_call_bar_method_finish (
    FooiGenChangingInterfaceV10 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v10_call_bar_method_sync:
 * @proxy: A #FooiGenChangingInterfaceV10Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV10.BarMethod">BarMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_changing_interface_v10_call_bar_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_changing_interface_v10_call_bar_method_sync (
    FooiGenChangingInterfaceV10 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "BarMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v10_call_foo_method:
 * @proxy: A #FooiGenChangingInterfaceV10Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV10.FooMethod">FooMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_changing_interface_v10_call_foo_method_finish() to get the result of the operation.
 *
 * See foo_igen_changing_interface_v10_call_foo_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_changing_interface_v10_call_foo_method (
    FooiGenChangingInterfaceV10 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "FooMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_changing_interface_v10_call_foo_method_finish:
 * @proxy: A #FooiGenChangingInterfaceV10Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_changing_interface_v10_call_foo_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_changing_interface_v10_call_foo_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_changing_interface_v10_call_foo_method_finish (
    FooiGenChangingInterfaceV10 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v10_call_foo_method_sync:
 * @proxy: A #FooiGenChangingInterfaceV10Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV10.FooMethod">FooMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_changing_interface_v10_call_foo_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_changing_interface_v10_call_foo_method_sync (
    FooiGenChangingInterfaceV10 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "FooMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_changing_interface_v10_complete_added_method_in10:
 * @object: A #FooiGenChangingInterfaceV10.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV10.AddedMethodIn10">AddedMethodIn10()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 *
 * Since: 10.0
 */
void
foo_igen_changing_interface_v10_complete_added_method_in10 (
    FooiGenChangingInterfaceV10 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_changing_interface_v10_complete_new_method_in2:
 * @object: A #FooiGenChangingInterfaceV10.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV10.NewMethodIn2">NewMethodIn2()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 *
 * Since: 2.0
 */
void
foo_igen_changing_interface_v10_complete_new_method_in2 (
    FooiGenChangingInterfaceV10 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_changing_interface_v10_complete_baz_method:
 * @object: A #FooiGenChangingInterfaceV10.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV10.BazMethod">BazMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_changing_interface_v10_complete_baz_method (
    FooiGenChangingInterfaceV10 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_changing_interface_v10_complete_bar_method:
 * @object: A #FooiGenChangingInterfaceV10.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV10.BarMethod">BarMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_changing_interface_v10_complete_bar_method (
    FooiGenChangingInterfaceV10 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_igen_changing_interface_v10_complete_foo_method:
 * @object: A #FooiGenChangingInterfaceV10.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV10.FooMethod">FooMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_changing_interface_v10_complete_foo_method (
    FooiGenChangingInterfaceV10 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenChangingInterfaceV10Proxy:
 *
 * The #FooiGenChangingInterfaceV10Proxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenChangingInterfaceV10ProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenChangingInterfaceV10Proxy.
 */

struct _FooiGenChangingInterfaceV10ProxyPrivate
{
  GData *qdata;
};

static void foo_igen_changing_interface_v10_proxy_iface_init (FooiGenChangingInterfaceV10Iface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenChangingInterfaceV10Proxy, foo_igen_changing_interface_v10_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (FooiGenChangingInterfaceV10Proxy)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_CHANGING_INTERFACE_V10, foo_igen_changing_interface_v10_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenChangingInterfaceV10Proxy, foo_igen_changing_interface_v10_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_CHANGING_INTERFACE_V10, foo_igen_changing_interface_v10_proxy_iface_init));

#endif
static void
foo_igen_changing_interface_v10_proxy_finalize (GObject *object)
{
  FooiGenChangingInterfaceV10Proxy *proxy = FOO_IGEN_CHANGING_INTERFACE_V10_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_changing_interface_v10_proxy_parent_class)->finalize (object);
}

static void
foo_igen_changing_interface_v10_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
foo_igen_changing_interface_v10_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
foo_igen_changing_interface_v10_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_changing_interface_v10_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_CHANGING_INTERFACE_V10);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_CHANGING_INTERFACE_V10);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_changing_interface_v10_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenChangingInterfaceV10Proxy *proxy = FOO_IGEN_CHANGING_INTERFACE_V10_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_changing_interface_v10_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_changing_interface_v10_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_igen_changing_interface_v10_proxy_init (FooiGenChangingInterfaceV10Proxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = foo_igen_changing_interface_v10_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_CHANGING_INTERFACE_V10_PROXY, FooiGenChangingInterfaceV10ProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_changing_interface_v10_interface_info ());
}

static void
foo_igen_changing_interface_v10_proxy_class_init (FooiGenChangingInterfaceV10ProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_changing_interface_v10_proxy_finalize;
  gobject_class->get_property = foo_igen_changing_interface_v10_proxy_get_property;
  gobject_class->set_property = foo_igen_changing_interface_v10_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_changing_interface_v10_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_changing_interface_v10_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenChangingInterfaceV10ProxyPrivate));
#endif
}

static void
foo_igen_changing_interface_v10_proxy_iface_init (FooiGenChangingInterfaceV10Iface *iface)
{
}

/**
 * foo_igen_changing_interface_v10_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV10.top_of_page">ChangingInterfaceV10</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_changing_interface_v10_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_changing_interface_v10_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_changing_interface_v10_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_CHANGING_INTERFACE_V10_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV10", NULL);
}

/**
 * foo_igen_changing_interface_v10_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_changing_interface_v10_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_changing_interface_v10_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenChangingInterfaceV10Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenChangingInterfaceV10 *
foo_igen_changing_interface_v10_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_CHANGING_INTERFACE_V10 (ret);
  else
    return NULL;
}

/**
 * foo_igen_changing_interface_v10_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV10.top_of_page">ChangingInterfaceV10</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_changing_interface_v10_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenChangingInterfaceV10Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenChangingInterfaceV10 *
foo_igen_changing_interface_v10_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_CHANGING_INTERFACE_V10_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV10", NULL);
  if (ret != NULL)
    return FOO_IGEN_CHANGING_INTERFACE_V10 (ret);
  else
    return NULL;
}


/**
 * foo_igen_changing_interface_v10_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_changing_interface_v10_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_changing_interface_v10_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_changing_interface_v10_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_changing_interface_v10_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_CHANGING_INTERFACE_V10_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV10", NULL);
}

/**
 * foo_igen_changing_interface_v10_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_changing_interface_v10_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_changing_interface_v10_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenChangingInterfaceV10Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenChangingInterfaceV10 *
foo_igen_changing_interface_v10_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_CHANGING_INTERFACE_V10 (ret);
  else
    return NULL;
}

/**
 * foo_igen_changing_interface_v10_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_changing_interface_v10_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_changing_interface_v10_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenChangingInterfaceV10Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenChangingInterfaceV10 *
foo_igen_changing_interface_v10_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_CHANGING_INTERFACE_V10_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV10", NULL);
  if (ret != NULL)
    return FOO_IGEN_CHANGING_INTERFACE_V10 (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenChangingInterfaceV10Skeleton:
 *
 * The #FooiGenChangingInterfaceV10Skeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenChangingInterfaceV10SkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenChangingInterfaceV10Skeleton.
 */

struct _FooiGenChangingInterfaceV10SkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_foo_igen_changing_interface_v10_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenChangingInterfaceV10Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V10_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_CHANGING_INTERFACE_V10);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_CHANGING_INTERFACE_V10);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_changing_interface_v10_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenChangingInterfaceV10Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V10_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_changing_interface_v10_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_changing_interface_v10_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenChangingInterfaceV10Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V10_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_changing_interface_v10_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_changing_interface_v10_skeleton_vtable =
{
  _foo_igen_changing_interface_v10_skeleton_handle_method_call,
  _foo_igen_changing_interface_v10_skeleton_handle_get_property,
  _foo_igen_changing_interface_v10_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
foo_igen_changing_interface_v10_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return foo_igen_changing_interface_v10_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_changing_interface_v10_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_foo_igen_changing_interface_v10_skeleton_vtable;
}

static GVariant *
foo_igen_changing_interface_v10_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenChangingInterfaceV10Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V10_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_changing_interface_v10_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_changing_interface_v10_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_changing_interface_v10_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_changing_interface_v10_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV10", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
foo_igen_changing_interface_v10_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void
_foo_igen_changing_interface_v10_on_signal_added_signal_in10 (
    FooiGenChangingInterfaceV10 *object)
{
  FooiGenChangingInterfaceV10Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V10_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV10", "AddedSignalIn10",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_foo_igen_changing_interface_v10_on_signal_new_signal_in2 (
    FooiGenChangingInterfaceV10 *object)
{
  FooiGenChangingInterfaceV10Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V10_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV10", "NewSignalIn2",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_foo_igen_changing_interface_v10_on_signal_baz_signal (
    FooiGenChangingInterfaceV10 *object)
{
  FooiGenChangingInterfaceV10Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V10_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV10", "BazSignal",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_foo_igen_changing_interface_v10_on_signal_bar_signal (
    FooiGenChangingInterfaceV10 *object)
{
  FooiGenChangingInterfaceV10Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V10_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV10", "BarSignal",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_foo_igen_changing_interface_v10_on_signal_foo_signal (
    FooiGenChangingInterfaceV10 *object)
{
  FooiGenChangingInterfaceV10Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V10_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV10", "FooSignal",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void foo_igen_changing_interface_v10_skeleton_iface_init (FooiGenChangingInterfaceV10Iface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenChangingInterfaceV10Skeleton, foo_igen_changing_interface_v10_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (FooiGenChangingInterfaceV10Skeleton)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_CHANGING_INTERFACE_V10, foo_igen_changing_interface_v10_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenChangingInterfaceV10Skeleton, foo_igen_changing_interface_v10_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_CHANGING_INTERFACE_V10, foo_igen_changing_interface_v10_skeleton_iface_init));

#endif
static void
foo_igen_changing_interface_v10_skeleton_finalize (GObject *object)
{
  FooiGenChangingInterfaceV10Skeleton *skeleton = FOO_IGEN_CHANGING_INTERFACE_V10_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_changing_interface_v10_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_changing_interface_v10_skeleton_init (FooiGenChangingInterfaceV10Skeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = foo_igen_changing_interface_v10_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_CHANGING_INTERFACE_V10_SKELETON, FooiGenChangingInterfaceV10SkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
foo_igen_changing_interface_v10_skeleton_class_init (FooiGenChangingInterfaceV10SkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_changing_interface_v10_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_changing_interface_v10_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_changing_interface_v10_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_changing_interface_v10_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_changing_interface_v10_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenChangingInterfaceV10SkeletonPrivate));
#endif
}

static void
foo_igen_changing_interface_v10_skeleton_iface_init (FooiGenChangingInterfaceV10Iface *iface)
{
  iface->added_signal_in10 = _foo_igen_changing_interface_v10_on_signal_added_signal_in10;
  iface->new_signal_in2 = _foo_igen_changing_interface_v10_on_signal_new_signal_in2;
  iface->baz_signal = _foo_igen_changing_interface_v10_on_signal_baz_signal;
  iface->bar_signal = _foo_igen_changing_interface_v10_on_signal_bar_signal;
  iface->foo_signal = _foo_igen_changing_interface_v10_on_signal_foo_signal;
}

/**
 * foo_igen_changing_interface_v10_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV10.top_of_page">ChangingInterfaceV10</link>.
 *
 * Returns: (transfer full) (type FooiGenChangingInterfaceV10Skeleton): The skeleton object.
 */
FooiGenChangingInterfaceV10 *
foo_igen_changing_interface_v10_skeleton_new (void)
{
  return FOO_IGEN_CHANGING_INTERFACE_V10 (g_object_new (FOO_IGEN_TYPE_CHANGING_INTERFACE_V10_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface TestUglyCaseInterface
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenTesTuglyCASEInterface
 * @title: FooiGenTesTuglyCASEInterface
 * @short_description: Generated C code for the TestUglyCaseInterface D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-TestUglyCaseInterface.top_of_page">TestUglyCaseInterface</link> D-Bus interface in C.
 */

/* ---- Introspection data for TestUglyCaseInterface ---- */

static const _ExtendedGDBusMethodInfo _foo_igen_test_ugly_case_interface_method_info_get_iscsi_servers =
{
  {
    -1,
    (gchar *) "GetiSCSIServers",
    NULL,
    NULL,
    NULL
  },
  "handle-get-iscsi-servers",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_test_ugly_case_interface_method_info_pointers[] =
{
  &_foo_igen_test_ugly_case_interface_method_info_get_iscsi_servers,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_igen_test_ugly_case_interface_signal_info_servers_updated_now =
{
  {
    -1,
    (gchar *) "serversUPDATEDNOW",
    NULL,
    NULL
  },
  "servers-updated-now"
};

static const _ExtendedGDBusSignalInfo * const _foo_igen_test_ugly_case_interface_signal_info_pointers[] =
{
  &_foo_igen_test_ugly_case_interface_signal_info_servers_updated_now,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_igen_test_ugly_case_interface_property_info_ugly_name =
{
  {
    -1,
    (gchar *) "UGLYNAME",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "ugly-name",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _foo_igen_test_ugly_case_interface_property_info_pointers[] =
{
  &_foo_igen_test_ugly_case_interface_property_info_ugly_name,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_test_ugly_case_interface_interface_info =
{
  {
    -1,
    (gchar *) "TestUglyCaseInterface",
    (GDBusMethodInfo **) &_foo_igen_test_ugly_case_interface_method_info_pointers,
    (GDBusSignalInfo **) &_foo_igen_test_ugly_case_interface_signal_info_pointers,
    (GDBusPropertyInfo **) &_foo_igen_test_ugly_case_interface_property_info_pointers,
    NULL
  },
  "test-ugly-case-interface",
};


/**
 * foo_igen_test_ugly_case_interface_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-TestUglyCaseInterface.top_of_page">TestUglyCaseInterface</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_test_ugly_case_interface_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_test_ugly_case_interface_interface_info.parent_struct;
}

/**
 * foo_igen_test_ugly_case_interface_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenTesTuglyCASEInterface interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_test_ugly_case_interface_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "ugly-name");
  return property_id_begin - 1;
}



/**
 * FooiGenTesTuglyCASEInterface:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-TestUglyCaseInterface.top_of_page">TestUglyCaseInterface</link>.
 */

/**
 * FooiGenTesTuglyCASEInterfaceIface:
 * @parent_iface: The parent interface.
 * @handle_get_iscsi_servers: Handler for the #FooiGenTesTuglyCASEInterface::handle-get-iscsi-servers signal.
 * @get_ugly_name: Getter for the #FooiGenTesTuglyCASEInterface:ugly-name property.
 * @servers_updated_now: Handler for the #FooiGenTesTuglyCASEInterface::servers-updated-now signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-TestUglyCaseInterface.top_of_page">TestUglyCaseInterface</link>.
 */

typedef FooiGenTesTuglyCASEInterfaceIface FooiGenTesTuglyCASEInterfaceInterface;
G_DEFINE_INTERFACE (FooiGenTesTuglyCASEInterface, foo_igen_test_ugly_case_interface, G_TYPE_OBJECT);

static void
foo_igen_test_ugly_case_interface_default_init (FooiGenTesTuglyCASEInterfaceIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenTesTuglyCASEInterface::handle-get-iscsi-servers:
   * @object: A #FooiGenTesTuglyCASEInterface.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-TestUglyCaseInterface.GetiSCSIServers">GetiSCSIServers()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_test_ugly_case_interface_complete_get_iscsi_servers() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-iscsi-servers",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenTesTuglyCASEInterfaceIface, handle_get_iscsi_servers),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooiGenTesTuglyCASEInterface::servers-updated-now:
   * @object: A #FooiGenTesTuglyCASEInterface.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-TestUglyCaseInterface.serversUPDATEDNOW">"serversUPDATEDNOW"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("servers-updated-now",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenTesTuglyCASEInterfaceIface, servers_updated_now),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /* GObject properties for D-Bus properties: */
  /**
   * FooiGenTesTuglyCASEInterface:ugly-name:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-TestUglyCaseInterface.UGLYNAME">"UGLYNAME"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("ugly-name", "UGLYNAME", "UGLYNAME", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * foo_igen_test_ugly_case_interface_get_ugly_name: (skip)
 * @object: A #FooiGenTesTuglyCASEInterface.
 *
 * Gets the value of the <link linkend="gdbus-property-TestUglyCaseInterface.UGLYNAME">"UGLYNAME"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
foo_igen_test_ugly_case_interface_get_ugly_name (FooiGenTesTuglyCASEInterface *object)
{
  return FOO_IGEN_TEST_UGLY_CASE_INTERFACE_GET_IFACE (object)->get_ugly_name (object);
}

/**
 * foo_igen_test_ugly_case_interface_set_ugly_name: (skip)
 * @object: A #FooiGenTesTuglyCASEInterface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-TestUglyCaseInterface.UGLYNAME">"UGLYNAME"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_test_ugly_case_interface_set_ugly_name (FooiGenTesTuglyCASEInterface *object, gint value)
{
  g_object_set (G_OBJECT (object), "ugly-name", value, NULL);
}

/**
 * foo_igen_test_ugly_case_interface_emit_servers_updated_now:
 * @object: A #FooiGenTesTuglyCASEInterface.
 *
 * Emits the <link linkend="gdbus-signal-TestUglyCaseInterface.serversUPDATEDNOW">"serversUPDATEDNOW"</link> D-Bus signal.
 */
void
foo_igen_test_ugly_case_interface_emit_servers_updated_now (
    FooiGenTesTuglyCASEInterface *object)
{
  g_signal_emit_by_name (object, "servers-updated-now");
}

/**
 * foo_igen_test_ugly_case_interface_call_get_iscsi_servers:
 * @proxy: A #FooiGenTesTuglyCASEInterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-TestUglyCaseInterface.GetiSCSIServers">GetiSCSIServers()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_test_ugly_case_interface_call_get_iscsi_servers_finish() to get the result of the operation.
 *
 * See foo_igen_test_ugly_case_interface_call_get_iscsi_servers_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_test_ugly_case_interface_call_get_iscsi_servers (
    FooiGenTesTuglyCASEInterface *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "GetiSCSIServers",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_test_ugly_case_interface_call_get_iscsi_servers_finish:
 * @proxy: A #FooiGenTesTuglyCASEInterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_test_ugly_case_interface_call_get_iscsi_servers().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_test_ugly_case_interface_call_get_iscsi_servers().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_test_ugly_case_interface_call_get_iscsi_servers_finish (
    FooiGenTesTuglyCASEInterface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_test_ugly_case_interface_call_get_iscsi_servers_sync:
 * @proxy: A #FooiGenTesTuglyCASEInterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-TestUglyCaseInterface.GetiSCSIServers">GetiSCSIServers()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_test_ugly_case_interface_call_get_iscsi_servers() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_test_ugly_case_interface_call_get_iscsi_servers_sync (
    FooiGenTesTuglyCASEInterface *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "GetiSCSIServers",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_test_ugly_case_interface_complete_get_iscsi_servers:
 * @object: A #FooiGenTesTuglyCASEInterface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-TestUglyCaseInterface.GetiSCSIServers">GetiSCSIServers()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_test_ugly_case_interface_complete_get_iscsi_servers (
    FooiGenTesTuglyCASEInterface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenTesTuglyCASEInterfaceProxy:
 *
 * The #FooiGenTesTuglyCASEInterfaceProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenTesTuglyCASEInterfaceProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenTesTuglyCASEInterfaceProxy.
 */

struct _FooiGenTesTuglyCASEInterfaceProxyPrivate
{
  GData *qdata;
};

static void foo_igen_test_ugly_case_interface_proxy_iface_init (FooiGenTesTuglyCASEInterfaceIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenTesTuglyCASEInterfaceProxy, foo_igen_test_ugly_case_interface_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (FooiGenTesTuglyCASEInterfaceProxy)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_TEST_UGLY_CASE_INTERFACE, foo_igen_test_ugly_case_interface_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenTesTuglyCASEInterfaceProxy, foo_igen_test_ugly_case_interface_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_TEST_UGLY_CASE_INTERFACE, foo_igen_test_ugly_case_interface_proxy_iface_init));

#endif
static void
foo_igen_test_ugly_case_interface_proxy_finalize (GObject *object)
{
  FooiGenTesTuglyCASEInterfaceProxy *proxy = FOO_IGEN_TEST_UGLY_CASE_INTERFACE_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_test_ugly_case_interface_proxy_parent_class)->finalize (object);
}

static void
foo_igen_test_ugly_case_interface_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = _foo_igen_test_ugly_case_interface_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
foo_igen_test_ugly_case_interface_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface TestUglyCaseInterface: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
foo_igen_test_ugly_case_interface_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = _foo_igen_test_ugly_case_interface_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "TestUglyCaseInterface", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) foo_igen_test_ugly_case_interface_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
foo_igen_test_ugly_case_interface_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_test_ugly_case_interface_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_TEST_UGLY_CASE_INTERFACE);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_TEST_UGLY_CASE_INTERFACE);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_test_ugly_case_interface_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenTesTuglyCASEInterfaceProxy *proxy = FOO_IGEN_TEST_UGLY_CASE_INTERFACE_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_test_ugly_case_interface_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_test_ugly_case_interface_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static gint 
foo_igen_test_ugly_case_interface_proxy_get_ugly_name (FooiGenTesTuglyCASEInterface *object)
{
  FooiGenTesTuglyCASEInterfaceProxy *proxy = FOO_IGEN_TEST_UGLY_CASE_INTERFACE_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "UGLYNAME");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static void
foo_igen_test_ugly_case_interface_proxy_init (FooiGenTesTuglyCASEInterfaceProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = foo_igen_test_ugly_case_interface_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_TEST_UGLY_CASE_INTERFACE_PROXY, FooiGenTesTuglyCASEInterfaceProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_test_ugly_case_interface_interface_info ());
}

static void
foo_igen_test_ugly_case_interface_proxy_class_init (FooiGenTesTuglyCASEInterfaceProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_test_ugly_case_interface_proxy_finalize;
  gobject_class->get_property = foo_igen_test_ugly_case_interface_proxy_get_property;
  gobject_class->set_property = foo_igen_test_ugly_case_interface_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_test_ugly_case_interface_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_test_ugly_case_interface_proxy_g_properties_changed;

  foo_igen_test_ugly_case_interface_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenTesTuglyCASEInterfaceProxyPrivate));
#endif
}

static void
foo_igen_test_ugly_case_interface_proxy_iface_init (FooiGenTesTuglyCASEInterfaceIface *iface)
{
  iface->get_ugly_name = foo_igen_test_ugly_case_interface_proxy_get_ugly_name;
}

/**
 * foo_igen_test_ugly_case_interface_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-TestUglyCaseInterface.top_of_page">TestUglyCaseInterface</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_test_ugly_case_interface_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_test_ugly_case_interface_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_test_ugly_case_interface_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_TEST_UGLY_CASE_INTERFACE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "TestUglyCaseInterface", NULL);
}

/**
 * foo_igen_test_ugly_case_interface_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_test_ugly_case_interface_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_test_ugly_case_interface_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenTesTuglyCASEInterfaceProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenTesTuglyCASEInterface *
foo_igen_test_ugly_case_interface_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_TEST_UGLY_CASE_INTERFACE (ret);
  else
    return NULL;
}

/**
 * foo_igen_test_ugly_case_interface_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-TestUglyCaseInterface.top_of_page">TestUglyCaseInterface</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_test_ugly_case_interface_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenTesTuglyCASEInterfaceProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenTesTuglyCASEInterface *
foo_igen_test_ugly_case_interface_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_TEST_UGLY_CASE_INTERFACE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "TestUglyCaseInterface", NULL);
  if (ret != NULL)
    return FOO_IGEN_TEST_UGLY_CASE_INTERFACE (ret);
  else
    return NULL;
}


/**
 * foo_igen_test_ugly_case_interface_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_test_ugly_case_interface_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_test_ugly_case_interface_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_test_ugly_case_interface_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_test_ugly_case_interface_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_TEST_UGLY_CASE_INTERFACE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "TestUglyCaseInterface", NULL);
}

/**
 * foo_igen_test_ugly_case_interface_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_test_ugly_case_interface_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_test_ugly_case_interface_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenTesTuglyCASEInterfaceProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenTesTuglyCASEInterface *
foo_igen_test_ugly_case_interface_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_TEST_UGLY_CASE_INTERFACE (ret);
  else
    return NULL;
}

/**
 * foo_igen_test_ugly_case_interface_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_test_ugly_case_interface_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_test_ugly_case_interface_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenTesTuglyCASEInterfaceProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenTesTuglyCASEInterface *
foo_igen_test_ugly_case_interface_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_TEST_UGLY_CASE_INTERFACE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "TestUglyCaseInterface", NULL);
  if (ret != NULL)
    return FOO_IGEN_TEST_UGLY_CASE_INTERFACE (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenTesTuglyCASEInterfaceSkeleton:
 *
 * The #FooiGenTesTuglyCASEInterfaceSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenTesTuglyCASEInterfaceSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenTesTuglyCASEInterfaceSkeleton.
 */

struct _FooiGenTesTuglyCASEInterfaceSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_foo_igen_test_ugly_case_interface_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenTesTuglyCASEInterfaceSkeleton *skeleton = FOO_IGEN_TEST_UGLY_CASE_INTERFACE_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_TEST_UGLY_CASE_INTERFACE);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_TEST_UGLY_CASE_INTERFACE);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_test_ugly_case_interface_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenTesTuglyCASEInterfaceSkeleton *skeleton = FOO_IGEN_TEST_UGLY_CASE_INTERFACE_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_test_ugly_case_interface_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_test_ugly_case_interface_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenTesTuglyCASEInterfaceSkeleton *skeleton = FOO_IGEN_TEST_UGLY_CASE_INTERFACE_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_test_ugly_case_interface_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_test_ugly_case_interface_skeleton_vtable =
{
  _foo_igen_test_ugly_case_interface_skeleton_handle_method_call,
  _foo_igen_test_ugly_case_interface_skeleton_handle_get_property,
  _foo_igen_test_ugly_case_interface_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
foo_igen_test_ugly_case_interface_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return foo_igen_test_ugly_case_interface_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_test_ugly_case_interface_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_foo_igen_test_ugly_case_interface_skeleton_vtable;
}

static GVariant *
foo_igen_test_ugly_case_interface_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenTesTuglyCASEInterfaceSkeleton *skeleton = FOO_IGEN_TEST_UGLY_CASE_INTERFACE_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_test_ugly_case_interface_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_test_ugly_case_interface_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_test_ugly_case_interface_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_test_ugly_case_interface_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "TestUglyCaseInterface", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _foo_igen_test_ugly_case_interface_emit_changed (gpointer user_data);

static void
foo_igen_test_ugly_case_interface_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenTesTuglyCASEInterfaceSkeleton *skeleton = FOO_IGEN_TEST_UGLY_CASE_INTERFACE_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _foo_igen_test_ugly_case_interface_emit_changed (skeleton);
}

static void
_foo_igen_test_ugly_case_interface_on_signal_servers_updated_now (
    FooiGenTesTuglyCASEInterface *object)
{
  FooiGenTesTuglyCASEInterfaceSkeleton *skeleton = FOO_IGEN_TEST_UGLY_CASE_INTERFACE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "TestUglyCaseInterface", "serversUPDATEDNOW",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void foo_igen_test_ugly_case_interface_skeleton_iface_init (FooiGenTesTuglyCASEInterfaceIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenTesTuglyCASEInterfaceSkeleton, foo_igen_test_ugly_case_interface_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (FooiGenTesTuglyCASEInterfaceSkeleton)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_TEST_UGLY_CASE_INTERFACE, foo_igen_test_ugly_case_interface_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenTesTuglyCASEInterfaceSkeleton, foo_igen_test_ugly_case_interface_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_TEST_UGLY_CASE_INTERFACE, foo_igen_test_ugly_case_interface_skeleton_iface_init));

#endif
static void
foo_igen_test_ugly_case_interface_skeleton_finalize (GObject *object)
{
  FooiGenTesTuglyCASEInterfaceSkeleton *skeleton = FOO_IGEN_TEST_UGLY_CASE_INTERFACE_SKELETON (object);
  guint n;
  for (n = 0; n < 1; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_test_ugly_case_interface_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_test_ugly_case_interface_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  FooiGenTesTuglyCASEInterfaceSkeleton *skeleton = FOO_IGEN_TEST_UGLY_CASE_INTERFACE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_foo_igen_test_ugly_case_interface_emit_changed (gpointer user_data)
{
  FooiGenTesTuglyCASEInterfaceSkeleton *skeleton = FOO_IGEN_TEST_UGLY_CASE_INTERFACE_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "TestUglyCaseInterface",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_foo_igen_test_ugly_case_interface_schedule_emit_changed (FooiGenTesTuglyCASEInterfaceSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
foo_igen_test_ugly_case_interface_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  FooiGenTesTuglyCASEInterfaceSkeleton *skeleton = FOO_IGEN_TEST_UGLY_CASE_INTERFACE_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _foo_igen_test_ugly_case_interface_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _foo_igen_test_ugly_case_interface_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
foo_igen_test_ugly_case_interface_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooiGenTesTuglyCASEInterfaceSkeleton *skeleton = FOO_IGEN_TEST_UGLY_CASE_INTERFACE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _foo_igen_test_ugly_case_interface_schedule_emit_changed (skeleton, _foo_igen_test_ugly_case_interface_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
foo_igen_test_ugly_case_interface_skeleton_init (FooiGenTesTuglyCASEInterfaceSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = foo_igen_test_ugly_case_interface_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_TEST_UGLY_CASE_INTERFACE_SKELETON, FooiGenTesTuglyCASEInterfaceSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 1);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_INT);
}

static gint 
foo_igen_test_ugly_case_interface_skeleton_get_ugly_name (FooiGenTesTuglyCASEInterface *object)
{
  FooiGenTesTuglyCASEInterfaceSkeleton *skeleton = FOO_IGEN_TEST_UGLY_CASE_INTERFACE_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
foo_igen_test_ugly_case_interface_skeleton_class_init (FooiGenTesTuglyCASEInterfaceSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_test_ugly_case_interface_skeleton_finalize;
  gobject_class->get_property = foo_igen_test_ugly_case_interface_skeleton_get_property;
  gobject_class->set_property = foo_igen_test_ugly_case_interface_skeleton_set_property;
  gobject_class->notify       = foo_igen_test_ugly_case_interface_skeleton_notify;


  foo_igen_test_ugly_case_interface_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_test_ugly_case_interface_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_test_ugly_case_interface_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_test_ugly_case_interface_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_test_ugly_case_interface_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenTesTuglyCASEInterfaceSkeletonPrivate));
#endif
}

static void
foo_igen_test_ugly_case_interface_skeleton_iface_init (FooiGenTesTuglyCASEInterfaceIface *iface)
{
  iface->servers_updated_now = _foo_igen_test_ugly_case_interface_on_signal_servers_updated_now;
  iface->get_ugly_name = foo_igen_test_ugly_case_interface_skeleton_get_ugly_name;
}

/**
 * foo_igen_test_ugly_case_interface_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-TestUglyCaseInterface.top_of_page">TestUglyCaseInterface</link>.
 *
 * Returns: (transfer full) (type FooiGenTesTuglyCASEInterfaceSkeleton): The skeleton object.
 */
FooiGenTesTuglyCASEInterface *
foo_igen_test_ugly_case_interface_skeleton_new (void)
{
  return FOO_IGEN_TEST_UGLY_CASE_INTERFACE (g_object_new (FOO_IGEN_TYPE_TEST_UGLY_CASE_INTERFACE_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface OldieInterface
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenOldieInterface
 * @title: FooiGenOldieInterface
 * @short_description: Generated C code for the OldieInterface D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-OldieInterface.top_of_page">OldieInterface</link> D-Bus interface in C.
 */

/* ---- Introspection data for OldieInterface ---- */

static const GDBusAnnotationInfo _foo_igen_oldie_interface_method_foo_annotation_info_0 =
{
  -1,
  (gchar *) "org.freedesktop.DBus.Deprecated",
  (gchar *) "true",
  NULL
};

static const GDBusAnnotationInfo * const _foo_igen_oldie_interface_method_foo_annotation_info_pointers[] =
{
  &_foo_igen_oldie_interface_method_foo_annotation_info_0,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_igen_oldie_interface_method_info_foo =
{
  {
    -1,
    (gchar *) "Foo",
    NULL,
    NULL,
    (GDBusAnnotationInfo **) &_foo_igen_oldie_interface_method_foo_annotation_info_pointers
  },
  "handle-foo",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_oldie_interface_method_info_pointers[] =
{
  &_foo_igen_oldie_interface_method_info_foo,
  NULL
};

static const GDBusAnnotationInfo _foo_igen_oldie_interface_signal_bar_annotation_info_0 =
{
  -1,
  (gchar *) "org.freedesktop.DBus.Deprecated",
  (gchar *) "true",
  NULL
};

static const GDBusAnnotationInfo * const _foo_igen_oldie_interface_signal_bar_annotation_info_pointers[] =
{
  &_foo_igen_oldie_interface_signal_bar_annotation_info_0,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_igen_oldie_interface_signal_info_bar =
{
  {
    -1,
    (gchar *) "Bar",
    NULL,
    (GDBusAnnotationInfo **) &_foo_igen_oldie_interface_signal_bar_annotation_info_pointers
  },
  "bar"
};

static const _ExtendedGDBusSignalInfo * const _foo_igen_oldie_interface_signal_info_pointers[] =
{
  &_foo_igen_oldie_interface_signal_info_bar,
  NULL
};

static const GDBusAnnotationInfo _foo_igen_oldie_interface_property_bat_annotation_info_0 =
{
  -1,
  (gchar *) "org.freedesktop.DBus.Deprecated",
  (gchar *) "true",
  NULL
};

static const GDBusAnnotationInfo * const _foo_igen_oldie_interface_property_bat_annotation_info_pointers[] =
{
  &_foo_igen_oldie_interface_property_bat_annotation_info_0,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_igen_oldie_interface_property_info_bat =
{
  {
    -1,
    (gchar *) "Bat",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    (GDBusAnnotationInfo **) &_foo_igen_oldie_interface_property_bat_annotation_info_pointers
  },
  "bat",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _foo_igen_oldie_interface_property_info_pointers[] =
{
  &_foo_igen_oldie_interface_property_info_bat,
  NULL
};

static const GDBusAnnotationInfo _foo_igen_oldie_interface_annotation_info_0 =
{
  -1,
  (gchar *) "org.freedesktop.DBus.Deprecated",
  (gchar *) "true",
  NULL
};

static const GDBusAnnotationInfo * const _foo_igen_oldie_interface_annotation_info_pointers[] =
{
  &_foo_igen_oldie_interface_annotation_info_0,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_oldie_interface_interface_info =
{
  {
    -1,
    (gchar *) "OldieInterface",
    (GDBusMethodInfo **) &_foo_igen_oldie_interface_method_info_pointers,
    (GDBusSignalInfo **) &_foo_igen_oldie_interface_signal_info_pointers,
    (GDBusPropertyInfo **) &_foo_igen_oldie_interface_property_info_pointers,
    (GDBusAnnotationInfo **) &_foo_igen_oldie_interface_annotation_info_pointers
  },
  "oldie-interface",
};


/**
 * foo_igen_oldie_interface_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-OldieInterface.top_of_page">OldieInterface</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GDBusInterfaceInfo *
foo_igen_oldie_interface_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_oldie_interface_interface_info.parent_struct;
}

/**
 * foo_igen_oldie_interface_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenOldieInterface interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
guint
foo_igen_oldie_interface_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "bat");
  return property_id_begin - 1;
}



/**
 * FooiGenOldieInterface:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-OldieInterface.top_of_page">OldieInterface</link>.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

/**
 * FooiGenOldieInterfaceIface:
 * @parent_iface: The parent interface.
 * @handle_foo: Handler for the #FooiGenOldieInterface::handle-foo signal.
 * @get_bat: Getter for the #FooiGenOldieInterface:bat property.
 * @bar: Handler for the #FooiGenOldieInterface::bar signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-OldieInterface.top_of_page">OldieInterface</link>.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

typedef FooiGenOldieInterfaceIface FooiGenOldieInterfaceInterface;
G_DEFINE_INTERFACE (FooiGenOldieInterface, foo_igen_oldie_interface, G_TYPE_OBJECT);

static void
foo_igen_oldie_interface_default_init (FooiGenOldieInterfaceIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenOldieInterface::handle-foo:
   * @object: A #FooiGenOldieInterface.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-OldieInterface.Foo">Foo()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_oldie_interface_complete_foo() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   *
   * Deprecated: The D-Bus method has been deprecated.
   */
  g_signal_new ("handle-foo",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenOldieInterfaceIface, handle_foo),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooiGenOldieInterface::bar:
   * @object: A #FooiGenOldieInterface.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-OldieInterface.Bar">"Bar"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   *
   * Deprecated: The D-Bus signal has been deprecated.
   */
  g_signal_new ("bar",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenOldieInterfaceIface, bar),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /* GObject properties for D-Bus properties: */
  /**
   * FooiGenOldieInterface:bat:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-OldieInterface.Bat">"Bat"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   *
   * Deprecated: The D-Bus property has been deprecated.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("bat", "Bat", "Bat", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * foo_igen_oldie_interface_get_bat: (skip)
 * @object: A #FooiGenOldieInterface.
 *
 * Gets the value of the <link linkend="gdbus-property-OldieInterface.Bat">"Bat"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 *
 * Deprecated: The D-Bus property has been deprecated.
 */
gint 
foo_igen_oldie_interface_get_bat (FooiGenOldieInterface *object)
{
  return FOO_IGEN_OLDIE_INTERFACE_GET_IFACE (object)->get_bat (object);
}

/**
 * foo_igen_oldie_interface_set_bat: (skip)
 * @object: A #FooiGenOldieInterface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-OldieInterface.Bat">"Bat"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Deprecated: The D-Bus property has been deprecated.
 */
void
foo_igen_oldie_interface_set_bat (FooiGenOldieInterface *object, gint value)
{
  g_object_set (G_OBJECT (object), "bat", value, NULL);
}

/**
 * foo_igen_oldie_interface_emit_bar:
 * @object: A #FooiGenOldieInterface.
 *
 * Emits the <link linkend="gdbus-signal-OldieInterface.Bar">"Bar"</link> D-Bus signal.
 *
 * Deprecated: The D-Bus signal has been deprecated.
 */
void
foo_igen_oldie_interface_emit_bar (
    FooiGenOldieInterface *object)
{
  g_signal_emit_by_name (object, "bar");
}

/**
 * foo_igen_oldie_interface_call_foo:
 * @proxy: A #FooiGenOldieInterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-OldieInterface.Foo">Foo()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_oldie_interface_call_foo_finish() to get the result of the operation.
 *
 * See foo_igen_oldie_interface_call_foo_sync() for the synchronous, blocking version of this method.
 *
 * Deprecated: The D-Bus method has been deprecated.
 */
void
foo_igen_oldie_interface_call_foo (
    FooiGenOldieInterface *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Foo",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_oldie_interface_call_foo_finish:
 * @proxy: A #FooiGenOldieInterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_oldie_interface_call_foo().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_oldie_interface_call_foo().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 *
 * Deprecated: The D-Bus method has been deprecated.
 */
gboolean
foo_igen_oldie_interface_call_foo_finish (
    FooiGenOldieInterface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_oldie_interface_call_foo_sync:
 * @proxy: A #FooiGenOldieInterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-OldieInterface.Foo">Foo()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_oldie_interface_call_foo() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 *
 * Deprecated: The D-Bus method has been deprecated.
 */
gboolean
foo_igen_oldie_interface_call_foo_sync (
    FooiGenOldieInterface *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Foo",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_oldie_interface_complete_foo:
 * @object: A #FooiGenOldieInterface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-OldieInterface.Foo">Foo()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 *
 * Deprecated: The D-Bus method has been deprecated.
 */
void
foo_igen_oldie_interface_complete_foo (
    FooiGenOldieInterface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenOldieInterfaceProxy:
 *
 * The #FooiGenOldieInterfaceProxy structure contains only private data and should only be accessed using the provided API.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

/**
 * FooiGenOldieInterfaceProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenOldieInterfaceProxy.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

struct _FooiGenOldieInterfaceProxyPrivate
{
  GData *qdata;
};

static void foo_igen_oldie_interface_proxy_iface_init (FooiGenOldieInterfaceIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenOldieInterfaceProxy, foo_igen_oldie_interface_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (FooiGenOldieInterfaceProxy)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_OLDIE_INTERFACE, foo_igen_oldie_interface_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenOldieInterfaceProxy, foo_igen_oldie_interface_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_OLDIE_INTERFACE, foo_igen_oldie_interface_proxy_iface_init));

#endif
static void
foo_igen_oldie_interface_proxy_finalize (GObject *object)
{
  FooiGenOldieInterfaceProxy *proxy = FOO_IGEN_OLDIE_INTERFACE_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_oldie_interface_proxy_parent_class)->finalize (object);
}

static void
foo_igen_oldie_interface_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = _foo_igen_oldie_interface_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
foo_igen_oldie_interface_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface OldieInterface: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
foo_igen_oldie_interface_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = _foo_igen_oldie_interface_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "OldieInterface", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) foo_igen_oldie_interface_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
foo_igen_oldie_interface_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_oldie_interface_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_OLDIE_INTERFACE);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_OLDIE_INTERFACE);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_oldie_interface_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenOldieInterfaceProxy *proxy = FOO_IGEN_OLDIE_INTERFACE_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_oldie_interface_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_oldie_interface_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static gint 
foo_igen_oldie_interface_proxy_get_bat (FooiGenOldieInterface *object)
{
  FooiGenOldieInterfaceProxy *proxy = FOO_IGEN_OLDIE_INTERFACE_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Bat");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static void
foo_igen_oldie_interface_proxy_init (FooiGenOldieInterfaceProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = foo_igen_oldie_interface_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_OLDIE_INTERFACE_PROXY, FooiGenOldieInterfaceProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_oldie_interface_interface_info ());
}

static void
foo_igen_oldie_interface_proxy_class_init (FooiGenOldieInterfaceProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_oldie_interface_proxy_finalize;
  gobject_class->get_property = foo_igen_oldie_interface_proxy_get_property;
  gobject_class->set_property = foo_igen_oldie_interface_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_oldie_interface_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_oldie_interface_proxy_g_properties_changed;

  foo_igen_oldie_interface_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenOldieInterfaceProxyPrivate));
#endif
}

static void
foo_igen_oldie_interface_proxy_iface_init (FooiGenOldieInterfaceIface *iface)
{
  iface->get_bat = foo_igen_oldie_interface_proxy_get_bat;
}

/**
 * foo_igen_oldie_interface_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-OldieInterface.top_of_page">OldieInterface</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_oldie_interface_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_oldie_interface_proxy_new_sync() for the synchronous, blocking version of this constructor.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
void
foo_igen_oldie_interface_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_OLDIE_INTERFACE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "OldieInterface", NULL);
}

/**
 * foo_igen_oldie_interface_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_oldie_interface_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_oldie_interface_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenOldieInterfaceProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
FooiGenOldieInterface *
foo_igen_oldie_interface_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_OLDIE_INTERFACE (ret);
  else
    return NULL;
}

/**
 * foo_igen_oldie_interface_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-OldieInterface.top_of_page">OldieInterface</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_oldie_interface_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenOldieInterfaceProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
FooiGenOldieInterface *
foo_igen_oldie_interface_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_OLDIE_INTERFACE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "OldieInterface", NULL);
  if (ret != NULL)
    return FOO_IGEN_OLDIE_INTERFACE (ret);
  else
    return NULL;
}


/**
 * foo_igen_oldie_interface_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_oldie_interface_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_oldie_interface_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_oldie_interface_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
void
foo_igen_oldie_interface_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_OLDIE_INTERFACE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "OldieInterface", NULL);
}

/**
 * foo_igen_oldie_interface_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_oldie_interface_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_oldie_interface_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenOldieInterfaceProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
FooiGenOldieInterface *
foo_igen_oldie_interface_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_OLDIE_INTERFACE (ret);
  else
    return NULL;
}

/**
 * foo_igen_oldie_interface_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_oldie_interface_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_oldie_interface_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenOldieInterfaceProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
FooiGenOldieInterface *
foo_igen_oldie_interface_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_OLDIE_INTERFACE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "OldieInterface", NULL);
  if (ret != NULL)
    return FOO_IGEN_OLDIE_INTERFACE (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenOldieInterfaceSkeleton:
 *
 * The #FooiGenOldieInterfaceSkeleton structure contains only private data and should only be accessed using the provided API.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

/**
 * FooiGenOldieInterfaceSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenOldieInterfaceSkeleton.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

struct _FooiGenOldieInterfaceSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_foo_igen_oldie_interface_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenOldieInterfaceSkeleton *skeleton = FOO_IGEN_OLDIE_INTERFACE_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_OLDIE_INTERFACE);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_OLDIE_INTERFACE);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_oldie_interface_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenOldieInterfaceSkeleton *skeleton = FOO_IGEN_OLDIE_INTERFACE_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_oldie_interface_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_oldie_interface_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenOldieInterfaceSkeleton *skeleton = FOO_IGEN_OLDIE_INTERFACE_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_oldie_interface_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_oldie_interface_skeleton_vtable =
{
  _foo_igen_oldie_interface_skeleton_handle_method_call,
  _foo_igen_oldie_interface_skeleton_handle_get_property,
  _foo_igen_oldie_interface_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
foo_igen_oldie_interface_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return foo_igen_oldie_interface_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_oldie_interface_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_foo_igen_oldie_interface_skeleton_vtable;
}

static GVariant *
foo_igen_oldie_interface_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenOldieInterfaceSkeleton *skeleton = FOO_IGEN_OLDIE_INTERFACE_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_oldie_interface_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_oldie_interface_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_oldie_interface_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_oldie_interface_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "OldieInterface", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _foo_igen_oldie_interface_emit_changed (gpointer user_data);

static void
foo_igen_oldie_interface_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenOldieInterfaceSkeleton *skeleton = FOO_IGEN_OLDIE_INTERFACE_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _foo_igen_oldie_interface_emit_changed (skeleton);
}

static void
_foo_igen_oldie_interface_on_signal_bar (
    FooiGenOldieInterface *object)
{
  FooiGenOldieInterfaceSkeleton *skeleton = FOO_IGEN_OLDIE_INTERFACE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "OldieInterface", "Bar",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void foo_igen_oldie_interface_skeleton_iface_init (FooiGenOldieInterfaceIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenOldieInterfaceSkeleton, foo_igen_oldie_interface_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (FooiGenOldieInterfaceSkeleton)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_OLDIE_INTERFACE, foo_igen_oldie_interface_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenOldieInterfaceSkeleton, foo_igen_oldie_interface_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_OLDIE_INTERFACE, foo_igen_oldie_interface_skeleton_iface_init));

#endif
static void
foo_igen_oldie_interface_skeleton_finalize (GObject *object)
{
  FooiGenOldieInterfaceSkeleton *skeleton = FOO_IGEN_OLDIE_INTERFACE_SKELETON (object);
  guint n;
  for (n = 0; n < 1; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_oldie_interface_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_oldie_interface_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  FooiGenOldieInterfaceSkeleton *skeleton = FOO_IGEN_OLDIE_INTERFACE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_foo_igen_oldie_interface_emit_changed (gpointer user_data)
{
  FooiGenOldieInterfaceSkeleton *skeleton = FOO_IGEN_OLDIE_INTERFACE_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "OldieInterface",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_foo_igen_oldie_interface_schedule_emit_changed (FooiGenOldieInterfaceSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
foo_igen_oldie_interface_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  FooiGenOldieInterfaceSkeleton *skeleton = FOO_IGEN_OLDIE_INTERFACE_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _foo_igen_oldie_interface_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _foo_igen_oldie_interface_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
foo_igen_oldie_interface_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooiGenOldieInterfaceSkeleton *skeleton = FOO_IGEN_OLDIE_INTERFACE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _foo_igen_oldie_interface_schedule_emit_changed (skeleton, _foo_igen_oldie_interface_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
foo_igen_oldie_interface_skeleton_init (FooiGenOldieInterfaceSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = foo_igen_oldie_interface_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_OLDIE_INTERFACE_SKELETON, FooiGenOldieInterfaceSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 1);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_INT);
}

static gint 
foo_igen_oldie_interface_skeleton_get_bat (FooiGenOldieInterface *object)
{
  FooiGenOldieInterfaceSkeleton *skeleton = FOO_IGEN_OLDIE_INTERFACE_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
foo_igen_oldie_interface_skeleton_class_init (FooiGenOldieInterfaceSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_oldie_interface_skeleton_finalize;
  gobject_class->get_property = foo_igen_oldie_interface_skeleton_get_property;
  gobject_class->set_property = foo_igen_oldie_interface_skeleton_set_property;
  gobject_class->notify       = foo_igen_oldie_interface_skeleton_notify;


  foo_igen_oldie_interface_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_oldie_interface_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_oldie_interface_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_oldie_interface_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_oldie_interface_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenOldieInterfaceSkeletonPrivate));
#endif
}

static void
foo_igen_oldie_interface_skeleton_iface_init (FooiGenOldieInterfaceIface *iface)
{
  iface->bar = _foo_igen_oldie_interface_on_signal_bar;
  iface->get_bat = foo_igen_oldie_interface_skeleton_get_bat;
}

/**
 * foo_igen_oldie_interface_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-OldieInterface.top_of_page">OldieInterface</link>.
 *
 * Returns: (transfer full) (type FooiGenOldieInterfaceSkeleton): The skeleton object.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
FooiGenOldieInterface *
foo_igen_oldie_interface_skeleton_new (void)
{
  return FOO_IGEN_OLDIE_INTERFACE (g_object_new (FOO_IGEN_TYPE_OLDIE_INTERFACE_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface UnknownXmlTags
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenUnknownXmlTags
 * @title: FooiGenUnknownXmlTags
 * @short_description: Generated C code for the UnknownXmlTags D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-UnknownXmlTags.top_of_page">UnknownXmlTags</link> D-Bus interface in C.
 */

/* ---- Introspection data for UnknownXmlTags ---- */

static const _ExtendedGDBusArgInfo _foo_igen_unknown_xml_tags_method_info_can_set_timezone_OUT_ARG_value =
{
  {
    -1,
    (gchar *) "value",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_unknown_xml_tags_method_info_can_set_timezone_OUT_ARG_pointers[] =
{
  &_foo_igen_unknown_xml_tags_method_info_can_set_timezone_OUT_ARG_value,
  NULL
};

static const GDBusAnnotationInfo _foo_igen_unknown_xml_tags_method_can_set_timezone_annotation_info_0 =
{
  -1,
  (gchar *) "org.freedesktop.DBus.GLib.Async",
  (gchar *) "",
  NULL
};

static const GDBusAnnotationInfo * const _foo_igen_unknown_xml_tags_method_can_set_timezone_annotation_info_pointers[] =
{
  &_foo_igen_unknown_xml_tags_method_can_set_timezone_annotation_info_0,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_igen_unknown_xml_tags_method_info_can_set_timezone =
{
  {
    -1,
    (gchar *) "CanSetTimezone",
    NULL,
    (GDBusArgInfo **) &_foo_igen_unknown_xml_tags_method_info_can_set_timezone_OUT_ARG_pointers,
    (GDBusAnnotationInfo **) &_foo_igen_unknown_xml_tags_method_can_set_timezone_annotation_info_pointers
  },
  "handle-can-set-timezone",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_unknown_xml_tags_method_info_pointers[] =
{
  &_foo_igen_unknown_xml_tags_method_info_can_set_timezone,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_igen_unknown_xml_tags_signal_info_some_signal =
{
  {
    -1,
    (gchar *) "SomeSignal",
    NULL,
    NULL
  },
  "some-signal"
};

static const _ExtendedGDBusSignalInfo * const _foo_igen_unknown_xml_tags_signal_info_pointers[] =
{
  &_foo_igen_unknown_xml_tags_signal_info_some_signal,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_igen_unknown_xml_tags_property_info_some_property =
{
  {
    -1,
    (gchar *) "SomeProperty",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "some-property",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _foo_igen_unknown_xml_tags_property_info_pointers[] =
{
  &_foo_igen_unknown_xml_tags_property_info_some_property,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_unknown_xml_tags_interface_info =
{
  {
    -1,
    (gchar *) "UnknownXmlTags",
    (GDBusMethodInfo **) &_foo_igen_unknown_xml_tags_method_info_pointers,
    (GDBusSignalInfo **) &_foo_igen_unknown_xml_tags_signal_info_pointers,
    (GDBusPropertyInfo **) &_foo_igen_unknown_xml_tags_property_info_pointers,
    NULL
  },
  "unknown-xml-tags",
};


/**
 * foo_igen_unknown_xml_tags_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-UnknownXmlTags.top_of_page">UnknownXmlTags</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_unknown_xml_tags_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_unknown_xml_tags_interface_info.parent_struct;
}

/**
 * foo_igen_unknown_xml_tags_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenUnknownXmlTags interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_unknown_xml_tags_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "some-property");
  return property_id_begin - 1;
}



/**
 * FooiGenUnknownXmlTags:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-UnknownXmlTags.top_of_page">UnknownXmlTags</link>.
 */

/**
 * FooiGenUnknownXmlTagsIface:
 * @parent_iface: The parent interface.
 * @handle_can_set_timezone: Handler for the #FooiGenUnknownXmlTags::handle-can-set-timezone signal.
 * @get_some_property: Getter for the #FooiGenUnknownXmlTags:some-property property.
 * @some_signal: Handler for the #FooiGenUnknownXmlTags::some-signal signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-UnknownXmlTags.top_of_page">UnknownXmlTags</link>.
 */

typedef FooiGenUnknownXmlTagsIface FooiGenUnknownXmlTagsInterface;
G_DEFINE_INTERFACE (FooiGenUnknownXmlTags, foo_igen_unknown_xml_tags, G_TYPE_OBJECT);

static void
foo_igen_unknown_xml_tags_default_init (FooiGenUnknownXmlTagsIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenUnknownXmlTags::handle-can-set-timezone:
   * @object: A #FooiGenUnknownXmlTags.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-UnknownXmlTags.CanSetTimezone">CanSetTimezone()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_unknown_xml_tags_complete_can_set_timezone() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-can-set-timezone",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenUnknownXmlTagsIface, handle_can_set_timezone),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooiGenUnknownXmlTags::some-signal:
   * @object: A #FooiGenUnknownXmlTags.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-UnknownXmlTags.SomeSignal">"SomeSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("some-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenUnknownXmlTagsIface, some_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /* GObject properties for D-Bus properties: */
  /**
   * FooiGenUnknownXmlTags:some-property:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-UnknownXmlTags.SomeProperty">"SomeProperty"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("some-property", "SomeProperty", "SomeProperty", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * foo_igen_unknown_xml_tags_get_some_property: (skip)
 * @object: A #FooiGenUnknownXmlTags.
 *
 * Gets the value of the <link linkend="gdbus-property-UnknownXmlTags.SomeProperty">"SomeProperty"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use foo_igen_unknown_xml_tags_dup_some_property() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
foo_igen_unknown_xml_tags_get_some_property (FooiGenUnknownXmlTags *object)
{
  return FOO_IGEN_UNKNOWN_XML_TAGS_GET_IFACE (object)->get_some_property (object);
}

/**
 * foo_igen_unknown_xml_tags_dup_some_property: (skip)
 * @object: A #FooiGenUnknownXmlTags.
 *
 * Gets a copy of the <link linkend="gdbus-property-UnknownXmlTags.SomeProperty">"SomeProperty"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
foo_igen_unknown_xml_tags_dup_some_property (FooiGenUnknownXmlTags *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "some-property", &value, NULL);
  return value;
}

/**
 * foo_igen_unknown_xml_tags_set_some_property: (skip)
 * @object: A #FooiGenUnknownXmlTags.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-UnknownXmlTags.SomeProperty">"SomeProperty"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_unknown_xml_tags_set_some_property (FooiGenUnknownXmlTags *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "some-property", value, NULL);
}

/**
 * foo_igen_unknown_xml_tags_emit_some_signal:
 * @object: A #FooiGenUnknownXmlTags.
 *
 * Emits the <link linkend="gdbus-signal-UnknownXmlTags.SomeSignal">"SomeSignal"</link> D-Bus signal.
 */
void
foo_igen_unknown_xml_tags_emit_some_signal (
    FooiGenUnknownXmlTags *object)
{
  g_signal_emit_by_name (object, "some-signal");
}

/**
 * foo_igen_unknown_xml_tags_call_can_set_timezone:
 * @proxy: A #FooiGenUnknownXmlTagsProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-UnknownXmlTags.CanSetTimezone">CanSetTimezone()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_unknown_xml_tags_call_can_set_timezone_finish() to get the result of the operation.
 *
 * See foo_igen_unknown_xml_tags_call_can_set_timezone_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_unknown_xml_tags_call_can_set_timezone (
    FooiGenUnknownXmlTags *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "CanSetTimezone",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_unknown_xml_tags_call_can_set_timezone_finish:
 * @proxy: A #FooiGenUnknownXmlTagsProxy.
 * @out_value: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_unknown_xml_tags_call_can_set_timezone().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_unknown_xml_tags_call_can_set_timezone().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_unknown_xml_tags_call_can_set_timezone_finish (
    FooiGenUnknownXmlTags *proxy,
    gint *out_value,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(i)",
                 out_value);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_unknown_xml_tags_call_can_set_timezone_sync:
 * @proxy: A #FooiGenUnknownXmlTagsProxy.
 * @out_value: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-UnknownXmlTags.CanSetTimezone">CanSetTimezone()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_unknown_xml_tags_call_can_set_timezone() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_unknown_xml_tags_call_can_set_timezone_sync (
    FooiGenUnknownXmlTags *proxy,
    gint *out_value,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "CanSetTimezone",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(i)",
                 out_value);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_unknown_xml_tags_complete_can_set_timezone:
 * @object: A #FooiGenUnknownXmlTags.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @value: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-UnknownXmlTags.CanSetTimezone">CanSetTimezone()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_unknown_xml_tags_complete_can_set_timezone (
    FooiGenUnknownXmlTags *object,
    GDBusMethodInvocation *invocation,
    gint value)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(i)",
                   value));
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenUnknownXmlTagsProxy:
 *
 * The #FooiGenUnknownXmlTagsProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenUnknownXmlTagsProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenUnknownXmlTagsProxy.
 */

struct _FooiGenUnknownXmlTagsProxyPrivate
{
  GData *qdata;
};

static void foo_igen_unknown_xml_tags_proxy_iface_init (FooiGenUnknownXmlTagsIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenUnknownXmlTagsProxy, foo_igen_unknown_xml_tags_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (FooiGenUnknownXmlTagsProxy)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_UNKNOWN_XML_TAGS, foo_igen_unknown_xml_tags_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenUnknownXmlTagsProxy, foo_igen_unknown_xml_tags_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_UNKNOWN_XML_TAGS, foo_igen_unknown_xml_tags_proxy_iface_init));

#endif
static void
foo_igen_unknown_xml_tags_proxy_finalize (GObject *object)
{
  FooiGenUnknownXmlTagsProxy *proxy = FOO_IGEN_UNKNOWN_XML_TAGS_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_unknown_xml_tags_proxy_parent_class)->finalize (object);
}

static void
foo_igen_unknown_xml_tags_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = _foo_igen_unknown_xml_tags_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
foo_igen_unknown_xml_tags_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface UnknownXmlTags: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
foo_igen_unknown_xml_tags_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = _foo_igen_unknown_xml_tags_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "UnknownXmlTags", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) foo_igen_unknown_xml_tags_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
foo_igen_unknown_xml_tags_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_unknown_xml_tags_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_UNKNOWN_XML_TAGS);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_UNKNOWN_XML_TAGS);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_unknown_xml_tags_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenUnknownXmlTagsProxy *proxy = FOO_IGEN_UNKNOWN_XML_TAGS_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_unknown_xml_tags_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_unknown_xml_tags_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static const gchar *
foo_igen_unknown_xml_tags_proxy_get_some_property (FooiGenUnknownXmlTags *object)
{
  FooiGenUnknownXmlTagsProxy *proxy = FOO_IGEN_UNKNOWN_XML_TAGS_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SomeProperty");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
foo_igen_unknown_xml_tags_proxy_init (FooiGenUnknownXmlTagsProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = foo_igen_unknown_xml_tags_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_UNKNOWN_XML_TAGS_PROXY, FooiGenUnknownXmlTagsProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_unknown_xml_tags_interface_info ());
}

static void
foo_igen_unknown_xml_tags_proxy_class_init (FooiGenUnknownXmlTagsProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_unknown_xml_tags_proxy_finalize;
  gobject_class->get_property = foo_igen_unknown_xml_tags_proxy_get_property;
  gobject_class->set_property = foo_igen_unknown_xml_tags_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_unknown_xml_tags_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_unknown_xml_tags_proxy_g_properties_changed;

  foo_igen_unknown_xml_tags_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenUnknownXmlTagsProxyPrivate));
#endif
}

static void
foo_igen_unknown_xml_tags_proxy_iface_init (FooiGenUnknownXmlTagsIface *iface)
{
  iface->get_some_property = foo_igen_unknown_xml_tags_proxy_get_some_property;
}

/**
 * foo_igen_unknown_xml_tags_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-UnknownXmlTags.top_of_page">UnknownXmlTags</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_unknown_xml_tags_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_unknown_xml_tags_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_unknown_xml_tags_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_UNKNOWN_XML_TAGS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "UnknownXmlTags", NULL);
}

/**
 * foo_igen_unknown_xml_tags_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_unknown_xml_tags_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_unknown_xml_tags_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenUnknownXmlTagsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenUnknownXmlTags *
foo_igen_unknown_xml_tags_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_UNKNOWN_XML_TAGS (ret);
  else
    return NULL;
}

/**
 * foo_igen_unknown_xml_tags_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-UnknownXmlTags.top_of_page">UnknownXmlTags</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_unknown_xml_tags_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenUnknownXmlTagsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenUnknownXmlTags *
foo_igen_unknown_xml_tags_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_UNKNOWN_XML_TAGS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "UnknownXmlTags", NULL);
  if (ret != NULL)
    return FOO_IGEN_UNKNOWN_XML_TAGS (ret);
  else
    return NULL;
}


/**
 * foo_igen_unknown_xml_tags_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_unknown_xml_tags_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_unknown_xml_tags_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_unknown_xml_tags_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_unknown_xml_tags_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_UNKNOWN_XML_TAGS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "UnknownXmlTags", NULL);
}

/**
 * foo_igen_unknown_xml_tags_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_unknown_xml_tags_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_unknown_xml_tags_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenUnknownXmlTagsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenUnknownXmlTags *
foo_igen_unknown_xml_tags_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_UNKNOWN_XML_TAGS (ret);
  else
    return NULL;
}

/**
 * foo_igen_unknown_xml_tags_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_unknown_xml_tags_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_unknown_xml_tags_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenUnknownXmlTagsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenUnknownXmlTags *
foo_igen_unknown_xml_tags_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_UNKNOWN_XML_TAGS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "UnknownXmlTags", NULL);
  if (ret != NULL)
    return FOO_IGEN_UNKNOWN_XML_TAGS (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenUnknownXmlTagsSkeleton:
 *
 * The #FooiGenUnknownXmlTagsSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenUnknownXmlTagsSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenUnknownXmlTagsSkeleton.
 */

struct _FooiGenUnknownXmlTagsSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_foo_igen_unknown_xml_tags_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenUnknownXmlTagsSkeleton *skeleton = FOO_IGEN_UNKNOWN_XML_TAGS_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_UNKNOWN_XML_TAGS);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_UNKNOWN_XML_TAGS);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_unknown_xml_tags_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenUnknownXmlTagsSkeleton *skeleton = FOO_IGEN_UNKNOWN_XML_TAGS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_unknown_xml_tags_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_unknown_xml_tags_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenUnknownXmlTagsSkeleton *skeleton = FOO_IGEN_UNKNOWN_XML_TAGS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_unknown_xml_tags_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_unknown_xml_tags_skeleton_vtable =
{
  _foo_igen_unknown_xml_tags_skeleton_handle_method_call,
  _foo_igen_unknown_xml_tags_skeleton_handle_get_property,
  _foo_igen_unknown_xml_tags_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
foo_igen_unknown_xml_tags_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return foo_igen_unknown_xml_tags_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_unknown_xml_tags_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_foo_igen_unknown_xml_tags_skeleton_vtable;
}

static GVariant *
foo_igen_unknown_xml_tags_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenUnknownXmlTagsSkeleton *skeleton = FOO_IGEN_UNKNOWN_XML_TAGS_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_unknown_xml_tags_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_unknown_xml_tags_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_unknown_xml_tags_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_unknown_xml_tags_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "UnknownXmlTags", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _foo_igen_unknown_xml_tags_emit_changed (gpointer user_data);

static void
foo_igen_unknown_xml_tags_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenUnknownXmlTagsSkeleton *skeleton = FOO_IGEN_UNKNOWN_XML_TAGS_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _foo_igen_unknown_xml_tags_emit_changed (skeleton);
}

static void
_foo_igen_unknown_xml_tags_on_signal_some_signal (
    FooiGenUnknownXmlTags *object)
{
  FooiGenUnknownXmlTagsSkeleton *skeleton = FOO_IGEN_UNKNOWN_XML_TAGS_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "UnknownXmlTags", "SomeSignal",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void foo_igen_unknown_xml_tags_skeleton_iface_init (FooiGenUnknownXmlTagsIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenUnknownXmlTagsSkeleton, foo_igen_unknown_xml_tags_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (FooiGenUnknownXmlTagsSkeleton)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_UNKNOWN_XML_TAGS, foo_igen_unknown_xml_tags_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenUnknownXmlTagsSkeleton, foo_igen_unknown_xml_tags_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_UNKNOWN_XML_TAGS, foo_igen_unknown_xml_tags_skeleton_iface_init));

#endif
static void
foo_igen_unknown_xml_tags_skeleton_finalize (GObject *object)
{
  FooiGenUnknownXmlTagsSkeleton *skeleton = FOO_IGEN_UNKNOWN_XML_TAGS_SKELETON (object);
  guint n;
  for (n = 0; n < 1; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_unknown_xml_tags_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_unknown_xml_tags_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  FooiGenUnknownXmlTagsSkeleton *skeleton = FOO_IGEN_UNKNOWN_XML_TAGS_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_foo_igen_unknown_xml_tags_emit_changed (gpointer user_data)
{
  FooiGenUnknownXmlTagsSkeleton *skeleton = FOO_IGEN_UNKNOWN_XML_TAGS_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "UnknownXmlTags",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_foo_igen_unknown_xml_tags_schedule_emit_changed (FooiGenUnknownXmlTagsSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
foo_igen_unknown_xml_tags_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  FooiGenUnknownXmlTagsSkeleton *skeleton = FOO_IGEN_UNKNOWN_XML_TAGS_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _foo_igen_unknown_xml_tags_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _foo_igen_unknown_xml_tags_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
foo_igen_unknown_xml_tags_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooiGenUnknownXmlTagsSkeleton *skeleton = FOO_IGEN_UNKNOWN_XML_TAGS_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _foo_igen_unknown_xml_tags_schedule_emit_changed (skeleton, _foo_igen_unknown_xml_tags_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
foo_igen_unknown_xml_tags_skeleton_init (FooiGenUnknownXmlTagsSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = foo_igen_unknown_xml_tags_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_UNKNOWN_XML_TAGS_SKELETON, FooiGenUnknownXmlTagsSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 1);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_STRING);
}

static const gchar *
foo_igen_unknown_xml_tags_skeleton_get_some_property (FooiGenUnknownXmlTags *object)
{
  FooiGenUnknownXmlTagsSkeleton *skeleton = FOO_IGEN_UNKNOWN_XML_TAGS_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
foo_igen_unknown_xml_tags_skeleton_class_init (FooiGenUnknownXmlTagsSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_unknown_xml_tags_skeleton_finalize;
  gobject_class->get_property = foo_igen_unknown_xml_tags_skeleton_get_property;
  gobject_class->set_property = foo_igen_unknown_xml_tags_skeleton_set_property;
  gobject_class->notify       = foo_igen_unknown_xml_tags_skeleton_notify;


  foo_igen_unknown_xml_tags_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_unknown_xml_tags_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_unknown_xml_tags_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_unknown_xml_tags_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_unknown_xml_tags_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenUnknownXmlTagsSkeletonPrivate));
#endif
}

static void
foo_igen_unknown_xml_tags_skeleton_iface_init (FooiGenUnknownXmlTagsIface *iface)
{
  iface->some_signal = _foo_igen_unknown_xml_tags_on_signal_some_signal;
  iface->get_some_property = foo_igen_unknown_xml_tags_skeleton_get_some_property;
}

/**
 * foo_igen_unknown_xml_tags_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-UnknownXmlTags.top_of_page">UnknownXmlTags</link>.
 *
 * Returns: (transfer full) (type FooiGenUnknownXmlTagsSkeleton): The skeleton object.
 */
FooiGenUnknownXmlTags *
foo_igen_unknown_xml_tags_skeleton_new (void)
{
  return FOO_IGEN_UNKNOWN_XML_TAGS (g_object_new (FOO_IGEN_TYPE_UNKNOWN_XML_TAGS_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface FDPassing
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenFDPassing
 * @title: FooiGenFDPassing
 * @short_description: Generated C code for the FDPassing D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-FDPassing.top_of_page">FDPassing</link> D-Bus interface in C.
 */

/* ---- Introspection data for FDPassing ---- */

static const _ExtendedGDBusArgInfo _foo_igen_fdpassing_method_info_hello_fd_IN_ARG_greeting =
{
  {
    -1,
    (gchar *) "greeting",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_fdpassing_method_info_hello_fd_IN_ARG_pointers[] =
{
  &_foo_igen_fdpassing_method_info_hello_fd_IN_ARG_greeting,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_igen_fdpassing_method_info_hello_fd_OUT_ARG_response =
{
  {
    -1,
    (gchar *) "response",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_igen_fdpassing_method_info_hello_fd_OUT_ARG_pointers[] =
{
  &_foo_igen_fdpassing_method_info_hello_fd_OUT_ARG_response,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_igen_fdpassing_method_info_hello_fd =
{
  {
    -1,
    (gchar *) "HelloFD",
    (GDBusArgInfo **) &_foo_igen_fdpassing_method_info_hello_fd_IN_ARG_pointers,
    (GDBusArgInfo **) &_foo_igen_fdpassing_method_info_hello_fd_OUT_ARG_pointers,
    NULL
  },
  "handle-hello-fd",
  TRUE
};

static const _ExtendedGDBusMethodInfo * const _foo_igen_fdpassing_method_info_pointers[] =
{
  &_foo_igen_fdpassing_method_info_hello_fd,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_fdpassing_interface_info =
{
  {
    -1,
    (gchar *) "FDPassing",
    (GDBusMethodInfo **) &_foo_igen_fdpassing_method_info_pointers,
    NULL,
    NULL,
    NULL
  },
  "fdpassing",
};


/**
 * foo_igen_fdpassing_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-FDPassing.top_of_page">FDPassing</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_fdpassing_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_fdpassing_interface_info.parent_struct;
}

/**
 * foo_igen_fdpassing_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenFDPassing interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_fdpassing_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * FooiGenFDPassing:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-FDPassing.top_of_page">FDPassing</link>.
 */

/**
 * FooiGenFDPassingIface:
 * @parent_iface: The parent interface.
 * @handle_hello_fd: Handler for the #FooiGenFDPassing::handle-hello-fd signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-FDPassing.top_of_page">FDPassing</link>.
 */

typedef FooiGenFDPassingIface FooiGenFDPassingInterface;
G_DEFINE_INTERFACE (FooiGenFDPassing, foo_igen_fdpassing, G_TYPE_OBJECT);

static void
foo_igen_fdpassing_default_init (FooiGenFDPassingIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooiGenFDPassing::handle-hello-fd:
   * @object: A #FooiGenFDPassing.
   * @invocation: A #GDBusMethodInvocation.
   * @fd_list: (allow-none): A #GUnixFDList or %NULL.
   * @arg_greeting: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-FDPassing.HelloFD">HelloFD()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_igen_fdpassing_complete_hello_fd() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-hello-fd",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooiGenFDPassingIface, handle_hello_fd),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    3,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_UNIX_FD_LIST, G_TYPE_STRING);

}

/**
 * foo_igen_fdpassing_call_hello_fd:
 * @proxy: A #FooiGenFDPassingProxy.
 * @arg_greeting: Argument to pass with the method invocation.
 * @fd_list: (allow-none): A #GUnixFDList or %NULL.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-FDPassing.HelloFD">HelloFD()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_fdpassing_call_hello_fd_finish() to get the result of the operation.
 *
 * See foo_igen_fdpassing_call_hello_fd_sync() for the synchronous, blocking version of this method.
 */
void
foo_igen_fdpassing_call_hello_fd (
    FooiGenFDPassing *proxy,
    const gchar *arg_greeting,
    GUnixFDList *fd_list,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call_with_unix_fd_list (G_DBUS_PROXY (proxy),
    "HelloFD",
    g_variant_new ("(s)",
                   arg_greeting),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    fd_list,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_igen_fdpassing_call_hello_fd_finish:
 * @proxy: A #FooiGenFDPassingProxy.
 * @out_response: (out): Return location for return parameter or %NULL to ignore.
 * @out_fd_list: (out): Return location for a #GUnixFDList or %NULL.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_fdpassing_call_hello_fd().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_igen_fdpassing_call_hello_fd().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_fdpassing_call_hello_fd_finish (
    FooiGenFDPassing *proxy,
    gchar **out_response,
    GUnixFDList **out_fd_list,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_with_unix_fd_list_finish (G_DBUS_PROXY (proxy), out_fd_list, res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_response);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_fdpassing_call_hello_fd_sync:
 * @proxy: A #FooiGenFDPassingProxy.
 * @arg_greeting: Argument to pass with the method invocation.
 * @fd_list: (allow-none): A #GUnixFDList or %NULL.
 * @out_response: (out): Return location for return parameter or %NULL to ignore.
 * @out_fd_list: (out): Return location for a #GUnixFDList or %NULL.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-FDPassing.HelloFD">HelloFD()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_igen_fdpassing_call_hello_fd() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_igen_fdpassing_call_hello_fd_sync (
    FooiGenFDPassing *proxy,
    const gchar *arg_greeting,
    GUnixFDList  *fd_list,
    gchar **out_response,
    GUnixFDList **out_fd_list,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_with_unix_fd_list_sync (G_DBUS_PROXY (proxy),
    "HelloFD",
    g_variant_new ("(s)",
                   arg_greeting),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    fd_list,
    out_fd_list,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_response);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_igen_fdpassing_complete_hello_fd:
 * @object: A #FooiGenFDPassing.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @fd_list: (allow-none): A #GUnixFDList or %NULL.
 * @response: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-FDPassing.HelloFD">HelloFD()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_igen_fdpassing_complete_hello_fd (
    FooiGenFDPassing *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    const gchar *response)
{
  g_dbus_method_invocation_return_value_with_unix_fd_list (invocation,
    g_variant_new ("(s)",
                   response),
    fd_list);
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenFDPassingProxy:
 *
 * The #FooiGenFDPassingProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenFDPassingProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenFDPassingProxy.
 */

struct _FooiGenFDPassingProxyPrivate
{
  GData *qdata;
};

static void foo_igen_fdpassing_proxy_iface_init (FooiGenFDPassingIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenFDPassingProxy, foo_igen_fdpassing_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (FooiGenFDPassingProxy)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_FDPASSING, foo_igen_fdpassing_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenFDPassingProxy, foo_igen_fdpassing_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_FDPASSING, foo_igen_fdpassing_proxy_iface_init));

#endif
static void
foo_igen_fdpassing_proxy_finalize (GObject *object)
{
  FooiGenFDPassingProxy *proxy = FOO_IGEN_FDPASSING_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_fdpassing_proxy_parent_class)->finalize (object);
}

static void
foo_igen_fdpassing_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
foo_igen_fdpassing_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
foo_igen_fdpassing_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_fdpassing_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_FDPASSING);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_FDPASSING);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_fdpassing_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenFDPassingProxy *proxy = FOO_IGEN_FDPASSING_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_fdpassing_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_fdpassing_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_igen_fdpassing_proxy_init (FooiGenFDPassingProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = foo_igen_fdpassing_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_FDPASSING_PROXY, FooiGenFDPassingProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_fdpassing_interface_info ());
}

static void
foo_igen_fdpassing_proxy_class_init (FooiGenFDPassingProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_fdpassing_proxy_finalize;
  gobject_class->get_property = foo_igen_fdpassing_proxy_get_property;
  gobject_class->set_property = foo_igen_fdpassing_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_fdpassing_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_fdpassing_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenFDPassingProxyPrivate));
#endif
}

static void
foo_igen_fdpassing_proxy_iface_init (FooiGenFDPassingIface *iface)
{
}

/**
 * foo_igen_fdpassing_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-FDPassing.top_of_page">FDPassing</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_fdpassing_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_fdpassing_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_fdpassing_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_FDPASSING_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "FDPassing", NULL);
}

/**
 * foo_igen_fdpassing_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_fdpassing_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_fdpassing_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenFDPassingProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenFDPassing *
foo_igen_fdpassing_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_FDPASSING (ret);
  else
    return NULL;
}

/**
 * foo_igen_fdpassing_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-FDPassing.top_of_page">FDPassing</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_fdpassing_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenFDPassingProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenFDPassing *
foo_igen_fdpassing_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_FDPASSING_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "FDPassing", NULL);
  if (ret != NULL)
    return FOO_IGEN_FDPASSING (ret);
  else
    return NULL;
}


/**
 * foo_igen_fdpassing_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_fdpassing_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_fdpassing_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_fdpassing_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_fdpassing_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_FDPASSING_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "FDPassing", NULL);
}

/**
 * foo_igen_fdpassing_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_fdpassing_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_fdpassing_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenFDPassingProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenFDPassing *
foo_igen_fdpassing_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_FDPASSING (ret);
  else
    return NULL;
}

/**
 * foo_igen_fdpassing_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_fdpassing_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_fdpassing_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenFDPassingProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenFDPassing *
foo_igen_fdpassing_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_FDPASSING_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "FDPassing", NULL);
  if (ret != NULL)
    return FOO_IGEN_FDPASSING (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenFDPassingSkeleton:
 *
 * The #FooiGenFDPassingSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenFDPassingSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenFDPassingSkeleton.
 */

struct _FooiGenFDPassingSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_foo_igen_fdpassing_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenFDPassingSkeleton *skeleton = FOO_IGEN_FDPASSING_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_FDPASSING);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_FDPASSING);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_fdpassing_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenFDPassingSkeleton *skeleton = FOO_IGEN_FDPASSING_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_fdpassing_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_fdpassing_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenFDPassingSkeleton *skeleton = FOO_IGEN_FDPASSING_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_fdpassing_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_fdpassing_skeleton_vtable =
{
  _foo_igen_fdpassing_skeleton_handle_method_call,
  _foo_igen_fdpassing_skeleton_handle_get_property,
  _foo_igen_fdpassing_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
foo_igen_fdpassing_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return foo_igen_fdpassing_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_fdpassing_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_foo_igen_fdpassing_skeleton_vtable;
}

static GVariant *
foo_igen_fdpassing_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenFDPassingSkeleton *skeleton = FOO_IGEN_FDPASSING_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_fdpassing_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_fdpassing_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_fdpassing_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_fdpassing_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "FDPassing", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
foo_igen_fdpassing_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void foo_igen_fdpassing_skeleton_iface_init (FooiGenFDPassingIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenFDPassingSkeleton, foo_igen_fdpassing_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (FooiGenFDPassingSkeleton)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_FDPASSING, foo_igen_fdpassing_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenFDPassingSkeleton, foo_igen_fdpassing_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_FDPASSING, foo_igen_fdpassing_skeleton_iface_init));

#endif
static void
foo_igen_fdpassing_skeleton_finalize (GObject *object)
{
  FooiGenFDPassingSkeleton *skeleton = FOO_IGEN_FDPASSING_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_fdpassing_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_fdpassing_skeleton_init (FooiGenFDPassingSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = foo_igen_fdpassing_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_FDPASSING_SKELETON, FooiGenFDPassingSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
foo_igen_fdpassing_skeleton_class_init (FooiGenFDPassingSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_fdpassing_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_fdpassing_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_fdpassing_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_fdpassing_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_fdpassing_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenFDPassingSkeletonPrivate));
#endif
}

static void
foo_igen_fdpassing_skeleton_iface_init (FooiGenFDPassingIface *iface)
{
}

/**
 * foo_igen_fdpassing_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-FDPassing.top_of_page">FDPassing</link>.
 *
 * Returns: (transfer full) (type FooiGenFDPassingSkeleton): The skeleton object.
 */
FooiGenFDPassing *
foo_igen_fdpassing_skeleton_new (void)
{
  return FOO_IGEN_FDPASSING (g_object_new (FOO_IGEN_TYPE_FDPASSING_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface Naming
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenNaming
 * @title: FooiGenNaming
 * @short_description: Generated C code for the Naming D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-Naming.top_of_page">Naming</link> D-Bus interface in C.
 */

/* ---- Introspection data for Naming ---- */

static const _ExtendedGDBusPropertyInfo _foo_igen_naming_property_info_type_ =
{
  {
    -1,
    (gchar *) "Type",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "type",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _foo_igen_naming_property_info_pointers[] =
{
  &_foo_igen_naming_property_info_type_,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_igen_naming_interface_info =
{
  {
    -1,
    (gchar *) "Naming",
    NULL,
    NULL,
    (GDBusPropertyInfo **) &_foo_igen_naming_property_info_pointers,
    NULL
  },
  "naming",
};


/**
 * foo_igen_naming_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-Naming.top_of_page">Naming</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_igen_naming_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_igen_naming_interface_info.parent_struct;
}

/**
 * foo_igen_naming_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooiGenNaming interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_igen_naming_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "type");
  return property_id_begin - 1;
}



/**
 * FooiGenNaming:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-Naming.top_of_page">Naming</link>.
 */

/**
 * FooiGenNamingIface:
 * @parent_iface: The parent interface.
 * @get_type_: Getter for the #FooiGenNaming:type property.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-Naming.top_of_page">Naming</link>.
 */

typedef FooiGenNamingIface FooiGenNamingInterface;
G_DEFINE_INTERFACE (FooiGenNaming, foo_igen_naming, G_TYPE_OBJECT);

static void
foo_igen_naming_default_init (FooiGenNamingIface *iface)
{
  /* GObject properties for D-Bus properties: */
  /**
   * FooiGenNaming:type:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-Naming.Type">"Type"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("type", "Type", "Type", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * foo_igen_naming_get_type_: (skip)
 * @object: A #FooiGenNaming.
 *
 * Gets the value of the <link linkend="gdbus-property-Naming.Type">"Type"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
foo_igen_naming_get_type_ (FooiGenNaming *object)
{
  return FOO_IGEN_NAMING_GET_IFACE (object)->get_type_ (object);
}

/**
 * foo_igen_naming_set_type_: (skip)
 * @object: A #FooiGenNaming.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-Naming.Type">"Type"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_igen_naming_set_type_ (FooiGenNaming *object, gint value)
{
  g_object_set (G_OBJECT (object), "type", value, NULL);
}

/* ------------------------------------------------------------------------ */

/**
 * FooiGenNamingProxy:
 *
 * The #FooiGenNamingProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenNamingProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenNamingProxy.
 */

struct _FooiGenNamingProxyPrivate
{
  GData *qdata;
};

static void foo_igen_naming_proxy_iface_init (FooiGenNamingIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenNamingProxy, foo_igen_naming_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (FooiGenNamingProxy)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_NAMING, foo_igen_naming_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenNamingProxy, foo_igen_naming_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_NAMING, foo_igen_naming_proxy_iface_init));

#endif
static void
foo_igen_naming_proxy_finalize (GObject *object)
{
  FooiGenNamingProxy *proxy = FOO_IGEN_NAMING_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (foo_igen_naming_proxy_parent_class)->finalize (object);
}

static void
foo_igen_naming_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = _foo_igen_naming_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
foo_igen_naming_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface Naming: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
foo_igen_naming_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = _foo_igen_naming_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "Naming", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) foo_igen_naming_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
foo_igen_naming_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_igen_naming_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_IGEN_TYPE_NAMING);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_NAMING);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_igen_naming_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FooiGenNamingProxy *proxy = FOO_IGEN_NAMING_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_naming_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_naming_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static gint 
foo_igen_naming_proxy_get_type_ (FooiGenNaming *object)
{
  FooiGenNamingProxy *proxy = FOO_IGEN_NAMING_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Type");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static void
foo_igen_naming_proxy_init (FooiGenNamingProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = foo_igen_naming_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, FOO_IGEN_TYPE_NAMING_PROXY, FooiGenNamingProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_igen_naming_interface_info ());
}

static void
foo_igen_naming_proxy_class_init (FooiGenNamingProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = foo_igen_naming_proxy_finalize;
  gobject_class->get_property = foo_igen_naming_proxy_get_property;
  gobject_class->set_property = foo_igen_naming_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_igen_naming_proxy_g_signal;
  proxy_class->g_properties_changed = foo_igen_naming_proxy_g_properties_changed;

  foo_igen_naming_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenNamingProxyPrivate));
#endif
}

static void
foo_igen_naming_proxy_iface_init (FooiGenNamingIface *iface)
{
  iface->get_type_ = foo_igen_naming_proxy_get_type_;
}

/**
 * foo_igen_naming_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-Naming.top_of_page">Naming</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_naming_proxy_new_finish() to get the result of the operation.
 *
 * See foo_igen_naming_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_naming_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_NAMING_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "Naming", NULL);
}

/**
 * foo_igen_naming_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_naming_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_naming_proxy_new().
 *
 * Returns: (transfer full) (type FooiGenNamingProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenNaming *
foo_igen_naming_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_NAMING (ret);
  else
    return NULL;
}

/**
 * foo_igen_naming_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-Naming.top_of_page">Naming</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_naming_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenNamingProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenNaming *
foo_igen_naming_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_NAMING_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "Naming", NULL);
  if (ret != NULL)
    return FOO_IGEN_NAMING (ret);
  else
    return NULL;
}


/**
 * foo_igen_naming_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_naming_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_naming_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_naming_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_naming_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_NAMING_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "Naming", NULL);
}

/**
 * foo_igen_naming_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_naming_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_naming_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenNamingProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenNaming *
foo_igen_naming_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_IGEN_NAMING (ret);
  else
    return NULL;
}

/**
 * foo_igen_naming_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_naming_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_naming_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenNamingProxy): The constructed proxy object or %NULL if @error is set.
 */
FooiGenNaming *
foo_igen_naming_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_NAMING_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "Naming", NULL);
  if (ret != NULL)
    return FOO_IGEN_NAMING (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooiGenNamingSkeleton:
 *
 * The #FooiGenNamingSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenNamingSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenNamingSkeleton.
 */

struct _FooiGenNamingSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_foo_igen_naming_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooiGenNamingSkeleton *skeleton = FOO_IGEN_NAMING_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_IGEN_TYPE_NAMING);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_IGEN_TYPE_NAMING);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_igen_naming_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooiGenNamingSkeleton *skeleton = FOO_IGEN_NAMING_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_naming_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_igen_naming_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooiGenNamingSkeleton *skeleton = FOO_IGEN_NAMING_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_igen_naming_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_igen_naming_skeleton_vtable =
{
  _foo_igen_naming_skeleton_handle_method_call,
  _foo_igen_naming_skeleton_handle_get_property,
  _foo_igen_naming_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
foo_igen_naming_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return foo_igen_naming_interface_info ();
}

static GDBusInterfaceVTable *
foo_igen_naming_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_foo_igen_naming_skeleton_vtable;
}

static GVariant *
foo_igen_naming_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenNamingSkeleton *skeleton = FOO_IGEN_NAMING_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_igen_naming_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_igen_naming_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_igen_naming_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_igen_naming_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "Naming", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _foo_igen_naming_emit_changed (gpointer user_data);

static void
foo_igen_naming_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FooiGenNamingSkeleton *skeleton = FOO_IGEN_NAMING_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _foo_igen_naming_emit_changed (skeleton);
}

static void foo_igen_naming_skeleton_iface_init (FooiGenNamingIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FooiGenNamingSkeleton, foo_igen_naming_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (FooiGenNamingSkeleton)
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_NAMING, foo_igen_naming_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FooiGenNamingSkeleton, foo_igen_naming_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_NAMING, foo_igen_naming_skeleton_iface_init));

#endif
static void
foo_igen_naming_skeleton_finalize (GObject *object)
{
  FooiGenNamingSkeleton *skeleton = FOO_IGEN_NAMING_SKELETON (object);
  guint n;
  for (n = 0; n < 1; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (foo_igen_naming_skeleton_parent_class)->finalize (object);
}

static void
foo_igen_naming_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  FooiGenNamingSkeleton *skeleton = FOO_IGEN_NAMING_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_foo_igen_naming_emit_changed (gpointer user_data)
{
  FooiGenNamingSkeleton *skeleton = FOO_IGEN_NAMING_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "Naming",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_foo_igen_naming_schedule_emit_changed (FooiGenNamingSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
foo_igen_naming_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  FooiGenNamingSkeleton *skeleton = FOO_IGEN_NAMING_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _foo_igen_naming_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _foo_igen_naming_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
foo_igen_naming_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooiGenNamingSkeleton *skeleton = FOO_IGEN_NAMING_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _foo_igen_naming_schedule_emit_changed (skeleton, _foo_igen_naming_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
foo_igen_naming_skeleton_init (FooiGenNamingSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = foo_igen_naming_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_IGEN_TYPE_NAMING_SKELETON, FooiGenNamingSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 1);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_INT);
}

static gint 
foo_igen_naming_skeleton_get_type_ (FooiGenNaming *object)
{
  FooiGenNamingSkeleton *skeleton = FOO_IGEN_NAMING_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
foo_igen_naming_skeleton_class_init (FooiGenNamingSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_igen_naming_skeleton_finalize;
  gobject_class->get_property = foo_igen_naming_skeleton_get_property;
  gobject_class->set_property = foo_igen_naming_skeleton_set_property;
  gobject_class->notify       = foo_igen_naming_skeleton_notify;


  foo_igen_naming_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_igen_naming_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_igen_naming_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_igen_naming_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_igen_naming_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FooiGenNamingSkeletonPrivate));
#endif
}

static void
foo_igen_naming_skeleton_iface_init (FooiGenNamingIface *iface)
{
  iface->get_type_ = foo_igen_naming_skeleton_get_type_;
}

/**
 * foo_igen_naming_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-Naming.top_of_page">Naming</link>.
 *
 * Returns: (transfer full) (type FooiGenNamingSkeleton): The skeleton object.
 */
FooiGenNaming *
foo_igen_naming_skeleton_new (void)
{
  return FOO_IGEN_NAMING (g_object_new (FOO_IGEN_TYPE_NAMING_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for Object, ObjectProxy and ObjectSkeleton
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenObject
 * @title: FooiGenObject
 * @short_description: Specialized GDBusObject types
 *
 * This section contains the #FooiGenObject, #FooiGenObjectProxy, and #FooiGenObjectSkeleton types which make it easier to work with objects implementing generated types for D-Bus interfaces.
 */

/**
 * FooiGenObject:
 *
 * The #FooiGenObject type is a specialized container of interfaces.
 */

/**
 * FooiGenObjectIface:
 * @parent_iface: The parent interface.
 *
 * Virtual table for the #FooiGenObject interface.
 */

typedef FooiGenObjectIface FooiGenObjectInterface;
G_DEFINE_INTERFACE_WITH_CODE (FooiGenObject, foo_igen_object, G_TYPE_OBJECT, g_type_interface_add_prerequisite (g_define_type_id, G_TYPE_DBUS_OBJECT));

static void
foo_igen_object_default_init (FooiGenObjectIface *iface)
{
  /**
   * FooiGenObject:bar:
   *
   * The #FooiGenBar instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("bar", "bar", "bar", FOO_IGEN_TYPE_BAR, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooiGenObject:bar-frobnicator:
   *
   * The #FooiGenBarFrobnicator instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("bar-frobnicator", "bar-frobnicator", "bar-frobnicator", FOO_IGEN_TYPE_BAR_FROBNICATOR, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooiGenObject:baz:
   *
   * The #FooiGenBaz instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("baz", "baz", "baz", FOO_IGEN_TYPE_BAZ, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooiGenObject:com-acme-coyote:
   *
   * The #FooiGenComAcmeCoyote instance corresponding to the D-Bus interface <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("com-acme-coyote", "com-acme-coyote", "com-acme-coyote", FOO_IGEN_TYPE_COM_ACME_COYOTE, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooiGenObject:rocket123:
   *
   * The #FooiGenRocket123 instance corresponding to the D-Bus interface <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("rocket123", "rocket123", "rocket123", FOO_IGEN_TYPE_ROCKET123, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooiGenObject:bat:
   *
   * The #FooiGenBat instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("bat", "bat", "bat", FOO_IGEN_TYPE_BAT, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooiGenObject:authorize:
   *
   * The #FooiGenAuthorize instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("authorize", "authorize", "authorize", FOO_IGEN_TYPE_AUTHORIZE, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooiGenObject:method-threads:
   *
   * The #FooiGenMethodThreads instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("method-threads", "method-threads", "method-threads", FOO_IGEN_TYPE_METHOD_THREADS, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooiGenObject:inline-docs:
   *
   * The #FooiGenInlineDocs instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("inline-docs", "inline-docs", "inline-docs", FOO_IGEN_TYPE_INLINE_DOCS, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooiGenObject:changing-interface-v1:
   *
   * The #FooiGenChangingInterfaceV1 instance corresponding to the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV1.top_of_page">ChangingInterfaceV1</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("changing-interface-v1", "changing-interface-v1", "changing-interface-v1", FOO_IGEN_TYPE_CHANGING_INTERFACE_V1, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooiGenObject:changing-interface-v2:
   *
   * The #FooiGenChangingInterfaceV2 instance corresponding to the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV2.top_of_page">ChangingInterfaceV2</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("changing-interface-v2", "changing-interface-v2", "changing-interface-v2", FOO_IGEN_TYPE_CHANGING_INTERFACE_V2, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooiGenObject:changing-interface-v10:
   *
   * The #FooiGenChangingInterfaceV10 instance corresponding to the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV10.top_of_page">ChangingInterfaceV10</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("changing-interface-v10", "changing-interface-v10", "changing-interface-v10", FOO_IGEN_TYPE_CHANGING_INTERFACE_V10, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooiGenObject:test-ugly-case-interface:
   *
   * The #FooiGenTesTuglyCASEInterface instance corresponding to the D-Bus interface <link linkend="gdbus-interface-TestUglyCaseInterface.top_of_page">TestUglyCaseInterface</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("test-ugly-case-interface", "test-ugly-case-interface", "test-ugly-case-interface", FOO_IGEN_TYPE_TEST_UGLY_CASE_INTERFACE, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooiGenObject:oldie-interface:
   *
   * The #FooiGenOldieInterface instance corresponding to the D-Bus interface <link linkend="gdbus-interface-OldieInterface.top_of_page">OldieInterface</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   *
   * Deprecated: The D-Bus interface has been deprecated.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("oldie-interface", "oldie-interface", "oldie-interface", FOO_IGEN_TYPE_OLDIE_INTERFACE, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooiGenObject:unknown-xml-tags:
   *
   * The #FooiGenUnknownXmlTags instance corresponding to the D-Bus interface <link linkend="gdbus-interface-UnknownXmlTags.top_of_page">UnknownXmlTags</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("unknown-xml-tags", "unknown-xml-tags", "unknown-xml-tags", FOO_IGEN_TYPE_UNKNOWN_XML_TAGS, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooiGenObject:fdpassing:
   *
   * The #FooiGenFDPassing instance corresponding to the D-Bus interface <link linkend="gdbus-interface-FDPassing.top_of_page">FDPassing</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("fdpassing", "fdpassing", "fdpassing", FOO_IGEN_TYPE_FDPASSING, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooiGenObject:naming:
   *
   * The #FooiGenNaming instance corresponding to the D-Bus interface <link linkend="gdbus-interface-Naming.top_of_page">Naming</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("naming", "naming", "naming", FOO_IGEN_TYPE_NAMING, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

}

/**
 * foo_igen_object_get_bar:
 * @object: A #FooiGenObject.
 *
 * Gets the #FooiGenBar instance for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooiGenBar that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooiGenBar *foo_igen_object_get_bar (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bar");
  if (ret == NULL)
    return NULL;
  return FOO_IGEN_BAR (ret);
}

/**
 * foo_igen_object_get_bar_frobnicator:
 * @object: A #FooiGenObject.
 *
 * Gets the #FooiGenBarFrobnicator instance for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooiGenBarFrobnicator that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooiGenBarFrobnicator *foo_igen_object_get_bar_frobnicator (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bar.Frobnicator");
  if (ret == NULL)
    return NULL;
  return FOO_IGEN_BAR_FROBNICATOR (ret);
}

/**
 * foo_igen_object_get_baz:
 * @object: A #FooiGenObject.
 *
 * Gets the #FooiGenBaz instance for the D-Bus interface <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooiGenBaz that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooiGenBaz *foo_igen_object_get_baz (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Baz");
  if (ret == NULL)
    return NULL;
  return FOO_IGEN_BAZ (ret);
}

/**
 * foo_igen_object_get_com_acme_coyote:
 * @object: A #FooiGenObject.
 *
 * Gets the #FooiGenComAcmeCoyote instance for the D-Bus interface <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooiGenComAcmeCoyote that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooiGenComAcmeCoyote *foo_igen_object_get_com_acme_coyote (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "com.acme.Coyote");
  if (ret == NULL)
    return NULL;
  return FOO_IGEN_COM_ACME_COYOTE (ret);
}

/**
 * foo_igen_object_get_rocket123:
 * @object: A #FooiGenObject.
 *
 * Gets the #FooiGenRocket123 instance for the D-Bus interface <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooiGenRocket123 that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooiGenRocket123 *foo_igen_object_get_rocket123 (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "com.acme.Rocket");
  if (ret == NULL)
    return NULL;
  return FOO_IGEN_ROCKET123 (ret);
}

/**
 * foo_igen_object_get_bat:
 * @object: A #FooiGenObject.
 *
 * Gets the #FooiGenBat instance for the D-Bus interface <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooiGenBat that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooiGenBat *foo_igen_object_get_bat (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bat");
  if (ret == NULL)
    return NULL;
  return FOO_IGEN_BAT (ret);
}

/**
 * foo_igen_object_get_authorize:
 * @object: A #FooiGenObject.
 *
 * Gets the #FooiGenAuthorize instance for the D-Bus interface <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooiGenAuthorize that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooiGenAuthorize *foo_igen_object_get_authorize (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Authorize");
  if (ret == NULL)
    return NULL;
  return FOO_IGEN_AUTHORIZE (ret);
}

/**
 * foo_igen_object_get_method_threads:
 * @object: A #FooiGenObject.
 *
 * Gets the #FooiGenMethodThreads instance for the D-Bus interface <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooiGenMethodThreads that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooiGenMethodThreads *foo_igen_object_get_method_threads (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.MethodThreads");
  if (ret == NULL)
    return NULL;
  return FOO_IGEN_METHOD_THREADS (ret);
}

/**
 * foo_igen_object_get_inline_docs:
 * @object: A #FooiGenObject.
 *
 * Gets the #FooiGenInlineDocs instance for the D-Bus interface <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooiGenInlineDocs that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooiGenInlineDocs *foo_igen_object_get_inline_docs (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.InlineDocs");
  if (ret == NULL)
    return NULL;
  return FOO_IGEN_INLINE_DOCS (ret);
}

/**
 * foo_igen_object_get_changing_interface_v1:
 * @object: A #FooiGenObject.
 *
 * Gets the #FooiGenChangingInterfaceV1 instance for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV1.top_of_page">ChangingInterfaceV1</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooiGenChangingInterfaceV1 that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooiGenChangingInterfaceV1 *foo_igen_object_get_changing_interface_v1 (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV1");
  if (ret == NULL)
    return NULL;
  return FOO_IGEN_CHANGING_INTERFACE_V1 (ret);
}

/**
 * foo_igen_object_get_changing_interface_v2:
 * @object: A #FooiGenObject.
 *
 * Gets the #FooiGenChangingInterfaceV2 instance for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV2.top_of_page">ChangingInterfaceV2</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooiGenChangingInterfaceV2 that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooiGenChangingInterfaceV2 *foo_igen_object_get_changing_interface_v2 (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV2");
  if (ret == NULL)
    return NULL;
  return FOO_IGEN_CHANGING_INTERFACE_V2 (ret);
}

/**
 * foo_igen_object_get_changing_interface_v10:
 * @object: A #FooiGenObject.
 *
 * Gets the #FooiGenChangingInterfaceV10 instance for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV10.top_of_page">ChangingInterfaceV10</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooiGenChangingInterfaceV10 that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooiGenChangingInterfaceV10 *foo_igen_object_get_changing_interface_v10 (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV10");
  if (ret == NULL)
    return NULL;
  return FOO_IGEN_CHANGING_INTERFACE_V10 (ret);
}

/**
 * foo_igen_object_get_test_ugly_case_interface:
 * @object: A #FooiGenObject.
 *
 * Gets the #FooiGenTesTuglyCASEInterface instance for the D-Bus interface <link linkend="gdbus-interface-TestUglyCaseInterface.top_of_page">TestUglyCaseInterface</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooiGenTesTuglyCASEInterface that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooiGenTesTuglyCASEInterface *foo_igen_object_get_test_ugly_case_interface (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "TestUglyCaseInterface");
  if (ret == NULL)
    return NULL;
  return FOO_IGEN_TEST_UGLY_CASE_INTERFACE (ret);
}

/**
 * foo_igen_object_get_oldie_interface:
 * @object: A #FooiGenObject.
 *
 * Gets the #FooiGenOldieInterface instance for the D-Bus interface <link linkend="gdbus-interface-OldieInterface.top_of_page">OldieInterface</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooiGenOldieInterface that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
FooiGenOldieInterface *foo_igen_object_get_oldie_interface (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "OldieInterface");
  if (ret == NULL)
    return NULL;
  return FOO_IGEN_OLDIE_INTERFACE (ret);
}

/**
 * foo_igen_object_get_unknown_xml_tags:
 * @object: A #FooiGenObject.
 *
 * Gets the #FooiGenUnknownXmlTags instance for the D-Bus interface <link linkend="gdbus-interface-UnknownXmlTags.top_of_page">UnknownXmlTags</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooiGenUnknownXmlTags that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooiGenUnknownXmlTags *foo_igen_object_get_unknown_xml_tags (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "UnknownXmlTags");
  if (ret == NULL)
    return NULL;
  return FOO_IGEN_UNKNOWN_XML_TAGS (ret);
}

/**
 * foo_igen_object_get_fdpassing:
 * @object: A #FooiGenObject.
 *
 * Gets the #FooiGenFDPassing instance for the D-Bus interface <link linkend="gdbus-interface-FDPassing.top_of_page">FDPassing</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooiGenFDPassing that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooiGenFDPassing *foo_igen_object_get_fdpassing (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "FDPassing");
  if (ret == NULL)
    return NULL;
  return FOO_IGEN_FDPASSING (ret);
}

/**
 * foo_igen_object_get_naming:
 * @object: A #FooiGenObject.
 *
 * Gets the #FooiGenNaming instance for the D-Bus interface <link linkend="gdbus-interface-Naming.top_of_page">Naming</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooiGenNaming that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooiGenNaming *foo_igen_object_get_naming (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "Naming");
  if (ret == NULL)
    return NULL;
  return FOO_IGEN_NAMING (ret);
}


/**
 * foo_igen_object_peek_bar: (skip)
 * @object: A #FooiGenObject.
 *
 * Like foo_igen_object_get_bar() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooiGenBar or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooiGenBar *foo_igen_object_peek_bar (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bar");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_IGEN_BAR (ret);
}

/**
 * foo_igen_object_peek_bar_frobnicator: (skip)
 * @object: A #FooiGenObject.
 *
 * Like foo_igen_object_get_bar_frobnicator() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooiGenBarFrobnicator or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooiGenBarFrobnicator *foo_igen_object_peek_bar_frobnicator (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bar.Frobnicator");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_IGEN_BAR_FROBNICATOR (ret);
}

/**
 * foo_igen_object_peek_baz: (skip)
 * @object: A #FooiGenObject.
 *
 * Like foo_igen_object_get_baz() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooiGenBaz or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooiGenBaz *foo_igen_object_peek_baz (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Baz");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_IGEN_BAZ (ret);
}

/**
 * foo_igen_object_peek_com_acme_coyote: (skip)
 * @object: A #FooiGenObject.
 *
 * Like foo_igen_object_get_com_acme_coyote() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooiGenComAcmeCoyote or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooiGenComAcmeCoyote *foo_igen_object_peek_com_acme_coyote (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "com.acme.Coyote");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_IGEN_COM_ACME_COYOTE (ret);
}

/**
 * foo_igen_object_peek_rocket123: (skip)
 * @object: A #FooiGenObject.
 *
 * Like foo_igen_object_get_rocket123() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooiGenRocket123 or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooiGenRocket123 *foo_igen_object_peek_rocket123 (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "com.acme.Rocket");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_IGEN_ROCKET123 (ret);
}

/**
 * foo_igen_object_peek_bat: (skip)
 * @object: A #FooiGenObject.
 *
 * Like foo_igen_object_get_bat() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooiGenBat or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooiGenBat *foo_igen_object_peek_bat (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bat");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_IGEN_BAT (ret);
}

/**
 * foo_igen_object_peek_authorize: (skip)
 * @object: A #FooiGenObject.
 *
 * Like foo_igen_object_get_authorize() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooiGenAuthorize or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooiGenAuthorize *foo_igen_object_peek_authorize (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Authorize");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_IGEN_AUTHORIZE (ret);
}

/**
 * foo_igen_object_peek_method_threads: (skip)
 * @object: A #FooiGenObject.
 *
 * Like foo_igen_object_get_method_threads() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooiGenMethodThreads or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooiGenMethodThreads *foo_igen_object_peek_method_threads (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.MethodThreads");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_IGEN_METHOD_THREADS (ret);
}

/**
 * foo_igen_object_peek_inline_docs: (skip)
 * @object: A #FooiGenObject.
 *
 * Like foo_igen_object_get_inline_docs() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooiGenInlineDocs or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooiGenInlineDocs *foo_igen_object_peek_inline_docs (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.InlineDocs");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_IGEN_INLINE_DOCS (ret);
}

/**
 * foo_igen_object_peek_changing_interface_v1: (skip)
 * @object: A #FooiGenObject.
 *
 * Like foo_igen_object_get_changing_interface_v1() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooiGenChangingInterfaceV1 or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooiGenChangingInterfaceV1 *foo_igen_object_peek_changing_interface_v1 (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV1");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_IGEN_CHANGING_INTERFACE_V1 (ret);
}

/**
 * foo_igen_object_peek_changing_interface_v2: (skip)
 * @object: A #FooiGenObject.
 *
 * Like foo_igen_object_get_changing_interface_v2() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooiGenChangingInterfaceV2 or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooiGenChangingInterfaceV2 *foo_igen_object_peek_changing_interface_v2 (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV2");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_IGEN_CHANGING_INTERFACE_V2 (ret);
}

/**
 * foo_igen_object_peek_changing_interface_v10: (skip)
 * @object: A #FooiGenObject.
 *
 * Like foo_igen_object_get_changing_interface_v10() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooiGenChangingInterfaceV10 or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooiGenChangingInterfaceV10 *foo_igen_object_peek_changing_interface_v10 (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV10");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_IGEN_CHANGING_INTERFACE_V10 (ret);
}

/**
 * foo_igen_object_peek_test_ugly_case_interface: (skip)
 * @object: A #FooiGenObject.
 *
 * Like foo_igen_object_get_test_ugly_case_interface() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooiGenTesTuglyCASEInterface or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooiGenTesTuglyCASEInterface *foo_igen_object_peek_test_ugly_case_interface (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "TestUglyCaseInterface");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_IGEN_TEST_UGLY_CASE_INTERFACE (ret);
}

/**
 * foo_igen_object_peek_oldie_interface: (skip)
 * @object: A #FooiGenObject.
 *
 * Like foo_igen_object_get_oldie_interface() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooiGenOldieInterface or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
FooiGenOldieInterface *foo_igen_object_peek_oldie_interface (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "OldieInterface");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_IGEN_OLDIE_INTERFACE (ret);
}

/**
 * foo_igen_object_peek_unknown_xml_tags: (skip)
 * @object: A #FooiGenObject.
 *
 * Like foo_igen_object_get_unknown_xml_tags() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooiGenUnknownXmlTags or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooiGenUnknownXmlTags *foo_igen_object_peek_unknown_xml_tags (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "UnknownXmlTags");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_IGEN_UNKNOWN_XML_TAGS (ret);
}

/**
 * foo_igen_object_peek_fdpassing: (skip)
 * @object: A #FooiGenObject.
 *
 * Like foo_igen_object_get_fdpassing() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooiGenFDPassing or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooiGenFDPassing *foo_igen_object_peek_fdpassing (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "FDPassing");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_IGEN_FDPASSING (ret);
}

/**
 * foo_igen_object_peek_naming: (skip)
 * @object: A #FooiGenObject.
 *
 * Like foo_igen_object_get_naming() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooiGenNaming or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooiGenNaming *foo_igen_object_peek_naming (FooiGenObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "Naming");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_IGEN_NAMING (ret);
}


static void
foo_igen_object_notify (GDBusObject *object, GDBusInterface *interface)
{
  _ExtendedGDBusInterfaceInfo *info = (_ExtendedGDBusInterfaceInfo *) g_dbus_interface_get_info (interface);
  /* info can be NULL if the other end is using a D-Bus interface we don't know
   * anything about, for example old generated code in this process talking to
   * newer generated code in the other process. */
  if (info != NULL)
    g_object_notify (G_OBJECT (object), info->hyphen_name);
}

/**
 * FooiGenObjectProxy:
 *
 * The #FooiGenObjectProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenObjectProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenObjectProxy.
 */

static void
foo_igen_object_proxy__foo_igen_object_iface_init (FooiGenObjectIface *iface G_GNUC_UNUSED)
{
}

static void
foo_igen_object_proxy__g_dbus_object_iface_init (GDBusObjectIface *iface)
{
  iface->interface_added = foo_igen_object_notify;
  iface->interface_removed = foo_igen_object_notify;
}


G_DEFINE_TYPE_WITH_CODE (FooiGenObjectProxy, foo_igen_object_proxy, G_TYPE_DBUS_OBJECT_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_OBJECT, foo_igen_object_proxy__foo_igen_object_iface_init)
                         G_IMPLEMENT_INTERFACE (G_TYPE_DBUS_OBJECT, foo_igen_object_proxy__g_dbus_object_iface_init));

static void
foo_igen_object_proxy_init (FooiGenObjectProxy *object G_GNUC_UNUSED)
{
}

static void
foo_igen_object_proxy_set_property (GObject      *gobject,
  guint         prop_id,
  const GValue *value G_GNUC_UNUSED,
  GParamSpec   *pspec)
{
  G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
}

static void
foo_igen_object_proxy_get_property (GObject      *gobject,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  FooiGenObjectProxy *object = FOO_IGEN_OBJECT_PROXY (gobject);
  GDBusInterface *interface;

  switch (prop_id)
    {
    case 1:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bar");
      g_value_take_object (value, interface);
      break;

    case 2:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bar.Frobnicator");
      g_value_take_object (value, interface);
      break;

    case 3:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Baz");
      g_value_take_object (value, interface);
      break;

    case 4:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "com.acme.Coyote");
      g_value_take_object (value, interface);
      break;

    case 5:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "com.acme.Rocket");
      g_value_take_object (value, interface);
      break;

    case 6:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bat");
      g_value_take_object (value, interface);
      break;

    case 7:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Authorize");
      g_value_take_object (value, interface);
      break;

    case 8:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.MethodThreads");
      g_value_take_object (value, interface);
      break;

    case 9:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.InlineDocs");
      g_value_take_object (value, interface);
      break;

    case 10:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV1");
      g_value_take_object (value, interface);
      break;

    case 11:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV2");
      g_value_take_object (value, interface);
      break;

    case 12:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV10");
      g_value_take_object (value, interface);
      break;

    case 13:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "TestUglyCaseInterface");
      g_value_take_object (value, interface);
      break;

    case 14:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "OldieInterface");
      g_value_take_object (value, interface);
      break;

    case 15:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "UnknownXmlTags");
      g_value_take_object (value, interface);
      break;

    case 16:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "FDPassing");
      g_value_take_object (value, interface);
      break;

    case 17:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "Naming");
      g_value_take_object (value, interface);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
      break;
  }
}

static void
foo_igen_object_proxy_class_init (FooiGenObjectProxyClass *klass)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);

  gobject_class->set_property = foo_igen_object_proxy_set_property;
  gobject_class->get_property = foo_igen_object_proxy_get_property;

  g_object_class_override_property (gobject_class, 1, "bar");
  g_object_class_override_property (gobject_class, 2, "bar-frobnicator");
  g_object_class_override_property (gobject_class, 3, "baz");
  g_object_class_override_property (gobject_class, 4, "com-acme-coyote");
  g_object_class_override_property (gobject_class, 5, "rocket123");
  g_object_class_override_property (gobject_class, 6, "bat");
  g_object_class_override_property (gobject_class, 7, "authorize");
  g_object_class_override_property (gobject_class, 8, "method-threads");
  g_object_class_override_property (gobject_class, 9, "inline-docs");
  g_object_class_override_property (gobject_class, 10, "changing-interface-v1");
  g_object_class_override_property (gobject_class, 11, "changing-interface-v2");
  g_object_class_override_property (gobject_class, 12, "changing-interface-v10");
  g_object_class_override_property (gobject_class, 13, "test-ugly-case-interface");
  g_object_class_override_property (gobject_class, 14, "oldie-interface");
  g_object_class_override_property (gobject_class, 15, "unknown-xml-tags");
  g_object_class_override_property (gobject_class, 16, "fdpassing");
  g_object_class_override_property (gobject_class, 17, "naming");
}

/**
 * foo_igen_object_proxy_new:
 * @connection: A #GDBusConnection.
 * @object_path: An object path.
 *
 * Creates a new proxy object.
 *
 * Returns: (transfer full): The proxy object.
 */
FooiGenObjectProxy *
foo_igen_object_proxy_new (GDBusConnection *connection,
  const gchar *object_path)
{
  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);
  g_return_val_if_fail (g_variant_is_object_path (object_path), NULL);
  return FOO_IGEN_OBJECT_PROXY (g_object_new (FOO_IGEN_TYPE_OBJECT_PROXY, "g-connection", connection, "g-object-path", object_path, NULL));
}

/**
 * FooiGenObjectSkeleton:
 *
 * The #FooiGenObjectSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenObjectSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenObjectSkeleton.
 */

static void
foo_igen_object_skeleton__foo_igen_object_iface_init (FooiGenObjectIface *iface G_GNUC_UNUSED)
{
}


static void
foo_igen_object_skeleton__g_dbus_object_iface_init (GDBusObjectIface *iface)
{
  iface->interface_added = foo_igen_object_notify;
  iface->interface_removed = foo_igen_object_notify;
}

G_DEFINE_TYPE_WITH_CODE (FooiGenObjectSkeleton, foo_igen_object_skeleton, G_TYPE_DBUS_OBJECT_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_IGEN_TYPE_OBJECT, foo_igen_object_skeleton__foo_igen_object_iface_init)
                         G_IMPLEMENT_INTERFACE (G_TYPE_DBUS_OBJECT, foo_igen_object_skeleton__g_dbus_object_iface_init));

static void
foo_igen_object_skeleton_init (FooiGenObjectSkeleton *object G_GNUC_UNUSED)
{
}

static void
foo_igen_object_skeleton_set_property (GObject      *gobject,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooiGenObjectSkeleton *object = FOO_IGEN_OBJECT_SKELETON (gobject);
  GDBusInterfaceSkeleton *interface;

  switch (prop_id)
    {
    case 1:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IGEN_IS_BAR (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.project.Bar");
        }
      break;

    case 2:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IGEN_IS_BAR_FROBNICATOR (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.project.Bar.Frobnicator");
        }
      break;

    case 3:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IGEN_IS_BAZ (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.project.Baz");
        }
      break;

    case 4:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IGEN_IS_COM_ACME_COYOTE (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "com.acme.Coyote");
        }
      break;

    case 5:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IGEN_IS_ROCKET123 (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "com.acme.Rocket");
        }
      break;

    case 6:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IGEN_IS_BAT (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.project.Bat");
        }
      break;

    case 7:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IGEN_IS_AUTHORIZE (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.project.Authorize");
        }
      break;

    case 8:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IGEN_IS_METHOD_THREADS (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.project.MethodThreads");
        }
      break;

    case 9:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IGEN_IS_INLINE_DOCS (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.project.InlineDocs");
        }
      break;

    case 10:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IGEN_IS_CHANGING_INTERFACE_V1 (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "ChangingInterfaceV1");
        }
      break;

    case 11:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IGEN_IS_CHANGING_INTERFACE_V2 (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "ChangingInterfaceV2");
        }
      break;

    case 12:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IGEN_IS_CHANGING_INTERFACE_V10 (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "ChangingInterfaceV10");
        }
      break;

    case 13:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IGEN_IS_TEST_UGLY_CASE_INTERFACE (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "TestUglyCaseInterface");
        }
      break;

    case 14:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IGEN_IS_OLDIE_INTERFACE (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "OldieInterface");
        }
      break;

    case 15:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IGEN_IS_UNKNOWN_XML_TAGS (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "UnknownXmlTags");
        }
      break;

    case 16:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IGEN_IS_FDPASSING (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "FDPassing");
        }
      break;

    case 17:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IGEN_IS_NAMING (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "Naming");
        }
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
      break;
  }
}

static void
foo_igen_object_skeleton_get_property (GObject      *gobject,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  FooiGenObjectSkeleton *object = FOO_IGEN_OBJECT_SKELETON (gobject);
  GDBusInterface *interface;

  switch (prop_id)
    {
    case 1:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bar");
      g_value_take_object (value, interface);
      break;

    case 2:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bar.Frobnicator");
      g_value_take_object (value, interface);
      break;

    case 3:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Baz");
      g_value_take_object (value, interface);
      break;

    case 4:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "com.acme.Coyote");
      g_value_take_object (value, interface);
      break;

    case 5:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "com.acme.Rocket");
      g_value_take_object (value, interface);
      break;

    case 6:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bat");
      g_value_take_object (value, interface);
      break;

    case 7:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Authorize");
      g_value_take_object (value, interface);
      break;

    case 8:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.MethodThreads");
      g_value_take_object (value, interface);
      break;

    case 9:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.InlineDocs");
      g_value_take_object (value, interface);
      break;

    case 10:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV1");
      g_value_take_object (value, interface);
      break;

    case 11:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV2");
      g_value_take_object (value, interface);
      break;

    case 12:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV10");
      g_value_take_object (value, interface);
      break;

    case 13:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "TestUglyCaseInterface");
      g_value_take_object (value, interface);
      break;

    case 14:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "OldieInterface");
      g_value_take_object (value, interface);
      break;

    case 15:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "UnknownXmlTags");
      g_value_take_object (value, interface);
      break;

    case 16:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "FDPassing");
      g_value_take_object (value, interface);
      break;

    case 17:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "Naming");
      g_value_take_object (value, interface);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
      break;
  }
}

static void
foo_igen_object_skeleton_class_init (FooiGenObjectSkeletonClass *klass)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);

  gobject_class->set_property = foo_igen_object_skeleton_set_property;
  gobject_class->get_property = foo_igen_object_skeleton_get_property;

  g_object_class_override_property (gobject_class, 1, "bar");
  g_object_class_override_property (gobject_class, 2, "bar-frobnicator");
  g_object_class_override_property (gobject_class, 3, "baz");
  g_object_class_override_property (gobject_class, 4, "com-acme-coyote");
  g_object_class_override_property (gobject_class, 5, "rocket123");
  g_object_class_override_property (gobject_class, 6, "bat");
  g_object_class_override_property (gobject_class, 7, "authorize");
  g_object_class_override_property (gobject_class, 8, "method-threads");
  g_object_class_override_property (gobject_class, 9, "inline-docs");
  g_object_class_override_property (gobject_class, 10, "changing-interface-v1");
  g_object_class_override_property (gobject_class, 11, "changing-interface-v2");
  g_object_class_override_property (gobject_class, 12, "changing-interface-v10");
  g_object_class_override_property (gobject_class, 13, "test-ugly-case-interface");
  g_object_class_override_property (gobject_class, 14, "oldie-interface");
  g_object_class_override_property (gobject_class, 15, "unknown-xml-tags");
  g_object_class_override_property (gobject_class, 16, "fdpassing");
  g_object_class_override_property (gobject_class, 17, "naming");
}

/**
 * foo_igen_object_skeleton_new:
 * @object_path: An object path.
 *
 * Creates a new skeleton object.
 *
 * Returns: (transfer full): The skeleton object.
 */
FooiGenObjectSkeleton *
foo_igen_object_skeleton_new (const gchar *object_path)
{
  g_return_val_if_fail (g_variant_is_object_path (object_path), NULL);
  return FOO_IGEN_OBJECT_SKELETON (g_object_new (FOO_IGEN_TYPE_OBJECT_SKELETON, "g-object-path", object_path, NULL));
}

/**
 * foo_igen_object_skeleton_set_bar:
 * @object: A #FooiGenObjectSkeleton.
 * @interface_: (allow-none): A #FooiGenBar or %NULL to clear the interface.
 *
 * Sets the #FooiGenBar instance for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link> on @object.
 */
void foo_igen_object_skeleton_set_bar (FooiGenObjectSkeleton *object, FooiGenBar *interface_)
{
  g_object_set (G_OBJECT (object), "bar", interface_, NULL);
}

/**
 * foo_igen_object_skeleton_set_bar_frobnicator:
 * @object: A #FooiGenObjectSkeleton.
 * @interface_: (allow-none): A #FooiGenBarFrobnicator or %NULL to clear the interface.
 *
 * Sets the #FooiGenBarFrobnicator instance for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link> on @object.
 */
void foo_igen_object_skeleton_set_bar_frobnicator (FooiGenObjectSkeleton *object, FooiGenBarFrobnicator *interface_)
{
  g_object_set (G_OBJECT (object), "bar-frobnicator", interface_, NULL);
}

/**
 * foo_igen_object_skeleton_set_baz:
 * @object: A #FooiGenObjectSkeleton.
 * @interface_: (allow-none): A #FooiGenBaz or %NULL to clear the interface.
 *
 * Sets the #FooiGenBaz instance for the D-Bus interface <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link> on @object.
 */
void foo_igen_object_skeleton_set_baz (FooiGenObjectSkeleton *object, FooiGenBaz *interface_)
{
  g_object_set (G_OBJECT (object), "baz", interface_, NULL);
}

/**
 * foo_igen_object_skeleton_set_com_acme_coyote:
 * @object: A #FooiGenObjectSkeleton.
 * @interface_: (allow-none): A #FooiGenComAcmeCoyote or %NULL to clear the interface.
 *
 * Sets the #FooiGenComAcmeCoyote instance for the D-Bus interface <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link> on @object.
 */
void foo_igen_object_skeleton_set_com_acme_coyote (FooiGenObjectSkeleton *object, FooiGenComAcmeCoyote *interface_)
{
  g_object_set (G_OBJECT (object), "com-acme-coyote", interface_, NULL);
}

/**
 * foo_igen_object_skeleton_set_rocket123:
 * @object: A #FooiGenObjectSkeleton.
 * @interface_: (allow-none): A #FooiGenRocket123 or %NULL to clear the interface.
 *
 * Sets the #FooiGenRocket123 instance for the D-Bus interface <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link> on @object.
 */
void foo_igen_object_skeleton_set_rocket123 (FooiGenObjectSkeleton *object, FooiGenRocket123 *interface_)
{
  g_object_set (G_OBJECT (object), "rocket123", interface_, NULL);
}

/**
 * foo_igen_object_skeleton_set_bat:
 * @object: A #FooiGenObjectSkeleton.
 * @interface_: (allow-none): A #FooiGenBat or %NULL to clear the interface.
 *
 * Sets the #FooiGenBat instance for the D-Bus interface <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link> on @object.
 */
void foo_igen_object_skeleton_set_bat (FooiGenObjectSkeleton *object, FooiGenBat *interface_)
{
  g_object_set (G_OBJECT (object), "bat", interface_, NULL);
}

/**
 * foo_igen_object_skeleton_set_authorize:
 * @object: A #FooiGenObjectSkeleton.
 * @interface_: (allow-none): A #FooiGenAuthorize or %NULL to clear the interface.
 *
 * Sets the #FooiGenAuthorize instance for the D-Bus interface <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link> on @object.
 */
void foo_igen_object_skeleton_set_authorize (FooiGenObjectSkeleton *object, FooiGenAuthorize *interface_)
{
  g_object_set (G_OBJECT (object), "authorize", interface_, NULL);
}

/**
 * foo_igen_object_skeleton_set_method_threads:
 * @object: A #FooiGenObjectSkeleton.
 * @interface_: (allow-none): A #FooiGenMethodThreads or %NULL to clear the interface.
 *
 * Sets the #FooiGenMethodThreads instance for the D-Bus interface <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link> on @object.
 */
void foo_igen_object_skeleton_set_method_threads (FooiGenObjectSkeleton *object, FooiGenMethodThreads *interface_)
{
  g_object_set (G_OBJECT (object), "method-threads", interface_, NULL);
}

/**
 * foo_igen_object_skeleton_set_inline_docs:
 * @object: A #FooiGenObjectSkeleton.
 * @interface_: (allow-none): A #FooiGenInlineDocs or %NULL to clear the interface.
 *
 * Sets the #FooiGenInlineDocs instance for the D-Bus interface <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link> on @object.
 */
void foo_igen_object_skeleton_set_inline_docs (FooiGenObjectSkeleton *object, FooiGenInlineDocs *interface_)
{
  g_object_set (G_OBJECT (object), "inline-docs", interface_, NULL);
}

/**
 * foo_igen_object_skeleton_set_changing_interface_v1:
 * @object: A #FooiGenObjectSkeleton.
 * @interface_: (allow-none): A #FooiGenChangingInterfaceV1 or %NULL to clear the interface.
 *
 * Sets the #FooiGenChangingInterfaceV1 instance for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV1.top_of_page">ChangingInterfaceV1</link> on @object.
 */
void foo_igen_object_skeleton_set_changing_interface_v1 (FooiGenObjectSkeleton *object, FooiGenChangingInterfaceV1 *interface_)
{
  g_object_set (G_OBJECT (object), "changing-interface-v1", interface_, NULL);
}

/**
 * foo_igen_object_skeleton_set_changing_interface_v2:
 * @object: A #FooiGenObjectSkeleton.
 * @interface_: (allow-none): A #FooiGenChangingInterfaceV2 or %NULL to clear the interface.
 *
 * Sets the #FooiGenChangingInterfaceV2 instance for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV2.top_of_page">ChangingInterfaceV2</link> on @object.
 */
void foo_igen_object_skeleton_set_changing_interface_v2 (FooiGenObjectSkeleton *object, FooiGenChangingInterfaceV2 *interface_)
{
  g_object_set (G_OBJECT (object), "changing-interface-v2", interface_, NULL);
}

/**
 * foo_igen_object_skeleton_set_changing_interface_v10:
 * @object: A #FooiGenObjectSkeleton.
 * @interface_: (allow-none): A #FooiGenChangingInterfaceV10 or %NULL to clear the interface.
 *
 * Sets the #FooiGenChangingInterfaceV10 instance for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV10.top_of_page">ChangingInterfaceV10</link> on @object.
 */
void foo_igen_object_skeleton_set_changing_interface_v10 (FooiGenObjectSkeleton *object, FooiGenChangingInterfaceV10 *interface_)
{
  g_object_set (G_OBJECT (object), "changing-interface-v10", interface_, NULL);
}

/**
 * foo_igen_object_skeleton_set_test_ugly_case_interface:
 * @object: A #FooiGenObjectSkeleton.
 * @interface_: (allow-none): A #FooiGenTesTuglyCASEInterface or %NULL to clear the interface.
 *
 * Sets the #FooiGenTesTuglyCASEInterface instance for the D-Bus interface <link linkend="gdbus-interface-TestUglyCaseInterface.top_of_page">TestUglyCaseInterface</link> on @object.
 */
void foo_igen_object_skeleton_set_test_ugly_case_interface (FooiGenObjectSkeleton *object, FooiGenTesTuglyCASEInterface *interface_)
{
  g_object_set (G_OBJECT (object), "test-ugly-case-interface", interface_, NULL);
}

/**
 * foo_igen_object_skeleton_set_oldie_interface:
 * @object: A #FooiGenObjectSkeleton.
 * @interface_: (allow-none): A #FooiGenOldieInterface or %NULL to clear the interface.
 *
 * Sets the #FooiGenOldieInterface instance for the D-Bus interface <link linkend="gdbus-interface-OldieInterface.top_of_page">OldieInterface</link> on @object.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
void foo_igen_object_skeleton_set_oldie_interface (FooiGenObjectSkeleton *object, FooiGenOldieInterface *interface_)
{
  g_object_set (G_OBJECT (object), "oldie-interface", interface_, NULL);
}

/**
 * foo_igen_object_skeleton_set_unknown_xml_tags:
 * @object: A #FooiGenObjectSkeleton.
 * @interface_: (allow-none): A #FooiGenUnknownXmlTags or %NULL to clear the interface.
 *
 * Sets the #FooiGenUnknownXmlTags instance for the D-Bus interface <link linkend="gdbus-interface-UnknownXmlTags.top_of_page">UnknownXmlTags</link> on @object.
 */
void foo_igen_object_skeleton_set_unknown_xml_tags (FooiGenObjectSkeleton *object, FooiGenUnknownXmlTags *interface_)
{
  g_object_set (G_OBJECT (object), "unknown-xml-tags", interface_, NULL);
}

/**
 * foo_igen_object_skeleton_set_fdpassing:
 * @object: A #FooiGenObjectSkeleton.
 * @interface_: (allow-none): A #FooiGenFDPassing or %NULL to clear the interface.
 *
 * Sets the #FooiGenFDPassing instance for the D-Bus interface <link linkend="gdbus-interface-FDPassing.top_of_page">FDPassing</link> on @object.
 */
void foo_igen_object_skeleton_set_fdpassing (FooiGenObjectSkeleton *object, FooiGenFDPassing *interface_)
{
  g_object_set (G_OBJECT (object), "fdpassing", interface_, NULL);
}

/**
 * foo_igen_object_skeleton_set_naming:
 * @object: A #FooiGenObjectSkeleton.
 * @interface_: (allow-none): A #FooiGenNaming or %NULL to clear the interface.
 *
 * Sets the #FooiGenNaming instance for the D-Bus interface <link linkend="gdbus-interface-Naming.top_of_page">Naming</link> on @object.
 */
void foo_igen_object_skeleton_set_naming (FooiGenObjectSkeleton *object, FooiGenNaming *interface_)
{
  g_object_set (G_OBJECT (object), "naming", interface_, NULL);
}


/* ------------------------------------------------------------------------
 * Code for ObjectManager client
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooiGenObjectManagerClient
 * @title: FooiGenObjectManagerClient
 * @short_description: Generated GDBusObjectManagerClient type
 *
 * This section contains a #GDBusObjectManagerClient that uses foo_igen_object_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc.
 */

/**
 * FooiGenObjectManagerClient:
 *
 * The #FooiGenObjectManagerClient structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooiGenObjectManagerClientClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooiGenObjectManagerClient.
 */

G_DEFINE_TYPE (FooiGenObjectManagerClient, foo_igen_object_manager_client, G_TYPE_DBUS_OBJECT_MANAGER_CLIENT);

static void
foo_igen_object_manager_client_init (FooiGenObjectManagerClient *manager G_GNUC_UNUSED)
{
}

static void
foo_igen_object_manager_client_class_init (FooiGenObjectManagerClientClass *klass G_GNUC_UNUSED)
{
}

/**
 * foo_igen_object_manager_client_get_proxy_type:
 * @manager: A #GDBusObjectManagerClient.
 * @object_path: The object path of the remote object (unused).
 * @interface_name: (allow-none): Interface name of the remote object or %NULL to get the object proxy #GType.
 * @user_data: User data (unused).
 *
 * A #GDBusProxyTypeFunc that maps @interface_name to the generated #GDBusObjectProxy<!-- -->- and #GDBusProxy<!-- -->-derived types.
 *
 * Returns: A #GDBusProxy<!-- -->-derived #GType if @interface_name is not %NULL, otherwise the #GType for #FooiGenObjectProxy.
 */
GType
foo_igen_object_manager_client_get_proxy_type (GDBusObjectManagerClient *manager G_GNUC_UNUSED, const gchar *object_path G_GNUC_UNUSED, const gchar *interface_name, gpointer user_data G_GNUC_UNUSED)
{
  static gsize once_init_value = 0;
  static GHashTable *lookup_hash;
  GType ret;

  if (interface_name == NULL)
    return FOO_IGEN_TYPE_OBJECT_PROXY;
  if (g_once_init_enter (&once_init_value))
    {
      lookup_hash = g_hash_table_new (g_str_hash, g_str_equal);
      g_hash_table_insert (lookup_hash, (gpointer) "org.project.Bar", GSIZE_TO_POINTER (FOO_IGEN_TYPE_BAR_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.project.Bar.Frobnicator", GSIZE_TO_POINTER (FOO_IGEN_TYPE_BAR_FROBNICATOR_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.project.Baz", GSIZE_TO_POINTER (FOO_IGEN_TYPE_BAZ_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "com.acme.Coyote", GSIZE_TO_POINTER (FOO_IGEN_TYPE_COM_ACME_COYOTE_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "com.acme.Rocket", GSIZE_TO_POINTER (FOO_IGEN_TYPE_ROCKET123_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.project.Bat", GSIZE_TO_POINTER (FOO_IGEN_TYPE_BAT_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.project.Authorize", GSIZE_TO_POINTER (FOO_IGEN_TYPE_AUTHORIZE_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.project.MethodThreads", GSIZE_TO_POINTER (FOO_IGEN_TYPE_METHOD_THREADS_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.project.InlineDocs", GSIZE_TO_POINTER (FOO_IGEN_TYPE_INLINE_DOCS_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "ChangingInterfaceV1", GSIZE_TO_POINTER (FOO_IGEN_TYPE_CHANGING_INTERFACE_V1_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "ChangingInterfaceV2", GSIZE_TO_POINTER (FOO_IGEN_TYPE_CHANGING_INTERFACE_V2_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "ChangingInterfaceV10", GSIZE_TO_POINTER (FOO_IGEN_TYPE_CHANGING_INTERFACE_V10_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "TestUglyCaseInterface", GSIZE_TO_POINTER (FOO_IGEN_TYPE_TEST_UGLY_CASE_INTERFACE_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "OldieInterface", GSIZE_TO_POINTER (FOO_IGEN_TYPE_OLDIE_INTERFACE_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "UnknownXmlTags", GSIZE_TO_POINTER (FOO_IGEN_TYPE_UNKNOWN_XML_TAGS_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "FDPassing", GSIZE_TO_POINTER (FOO_IGEN_TYPE_FDPASSING_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "Naming", GSIZE_TO_POINTER (FOO_IGEN_TYPE_NAMING_PROXY));
      g_once_init_leave (&once_init_value, 1);
    }
  ret = (GType) GPOINTER_TO_SIZE (g_hash_table_lookup (lookup_hash, interface_name));
  if (ret == (GType) 0)
    ret = G_TYPE_DBUS_PROXY;
  return ret;
}

/**
 * foo_igen_object_manager_client_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates #GDBusObjectManagerClient using foo_igen_object_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc. See g_dbus_object_manager_client_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_object_manager_client_new_finish() to get the result of the operation.
 *
 * See foo_igen_object_manager_client_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_object_manager_client_new (
    GDBusConnection        *connection,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GAsyncReadyCallback     callback,
    gpointer                user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_OBJECT_MANAGER_CLIENT, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "flags", flags, "name", name, "connection", connection, "object-path", object_path, "get-proxy-type-func", foo_igen_object_manager_client_get_proxy_type, NULL);
}

/**
 * foo_igen_object_manager_client_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_object_manager_client_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_object_manager_client_new().
 *
 * Returns: (transfer full) (type FooiGenObjectManagerClient): The constructed object manager client or %NULL if @error is set.
 */
GDBusObjectManager *
foo_igen_object_manager_client_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return G_DBUS_OBJECT_MANAGER (ret);
  else
    return NULL;
}

/**
 * foo_igen_object_manager_client_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates #GDBusObjectManagerClient using foo_igen_object_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc. See g_dbus_object_manager_client_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_object_manager_client_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenObjectManagerClient): The constructed object manager client or %NULL if @error is set.
 */
GDBusObjectManager *
foo_igen_object_manager_client_new_sync (
    GDBusConnection        *connection,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GError                **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_OBJECT_MANAGER_CLIENT, cancellable, error, "flags", flags, "name", name, "connection", connection, "object-path", object_path, "get-proxy-type-func", foo_igen_object_manager_client_get_proxy_type, NULL);
  if (ret != NULL)
    return G_DBUS_OBJECT_MANAGER (ret);
  else
    return NULL;
}


/**
 * foo_igen_object_manager_client_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_igen_object_manager_client_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_igen_object_manager_client_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_igen_object_manager_client_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_igen_object_manager_client_new_for_bus (
    GBusType                bus_type,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GAsyncReadyCallback     callback,
    gpointer                user_data)
{
  g_async_initable_new_async (FOO_IGEN_TYPE_OBJECT_MANAGER_CLIENT, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "flags", flags, "name", name, "bus-type", bus_type, "object-path", object_path, "get-proxy-type-func", foo_igen_object_manager_client_get_proxy_type, NULL);
}

/**
 * foo_igen_object_manager_client_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_igen_object_manager_client_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_igen_object_manager_client_new_for_bus().
 *
 * Returns: (transfer full) (type FooiGenObjectManagerClient): The constructed object manager client or %NULL if @error is set.
 */
GDBusObjectManager *
foo_igen_object_manager_client_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return G_DBUS_OBJECT_MANAGER (ret);
  else
    return NULL;
}

/**
 * foo_igen_object_manager_client_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_igen_object_manager_client_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_igen_object_manager_client_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooiGenObjectManagerClient): The constructed object manager client or %NULL if @error is set.
 */
GDBusObjectManager *
foo_igen_object_manager_client_new_for_bus_sync (
    GBusType                bus_type,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GError                **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_IGEN_TYPE_OBJECT_MANAGER_CLIENT, cancellable, error, "flags", flags, "name", name, "bus-type", bus_type, "object-path", object_path, "get-proxy-type-func", foo_igen_object_manager_client_get_proxy_type, NULL);
  if (ret != NULL)
    return G_DBUS_OBJECT_MANAGER (ret);
  else
    return NULL;
}



/*
 *  Warning: Do not edit this file.
 *  Auto-generated by 'beam_makeops'.
 */

OpCase(allocate_heap_tIt):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  do {
    unsigned needed = tb(tmp_packed1&BEAM_WIDE_MASK) + 1;
    do {
      Uint need = Ib((tmp_packed1>>BEAM_WIDE_SHIFT)) + needed;
      if (ERTS_UNLIKELY(E - HTOP < need)) {
        SWAPOUT;
        PROCESS_MAIN_CHK_LOCKS(c_p);
        FCALLS -= erts_garbage_collect_nobump(c_p, need, reg, I[2], FCALLS);
        ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        SWAPIN;
      }
      HEAP_SPACE_VERIFIED(Ib((tmp_packed1>>BEAM_WIDE_SHIFT)));
    } while (0);
    E -= needed;
    *E = make_cp(c_p->cp);
    c_p->cp = 0;
  } while (0);
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(allocate_heap_zero_tIt):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  Eterm* ptr;
  int i = tb(tmp_packed1&BEAM_WIDE_MASK);
  do {
    unsigned needed = i + 1;
    do {
      Uint need = Ib((tmp_packed1>>BEAM_WIDE_SHIFT)) + needed;
      if (ERTS_UNLIKELY(E - HTOP < need)) {
        SWAPOUT;
        PROCESS_MAIN_CHK_LOCKS(c_p);
        FCALLS -= erts_garbage_collect_nobump(c_p, need, reg, I[2], FCALLS);
        ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        SWAPIN;
      }
      HEAP_SPACE_VERIFIED(Ib((tmp_packed1>>BEAM_WIDE_SHIFT)));
    } while (0);
    E -= needed;
    *E = make_cp(c_p->cp);
    c_p->cp = 0;
  } while (0);
  for (ptr = E + i; ptr > E; ptr--) {
    make_blank(*ptr);
  }
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(allocate_init_tty):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  do {
    unsigned needed = tb(tmp_packed1&BEAM_TIGHT_MASK) + 1;
    do {
      Uint need = 0 + needed;
      if (ERTS_UNLIKELY(E - HTOP < need)) {
        SWAPOUT;
        PROCESS_MAIN_CHK_LOCKS(c_p);
        FCALLS -= erts_garbage_collect_nobump(c_p, need, reg, tb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK), FCALLS);
        ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        SWAPIN;
      }
      HEAP_SPACE_VERIFIED(0);
    } while (0);
    E -= needed;
    *E = make_cp(c_p->cp);
    c_p->cp = 0;
  } while (0);
  make_blank(yb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))));
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(allocate_tt):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  do {
    unsigned needed = tb(tmp_packed1&BEAM_LOOSE_MASK) + 1;
    do {
      Uint need = 0 + needed;
      if (ERTS_UNLIKELY(E - HTOP < need)) {
        SWAPOUT;
        PROCESS_MAIN_CHK_LOCKS(c_p);
        FCALLS -= erts_garbage_collect_nobump(c_p, need, reg, tb((tmp_packed1>>BEAM_LOOSE_SHIFT)), FCALLS);
        ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        SWAPIN;
      }
      HEAP_SPACE_VERIFIED(0);
    } while (0);
    E -= needed;
    *E = make_cp(c_p->cp);
    c_p->cp = 0;
  } while (0);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(allocate_zero_tt):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* ptr;
  int i = tb(tmp_packed1&BEAM_LOOSE_MASK);
  do {
    unsigned needed = i + 1;
    do {
      Uint need = 0 + needed;
      if (ERTS_UNLIKELY(E - HTOP < need)) {
        SWAPOUT;
        PROCESS_MAIN_CHK_LOCKS(c_p);
        FCALLS -= erts_garbage_collect_nobump(c_p, need, reg, tb((tmp_packed1>>BEAM_LOOSE_SHIFT)), FCALLS);
        ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        SWAPIN;
      }
      HEAP_SPACE_VERIFIED(0);
    } while (0);
    E -= needed;
    *E = make_cp(c_p->cp);
    c_p->cp = 0;
  } while (0);
  for (ptr = E + i; ptr > E; ptr--) {
    make_blank(*ptr);
  }
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(apply_last_tQ):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr *next;
  HEAVY_SWAPOUT;
  next = fixed_apply(c_p, reg, tb(tmp_packed1&BEAM_LOOSE_MASK), I, Qb((tmp_packed1>>BEAM_LOOSE_SHIFT)));
  HEAVY_SWAPIN;;
  if (ERTS_LIKELY(next != NULL)) {
    SET_CP(c_p, (BeamInstr *) cp_val(*E));
    E = ADD_BYTE_OFFSET(E, Qb((tmp_packed1>>BEAM_LOOSE_SHIFT)));;
    SET_I((BeamInstr *) next);
    DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
    Dispatch();;
  }
  I = handle_error(c_p, I, reg, &bif_export[BIF_apply_3]->info.mfa);
  goto post_error_handling;;
}

OpCase(apply_t):
{
  BeamInstr *next;
  HEAVY_SWAPOUT;
  next = fixed_apply(c_p, reg, I[1], NULL, 0);
  HEAVY_SWAPIN;;
  if (ERTS_LIKELY(next != NULL)) {
    SET_CP(c_p, I+2);
    SET_I((BeamInstr *) next);
    DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
    Dispatch();;
  }
  I = handle_error(c_p, I, reg, &bif_export[BIF_apply_3]->info.mfa);
  goto post_error_handling;;
}

OpCase(bif1_body_bsd):
{
  Eterm targ1;
  Eterm dst = I[3];
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  GetR(1, targ1);
  {
    ErtsBifFunc bf;
    Eterm tmp_reg[1];

    tmp_reg[0] = targ1;
    bf = (BifFunction) I[1];
    do {
      Eterm result;

      ERTS_DBG_CHK_REDS(c_p, FCALLS);
      c_p->fcalls = FCALLS;
      PROCESS_MAIN_CHK_LOCKS(c_p);
      ASSERT(!ERTS_PROC_IS_EXITING(c_p));
      ERTS_CHK_MBUF_SZ(c_p);
      result = (*bf)(c_p, tmp_reg, I);
      ERTS_CHK_MBUF_SZ(c_p);
      ASSERT(!ERTS_PROC_IS_EXITING(c_p) || is_non_value(result));
      ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
      PROCESS_MAIN_CHK_LOCKS(c_p);
      ERTS_HOLE_CHECK(c_p);
      FCALLS = c_p->fcalls;
      ERTS_DBG_CHK_REDS(c_p, FCALLS);
      if (ERTS_LIKELY(is_value(result))) {
        *dst_ptr = result;
        SET_I((BeamInstr *) I+4);
        Goto(*I);;
      }
    } while (0);

    reg[0] = tmp_reg[0];
    SWAPOUT;
    I = handle_error(c_p, I, reg, ubif2mfa((void *) bf));
    goto post_error_handling;
  }
}

OpCase(bif1_fbsd):
{
  Eterm tmp_packed1 = I[1];
  Eterm targ1;
  Eterm dst = db((tmp_packed1>>BEAM_WIDE_SHIFT));
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  GetR(2, targ1);
  {
    ErtsBifFunc bf;
    Eterm tmp_reg[1];

    tmp_reg[0] = targ1;
    bf = (BifFunction) I[2];
    do {
      Eterm result;

      ERTS_DBG_CHK_REDS(c_p, FCALLS);
      c_p->fcalls = FCALLS;
      PROCESS_MAIN_CHK_LOCKS(c_p);
      ASSERT(!ERTS_PROC_IS_EXITING(c_p));
      ERTS_CHK_MBUF_SZ(c_p);
      result = (*bf)(c_p, tmp_reg, I);
      ERTS_CHK_MBUF_SZ(c_p);
      ASSERT(!ERTS_PROC_IS_EXITING(c_p) || is_non_value(result));
      ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
      PROCESS_MAIN_CHK_LOCKS(c_p);
      ERTS_HOLE_CHECK(c_p);
      FCALLS = c_p->fcalls;
      ERTS_DBG_CHK_REDS(c_p, FCALLS);
      if (ERTS_LIKELY(is_value(result))) {
        *dst_ptr = result;
        SET_I((BeamInstr *) I+4);
        Goto(*I);;
      }
    } while (0);

    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
}

OpCase(build_stacktrace):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  SWAPOUT;
  x(0) = build_stacktrace(c_p, x(0));
  SWAPIN;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(call_bif_e):
{
  ErtsBifFunc bf;
  Eterm result;
  ErlHeapFragment *live_hf_end;
  Export *export = (Export*) I[1];

  if (!((FCALLS - 1) > 0 || (FCALLS-1) > neg_o_reds)) {
    /* If we have run out of reductions, we do a context
    switch before calling the bif */
    c_p->arity = GET_BIF_ARITY(export);
    c_p->current = &export->info.mfa;
    goto context_switch3;
  }

  ERTS_MSACC_SET_BIF_STATE_CACHED_X(GET_BIF_MODULE(export),
  GET_BIF_ADDRESS(export));

  bf = GET_BIF_ADDRESS(export);

  PRE_BIF_SWAPOUT(c_p);
  ERTS_DBG_CHK_REDS(c_p, FCALLS);
  c_p->fcalls = FCALLS - 1;
  if (FCALLS <= 0) {
    save_calls(c_p, export);
  }
  ASSERT(!ERTS_PROC_IS_EXITING(c_p));
  ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
  live_hf_end = c_p->mbuf;
  ERTS_CHK_MBUF_SZ(c_p);
  result = (*bf)(c_p, reg, I);
  ERTS_CHK_MBUF_SZ(c_p);
  ASSERT(!ERTS_PROC_IS_EXITING(c_p) || is_non_value(result));
  ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
  ERTS_HOLE_CHECK(c_p);
  ERTS_REQ_PROC_MAIN_LOCK(c_p);
  if (ERTS_IS_GC_DESIRED(c_p)) {
    Uint arity = GET_BIF_ARITY(export);
    result = erts_gc_after_bif_call_lhf(c_p, live_hf_end, result,
    reg, arity);
    E = c_p->stop;
  }
  PROCESS_MAIN_CHK_LOCKS(c_p);
  HTOP = HEAP_TOP(c_p);
  FCALLS = c_p->fcalls;
  ERTS_DBG_CHK_REDS(c_p, FCALLS);
  /* We have to update the cache if we are enabled in order
  to make sure no book keeping is done after we disabled
  msacc. We don't always do this as it is quite expensive. */
  if (ERTS_MSACC_IS_ENABLED_CACHED_X()) {
    ERTS_MSACC_UPDATE_CACHE_X();
  }
  ERTS_MSACC_SET_STATE_CACHED_M_X(ERTS_MSACC_STATE_EMULATOR);
  if (ERTS_LIKELY(is_value(result))) {
    r(0) = result;
    CHECK_TERM(r(0));
    SET_I((BeamInstr *) I+2);
    Goto(*I);;
  } else if (c_p->freason == TRAP) {
    SET_CP(c_p, I+2);
    SET_I(c_p->i);
    SWAPIN;
    Dispatch();
  }

  /*
  * Error handling.  SWAPOUT is not needed because it was done above.
  */
  ASSERT(c_p->stop == E);
  I = handle_error(c_p, I, reg, &export->info.mfa);
  goto post_error_handling;
}

OpCase(catch_end_y):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  c_p->catches--;
  make_blank(yb(I[1]));;
  if (is_non_value(r(0))) {
    c_p->fvalue = NIL;
    if (x(1) == am_throw) {
      r(0) = x(2);
    } else {
      if (x(1) == am_error) {
        SWAPOUT;
        x(2) = add_stacktrace(c_p, x(2), x(3));
        SWAPIN;
      }
      /* only x(2) is included in the rootset here */
      if (E - HTOP < 3) {
        SWAPOUT;
        PROCESS_MAIN_CHK_LOCKS(c_p);
        FCALLS -= erts_garbage_collect_nobump(c_p, 3, reg+2, 1, FCALLS);
        ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        SWAPIN;
      }
      r(0) = TUPLE2(HTOP, am_EXIT, x(2));
      HTOP += 3;
    }
  }
  CHECK_TERM(r(0));
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(catch_yf):
{
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  c_p->catches++;
  yb(I[1]) = I[2];
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(deallocate_return_Q):
{
  int words_to_pop = I[1];
  SET_I((BeamInstr *) cp_val(*E));
  E = ADD_BYTE_OFFSET(E, words_to_pop);
  CHECK_TERM(x(0));
  DispatchReturn;
}

OpCase(get_hd_xx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* tmp_ptr = list_val(xb(tmp_packed1&BEAM_LOOSE_MASK));
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = CAR(tmp_ptr);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_hd_xy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* tmp_ptr = list_val(xb(tmp_packed1&BEAM_LOOSE_MASK));
  yb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = CAR(tmp_ptr);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_hd_yx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* tmp_ptr = list_val(yb(tmp_packed1&BEAM_LOOSE_MASK));
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = CAR(tmp_ptr);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_hd_yy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* tmp_ptr = list_val(yb(tmp_packed1&BEAM_LOOSE_MASK));
  yb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = CAR(tmp_ptr);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_rry):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* tmp_ptr = list_val(r(0));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  r(0) = hd;
  yb(I[1]) = tl;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_rxr):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* tmp_ptr = list_val(r(0));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  xb(I[1]) = hd;
  r(0) = tl;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_rxx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* tmp_ptr = list_val(r(0));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  xb(tmp_packed1&BEAM_LOOSE_MASK) = hd;
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = tl;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_rxy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* tmp_ptr = list_val(r(0));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  xb(tmp_packed1&BEAM_LOOSE_MASK) = hd;
  yb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = tl;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_ryr):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* tmp_ptr = list_val(r(0));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  yb(I[1]) = hd;
  r(0) = tl;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_xrx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* tmp_ptr = list_val(xb(tmp_packed1&BEAM_LOOSE_MASK));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  r(0) = hd;
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = tl;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_xxx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* tmp_ptr = list_val(xb(tmp_packed1&BEAM_TIGHT_MASK));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = hd;
  xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = tl;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_xxy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* tmp_ptr = list_val(xb(tmp_packed1&BEAM_TIGHT_MASK));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = hd;
  yb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = tl;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_xyx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* tmp_ptr = list_val(xb(tmp_packed1&BEAM_TIGHT_MASK));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  yb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = hd;
  xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = tl;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_xyy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* tmp_ptr = list_val(xb(tmp_packed1&BEAM_TIGHT_MASK));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  yb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = hd;
  yb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = tl;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_yxx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* tmp_ptr = list_val(yb(tmp_packed1&BEAM_TIGHT_MASK));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = hd;
  xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = tl;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_yxy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* tmp_ptr = list_val(yb(tmp_packed1&BEAM_TIGHT_MASK));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = hd;
  yb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = tl;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_yyx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* tmp_ptr = list_val(yb(tmp_packed1&BEAM_TIGHT_MASK));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  yb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = hd;
  xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = tl;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_yyy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* tmp_ptr = list_val(yb(tmp_packed1&BEAM_TIGHT_MASK));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  yb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = hd;
  yb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = tl;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_tl_xx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* tmp_ptr = list_val(xb(tmp_packed1&BEAM_LOOSE_MASK));
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = CDR(tmp_ptr);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_tl_xy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* tmp_ptr = list_val(xb(tmp_packed1&BEAM_LOOSE_MASK));
  yb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = CDR(tmp_ptr);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_tl_yx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* tmp_ptr = list_val(yb(tmp_packed1&BEAM_LOOSE_MASK));
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = CDR(tmp_ptr);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_tl_yy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* tmp_ptr = list_val(yb(tmp_packed1&BEAM_LOOSE_MASK));
  yb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = CDR(tmp_ptr);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(i_apply):
{
  BeamInstr *next;
  HEAVY_SWAPOUT;
  next = apply(c_p, reg, NULL, 0);
  HEAVY_SWAPIN;;
  if (ERTS_LIKELY(next != NULL)) {
    SET_CP(c_p, I+1);
    SET_I((BeamInstr *) next);
    DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
    Dispatch();;
  }
  I = handle_error(c_p, I, reg, &bif_export[BIF_apply_3]->info.mfa);
  goto post_error_handling;;
}

OpCase(i_apply_fun):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  BeamInstr *next;
  HEAVY_SWAPOUT;
  next = apply_fun(c_p, r(0), x(1), reg);
  HEAVY_SWAPIN;;
  if (ERTS_LIKELY(next != NULL)) {
    SET_CP(c_p, I+1);
    SET_I(next);
    Dispatchfun();;
  }
  goto find_func_info;;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(i_apply_fun_last_Q):
{
  BeamInstr *next;
  HEAVY_SWAPOUT;
  next = apply_fun(c_p, r(0), x(1), reg);
  HEAVY_SWAPIN;;
  if (ERTS_LIKELY(next != NULL)) {
    SET_CP(c_p, (BeamInstr *) cp_val(*E));
    E = ADD_BYTE_OFFSET(E, I[1]);;
    SET_I(next);
    Dispatchfun();;
  }
  goto find_func_info;;
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_apply_fun_only):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  BeamInstr *next;
  HEAVY_SWAPOUT;
  next = apply_fun(c_p, r(0), x(1), reg);
  HEAVY_SWAPIN;;
  if (ERTS_LIKELY(next != NULL)) {
    SET_I(next);
    Dispatchfun();;
  }
  goto find_func_info;;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(i_apply_last_Q):
{
  BeamInstr *next;
  HEAVY_SWAPOUT;
  next = apply(c_p, reg, I, I[1]);
  HEAVY_SWAPIN;;
  if (ERTS_LIKELY(next != NULL)) {
    SET_CP(c_p, (BeamInstr *) cp_val(*E));
    E = ADD_BYTE_OFFSET(E, I[1]);;
    SET_I((BeamInstr *) next);
    DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
    Dispatch();;
  }
  I = handle_error(c_p, I, reg, &bif_export[BIF_apply_3]->info.mfa);
  goto post_error_handling;;
}

OpCase(i_apply_only):
{
  BeamInstr *next;
  HEAVY_SWAPOUT;
  next = apply(c_p, reg, I, 0);
  HEAVY_SWAPIN;;
  if (ERTS_LIKELY(next != NULL)) {
    SET_I((BeamInstr *) next);
    DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
    Dispatch();;
  }
  I = handle_error(c_p, I, reg, &bif_export[BIF_apply_3]->info.mfa);
  goto post_error_handling;;
}

{
  Eterm BandOp1, BandOp2;
  OpCase(i_band_ssjtd):
  {
    Eterm targ1;
    Eterm targ2;
    GetR(0, targ1);
    GetR(1, targ2);
    {
      BandOp1 = targ1;
      BandOp2 = targ2;
    }
  }
  goto band__execute;

  OpCase(i_band_xcjtd):
  {
    BandOp1 = xb(I[1]);
    BandOp2 = I[2];
  }
  goto band__execute;

  band__execute:
  {
    Eterm tmp_packed1 = I[4];
    Eterm dst = db((tmp_packed1>>BEAM_LOOSE_SHIFT));
    Eterm* dst_ptr = REG_TARGET_PTR(dst);
    if (ERTS_LIKELY(is_both_small(BandOp1, BandOp2))) {
      /*
      * No need to untag -- TAG & TAG == TAG.
      */
      *dst_ptr = BandOp1 & BandOp2;
      SET_I((BeamInstr *) I+5);
      Goto(*I);;
    }
    do {
      Eterm result;
      Uint live = tb(tmp_packed1&BEAM_LOOSE_MASK);
      HEAVY_SWAPOUT;
      reg[live] = BandOp1;
      reg[live+1] = BandOp2;
      result = erts_gc_band (c_p, reg, live);
      HEAVY_SWAPIN;
      ERTS_HOLE_CHECK(c_p);
      if (ERTS_LIKELY(is_value(result))) {
        dst_ptr = REG_TARGET_PTR(dst);
        *dst_ptr = result;
        SET_I((BeamInstr *) I+5);
        Goto(*I);;
      }
      if (ERTS_LIKELY(I[3])) {
        ASSERT(VALID_INSTR(*(I + (I[3]) + 0)));
        I += I[3] + 0;;
        Goto(*I);;
      }
      reg[0] = reg[live];
      reg[1] = reg[live+1];
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_band_2]->info.mfa);
      goto post_error_handling;;
    } while (0);
  }

}

OpCase(i_bif2_body_bssd):
{
  Eterm targ1;
  Eterm targ2;
  Eterm dst = I[4];
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  GetR(1, targ1);
  GetR(2, targ2);
  {
    Eterm tmp_reg[2];
    ErtsBifFunc bf;

    tmp_reg[0] = targ1;
    tmp_reg[1] = targ2;
    bf = (ErtsBifFunc) I[1];
    do {
      Eterm result;

      ERTS_DBG_CHK_REDS(c_p, FCALLS);
      c_p->fcalls = FCALLS;
      PROCESS_MAIN_CHK_LOCKS(c_p);
      ASSERT(!ERTS_PROC_IS_EXITING(c_p));
      ERTS_CHK_MBUF_SZ(c_p);
      result = (*bf)(c_p, tmp_reg, I);
      ERTS_CHK_MBUF_SZ(c_p);
      ASSERT(!ERTS_PROC_IS_EXITING(c_p) || is_non_value(result));
      ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
      PROCESS_MAIN_CHK_LOCKS(c_p);
      ERTS_HOLE_CHECK(c_p);
      FCALLS = c_p->fcalls;
      ERTS_DBG_CHK_REDS(c_p, FCALLS);
      if (ERTS_LIKELY(is_value(result))) {
        *dst_ptr = result;
        SET_I((BeamInstr *) I+5);
        Goto(*I);;
      }
    } while (0);
    reg[0] = tmp_reg[0];
    reg[1] = tmp_reg[1];
    SWAPOUT;
    I = handle_error(c_p, I, reg, ubif2mfa((void *) bf));
    goto post_error_handling;
  }
}

OpCase(i_bif2_fbssd):
{
  Eterm tmp_packed1 = I[1];
  Eterm targ1;
  Eterm targ2;
  Eterm dst = db((tmp_packed1>>BEAM_WIDE_SHIFT));
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  GetR(2, targ1);
  GetR(3, targ2);
  {
    Eterm tmp_reg[2];
    ErtsBifFunc bf;

    tmp_reg[0] = targ1;
    tmp_reg[1] = targ2;
    bf = (ErtsBifFunc) I[2];
    do {
      Eterm result;

      ERTS_DBG_CHK_REDS(c_p, FCALLS);
      c_p->fcalls = FCALLS;
      PROCESS_MAIN_CHK_LOCKS(c_p);
      ASSERT(!ERTS_PROC_IS_EXITING(c_p));
      ERTS_CHK_MBUF_SZ(c_p);
      result = (*bf)(c_p, tmp_reg, I);
      ERTS_CHK_MBUF_SZ(c_p);
      ASSERT(!ERTS_PROC_IS_EXITING(c_p) || is_non_value(result));
      ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
      PROCESS_MAIN_CHK_LOCKS(c_p);
      ERTS_HOLE_CHECK(c_p);
      FCALLS = c_p->fcalls;
      ERTS_DBG_CHK_REDS(c_p, FCALLS);
      if (ERTS_LIKELY(is_value(result))) {
        *dst_ptr = result;
        SET_I((BeamInstr *) I+5);
        Goto(*I);;
      }
    } while (0);
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
}

OpCase(i_bor_jIssd):
{
  Eterm tmp_packed1 = I[2];
  Eterm targ1;
  Eterm targ2;
  Eterm dst = db((tmp_packed1>>BEAM_WIDE_SHIFT));
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  GetR(2, targ1);
  GetR(3, targ2);
  {
    if (ERTS_LIKELY(is_both_small(targ1, targ2))) {
      /*
      * No need to untag -- TAG | TAG == TAG.
      */
      *dst_ptr = targ1 | targ2;
      SET_I((BeamInstr *) I+5);
      Goto(*I);;
    }
    do {
      Eterm result;
      Uint live = Ib(tmp_packed1&BEAM_WIDE_MASK);
      HEAVY_SWAPOUT;
      reg[live] = targ1;
      reg[live+1] = targ2;
      result = erts_gc_bor (c_p, reg, live);
      HEAVY_SWAPIN;
      ERTS_HOLE_CHECK(c_p);
      if (ERTS_LIKELY(is_value(result))) {
        dst_ptr = REG_TARGET_PTR(dst);
        *dst_ptr = result;
        SET_I((BeamInstr *) I+5);
        Goto(*I);;
      }
      if (ERTS_LIKELY(I[1])) {
        ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
        I += I[1] + 0;;
        Goto(*I);;
      }
      reg[0] = reg[live];
      reg[1] = reg[live+1];
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_bor_2]->info.mfa);
      goto post_error_handling;;
    } while (0);
  }
}

{
  Eterm Op1, Op2;
  Sint shift_left_count;
  OpCase(i_bsl_ssjtd):
  {
    Eterm targ1;
    Eterm targ2;
    GetR(0, targ1);
    GetR(1, targ2);
    {
      Op1 = targ1;
      Op2 = targ2;
      shift_left_count = 0;
      if (ERTS_LIKELY(is_small(Op2))) {
        shift_left_count = signed_val(Op2);
      } else if (is_big(Op2)) {
        if (bignum_header_is_neg(*big_val(Op2))) {
          /*
          * N bsl NegativeBigNum is either 0 or -1, depending on
          * the sign of N. Since we don't believe this case
          * is common, do the calculation with the minimum
          * amount of code.
          */
          shift_left_count = MIN_SMALL;
        } else if (is_integer(Op1)) {
          /*
          * N bsl PositiveBigNum is too large to represent.
          */
          shift_left_count = MAX_SMALL;
        }
      }
    }
  }
  goto shift__execute;

  OpCase(i_bsr_ssjtd):
  {
    Eterm targ1;
    Eterm targ2;
    GetR(0, targ1);
    GetR(1, targ2);
    {
      Op1 = targ1;
      Op2 = targ2;
      shift_left_count = 0;
      if (ERTS_LIKELY(is_small(Op2))) {
        shift_left_count = -signed_val(Op2);
      } else if (is_big(Op2)) {
        /*
        * N bsr NegativeBigNum == N bsl MAX_SMALL
        * N bsr PositiveBigNum == N bsl MIN_SMALL
        */
        shift_left_count = make_small(bignum_header_is_neg(*big_val(Op2)) ?
        MAX_SMALL : MIN_SMALL);
      }
    }
  }
  goto shift__execute;

  shift__execute:
  {
    Eterm tmp_packed1 = I[4];
    Eterm dst = db((tmp_packed1>>BEAM_LOOSE_SHIFT));
    Eterm* dst_ptr = REG_TARGET_PTR(dst);
    Uint big_words_needed;

    if (ERTS_LIKELY(is_small(Op1))) {
      Sint int_res = signed_val(Op1);
      if (ERTS_UNLIKELY(shift_left_count == 0 || int_res == 0)) {
        if (ERTS_UNLIKELY(is_not_integer(Op2))) {
          goto shift_error;
        }
        if (int_res == 0) {
          *dst_ptr = Op1;
          SET_I((BeamInstr *) I+5);
          Goto(*I);;
        }
      } else if (shift_left_count < 0)  { /* Right shift */
        Eterm bsr_res;
        shift_left_count = -shift_left_count;
        if (shift_left_count >= SMALL_BITS-1) {
          bsr_res = (int_res < 0) ? SMALL_MINUS_ONE : SMALL_ZERO;
        } else {
          bsr_res = make_small(int_res >> shift_left_count);
        }
        *dst_ptr = bsr_res;
        SET_I((BeamInstr *) I+5);
        Goto(*I);;
      } else if (shift_left_count < SMALL_BITS-1) { /* Left shift */
        if ((int_res > 0 &&
        ((~(Uint)0 << ((SMALL_BITS-1)-shift_left_count)) & int_res) == 0) ||
        ((~(Uint)0 << ((SMALL_BITS-1)-shift_left_count)) & ~int_res) == 0) {
          *dst_ptr = make_small(int_res << shift_left_count);
          SET_I((BeamInstr *) I+5);
          Goto(*I);;
        }
      }
      big_words_needed = 1;   /* big_size(small_to_big(Op1)) */
      goto big_shift;
    } else if (is_big(Op1)) {
      if (shift_left_count == 0) {
        if (is_not_integer(Op2)) {
          goto shift_error;
        }
        *dst_ptr = Op1;
        SET_I((BeamInstr *) I+5);
        Goto(*I);;
      }
      big_words_needed = big_size(Op1);

      big_shift:
      if (shift_left_count > 0) {	/* Left shift. */
        big_words_needed += (shift_left_count / D_EXP);
      } else {	/* Right shift. */
        if (big_words_needed <= (-shift_left_count / D_EXP)) {
          big_words_needed = 3;       /* ??? */
        } else {
          big_words_needed -= (-shift_left_count / D_EXP);
        }
      }
      {
        Eterm tmp_big[2];
        Sint big_need_size = BIG_NEED_SIZE(big_words_needed+1);

        /*
        * Slightly conservative check the size to avoid
        * allocating huge amounts of memory for bignums that
        * clearly would overflow the arity in the header
        * word.
        */
        if (big_need_size-8 > BIG_ARITY_MAX) {
          c_p->freason = SYSTEM_LIMIT;

          /*
          * In a correctly working program, we expect failures in
          * guards to be more likely than failures in bodies.
          */

          if (ERTS_LIKELY(I[3])) {
            ASSERT(VALID_INSTR(*(I + (I[3]) + 0)));
            I += I[3] + 0;;
            Goto(*I);;
          }
          goto find_func_info;;;
        }
        do {
          Uint need = big_need_size+1;
          if (ERTS_UNLIKELY(E - HTOP < need)) {
            SWAPOUT;
            reg[tb(tmp_packed1&BEAM_LOOSE_MASK)] = Op1;
            PROCESS_MAIN_CHK_LOCKS(c_p);
            FCALLS -= erts_garbage_collect_nobump(c_p, need, reg, tb(tmp_packed1&BEAM_LOOSE_MASK)+1, FCALLS);
            ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
            PROCESS_MAIN_CHK_LOCKS(c_p);
            Op1 = reg[tb(tmp_packed1&BEAM_LOOSE_MASK)];
            SWAPIN;
          }
          HEAP_SPACE_VERIFIED(big_need_size+1);
        } while (0);
        if (is_small(Op1)) {
          Op1 = small_to_big(signed_val(Op1), tmp_big);
        }
        Op1 = big_lshift(Op1, shift_left_count, HTOP);
        if (is_big(Op1)) {
          HTOP += bignum_header_arity(*HTOP) + 1;
        }
        HEAP_SPACE_VERIFIED(0);
        if (ERTS_UNLIKELY(is_nil(Op1))) {
          /*
          * This result must have been only slighty larger
          * than allowed since it wasn't caught by the
          * previous test.
          */
          c_p->freason = SYSTEM_LIMIT;

          /*
          * In a correctly working program, we expect failures in
          * guards to be more likely than failures in bodies.
          */

          if (ERTS_LIKELY(I[3])) {
            ASSERT(VALID_INSTR(*(I + (I[3]) + 0)));
            I += I[3] + 0;;
            Goto(*I);;
          }
          goto find_func_info;;;
        }
        ERTS_HOLE_CHECK(c_p);
        dst_ptr = REG_TARGET_PTR(dst);
        *dst_ptr = Op1;
        SET_I((BeamInstr *) I+5);
        Goto(*I);;
      }
    }

    /*
    * One or more non-integer arguments.
    */
    shift_error:
    c_p->freason = BADARITH;
    if (I[3]) {
      ASSERT(VALID_INSTR(*(I + (I[3]) + 0)));
      I += I[3] + 0;;
      Goto(*I);;
    } else {
      reg[0] = Op1;
      reg[1] = Op2;
      SWAPOUT;
      if (IsOpCode(I[0], i_bsl_ssjtd)) {
        I = handle_error(c_p, I, reg, &bif_export[BIF_bsl_2]->info.mfa);
      } else {
        ASSERT(IsOpCode(I[0], i_bsr_ssjtd));
        I = handle_error(c_p, I, reg, &bif_export[BIF_bsr_2]->info.mfa);
      }
      goto post_error_handling;
    }
  }

}

OpCase(i_bxor_jIssd):
{
  Eterm tmp_packed1 = I[2];
  Eterm targ1;
  Eterm targ2;
  Eterm dst = db((tmp_packed1>>BEAM_WIDE_SHIFT));
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  GetR(2, targ1);
  GetR(3, targ2);
  {
    if (ERTS_LIKELY(is_both_small(targ1, targ2))) {
      /*
      * TAG ^ TAG == 0.
      *
      * Therefore, we perform the XOR operation on the tagged values,
      * and OR in the tag bits.
      */
      *dst_ptr = (targ1 ^ targ2) | make_small(0);
      SET_I((BeamInstr *) I+5);
      Goto(*I);;
    }
    do {
      Eterm result;
      Uint live = Ib(tmp_packed1&BEAM_WIDE_MASK);
      HEAVY_SWAPOUT;
      reg[live] = targ1;
      reg[live+1] = targ2;
      result = erts_gc_bxor (c_p, reg, live);
      HEAVY_SWAPIN;
      ERTS_HOLE_CHECK(c_p);
      if (ERTS_LIKELY(is_value(result))) {
        dst_ptr = REG_TARGET_PTR(dst);
        *dst_ptr = result;
        SET_I((BeamInstr *) I+5);
        Goto(*I);;
      }
      if (ERTS_LIKELY(I[1])) {
        ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
        I += I[1] + 0;;
        Goto(*I);;
      }
      reg[0] = reg[live];
      reg[1] = reg[live+1];
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_bxor_2]->info.mfa);
      goto post_error_handling;;
    } while (0);
  }
}

OpCase(i_call_ext_e):
{
  SET_CP(c_p, I+2);
  DTRACE_GLOBAL_CALL_FROM_EXPORT(c_p, I[1]);
  // Dispatchx assumes the Export* is in Arg(0)
  I = (&I[1]) - 1;
  Dispatchx();;
}

OpCase(i_call_ext_last_eQ):
{
  SET_CP(c_p, (BeamInstr *) cp_val(*E));
  E = ADD_BYTE_OFFSET(E, I[2]);;
  DTRACE_GLOBAL_CALL_FROM_EXPORT(c_p, I[1]);
  // Dispatchx assumes the Export* is in Arg(0)
  I = (&I[1]) - 1;
  Dispatchx();;
}

OpCase(i_call_ext_only_e):
{
  DTRACE_GLOBAL_CALL_FROM_EXPORT(c_p, I[1]);
  // Dispatchx assumes the Export* is in Arg(0)
  I = (&I[1]) - 1;
  Dispatchx();;
}

OpCase(i_call_f):
{
  SET_CP(c_p, I+2);
  ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
  I += I[1] + 0;;
  DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
  Dispatch();;
}

OpCase(i_call_fun_last_tQ):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr *next;
  HEAVY_SWAPOUT;
  next = call_fun(c_p, tb(tmp_packed1&BEAM_LOOSE_MASK), reg, THE_NON_VALUE);
  HEAVY_SWAPIN;;
  if (ERTS_LIKELY(next != NULL)) {
    SET_CP(c_p, (BeamInstr *) cp_val(*E));
    E = ADD_BYTE_OFFSET(E, Qb((tmp_packed1>>BEAM_LOOSE_SHIFT)));;
    SET_I(next);
    Dispatchfun();;
  }
  goto find_func_info;;
}

OpCase(i_call_fun_t):
{
  BeamInstr *next;
  HEAVY_SWAPOUT;
  next = call_fun(c_p, I[1], reg, THE_NON_VALUE);
  HEAVY_SWAPIN;;
  if (ERTS_LIKELY(next != NULL)) {
    SET_CP(c_p, I+2);
    SET_I(next);
    Dispatchfun();;
  }
  goto find_func_info;;
}

OpCase(i_call_last_fQ):
{
  Eterm tmp_packed1 = I[1];
  SET_CP(c_p, (BeamInstr *) cp_val(*E));
  E = ADD_BYTE_OFFSET(E, Qb((tmp_packed1>>BEAM_WIDE_SHIFT)));;
  ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
  I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
  DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
  Dispatch();;
}

OpCase(i_call_only_f):
{
  ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
  I += I[1] + 0;;
  DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
  Dispatch();;
}

{
  Eterm element_tuple;
  OpCase(i_element_xjsd):
  {
    element_tuple = xb(I[1]);
  }
  goto element_group__execute;

  OpCase(i_element_yjsd):
  {
    element_tuple = yb(I[1]);
  }
  goto element_group__execute;

  element_group__execute:
  {
    Eterm tmp_packed1 = I[2];
    Eterm targ1;
    Eterm dst = db((tmp_packed1>>BEAM_WIDE_SHIFT));
    Eterm* dst_ptr = REG_TARGET_PTR(dst);
    GetR(2, targ1);
    {
      Eterm element_index = targ1;
      if (ERTS_LIKELY(is_small(element_index) && is_tuple(element_tuple))) {
        Eterm* tp = tuple_val(element_tuple);

        if ((signed_val(element_index) >= 1) &&
        (signed_val(element_index) <= arityval(*tp))) {
          *dst_ptr = tp[signed_val(element_index)];
          SET_I((BeamInstr *) I+4);
          Goto(*I);;
        }
      }
      c_p->freason = BADARG;
      if (ERTS_LIKELY(jb(tmp_packed1&BEAM_WIDE_MASK))) {
        ASSERT(VALID_INSTR(*(I + (jb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
        I += jb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
        Goto(*I);;
      }
      reg[0] = element_index;
      reg[1] = element_tuple;
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_element_2]->info.mfa);
      goto post_error_handling;;
    }
  }

}

{
  Eterm fast_element_tuple;
  OpCase(i_fast_element_xjId):
  {
    fast_element_tuple = xb(I[1]);
  }
  goto fast_element_group__execute;

  OpCase(i_fast_element_yjId):
  {
    fast_element_tuple = yb(I[1]);
  }
  goto fast_element_group__execute;

  fast_element_group__execute:
  {
    Eterm tmp_packed1 = I[3];
    Eterm dst = db((tmp_packed1>>BEAM_WIDE_SHIFT));
    Eterm* dst_ptr = REG_TARGET_PTR(dst);
    if (ERTS_LIKELY(is_tuple(fast_element_tuple))) {
      Eterm* tp = tuple_val(fast_element_tuple);
      Eterm pos = Ib(tmp_packed1&BEAM_WIDE_MASK);	/* Untagged integer >= 1 */
      if (pos <= arityval(*tp)) {
        *dst_ptr = tp[pos];
        SET_I((BeamInstr *) I+4);
        Goto(*I);;
      }
    }
    c_p->freason = BADARG;
    if (ERTS_LIKELY(I[2])) {
      ASSERT(VALID_INSTR(*(I + (I[2]) + 0)));
      I += I[2] + 0;;
      Goto(*I);;
    }
    reg[0] = make_small(Ib(tmp_packed1&BEAM_WIDE_MASK));
    reg[1] = fast_element_tuple;
    SWAPOUT;
    I = handle_error(c_p, I, reg, &bif_export[BIF_element_2]->info.mfa);
    goto post_error_handling;;
  }

}

OpCase(i_gc_bif1_jWstd):
{
  Eterm tmp_packed1 = I[4];
  Eterm targ1;
  Eterm dst = db((tmp_packed1>>BEAM_LOOSE_SHIFT));
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  GetR(2, targ1);
  {
    typedef Eterm (*GcBifFunction)(Process*, Eterm*, Uint);
    GcBifFunction bf;
    Eterm result;
    Uint live = (Uint) tb(tmp_packed1&BEAM_LOOSE_MASK);

    x(live) = targ1;
    bf = (GcBifFunction) I[2];
    ERTS_DBG_CHK_REDS(c_p, FCALLS);
    c_p->fcalls = FCALLS;
    SWAPOUT;
    PROCESS_MAIN_CHK_LOCKS(c_p);
    ERTS_UNREQ_PROC_MAIN_LOCK(c_p);
    ERTS_CHK_MBUF_SZ(c_p);
    result = (*bf)(c_p, reg, live);
    ERTS_CHK_MBUF_SZ(c_p);
    ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
    ERTS_REQ_PROC_MAIN_LOCK(c_p);
    PROCESS_MAIN_CHK_LOCKS(c_p);
    SWAPIN;
    ERTS_HOLE_CHECK(c_p);
    FCALLS = c_p->fcalls;
    ERTS_DBG_CHK_REDS(c_p, FCALLS);
    if (ERTS_LIKELY(is_value(result))) {
      dst_ptr = REG_TARGET_PTR(dst);
      *dst_ptr = result;
      SET_I((BeamInstr *) I+5);
      Goto(*I);;
    }
    if (ERTS_LIKELY(I[1] != 0)) { /* Handle error in guard. */
      ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
      I += I[1] + 0;;
      Goto(*I);;
    }

    /* Handle error in body. */
    x(0) = x(live);
    I = handle_error(c_p, I, reg, gcbif2mfa((void *) bf));
    goto post_error_handling;
  }
}

OpCase(i_gc_bif2_jWtssd):
{
  Eterm tmp_packed1 = I[3];
  Eterm targ1;
  Eterm targ2;
  Eterm dst = db((tmp_packed1>>BEAM_LOOSE_SHIFT));
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  GetR(3, targ1);
  GetR(4, targ2);
  {
    typedef Eterm (*GcBifFunction)(Process*, Eterm*, Uint);
    GcBifFunction bf;
    Eterm result;
    Uint live = (Uint) tb(tmp_packed1&BEAM_LOOSE_MASK);

    /*
    * XXX This calling convention does not make sense. 'live'
    * should point out the first argument, not the second
    * (i.e. 'live' should not be incremented below).
    */
    x(live) = targ1;
    x(live+1) = targ2;
    live++;

    bf = (GcBifFunction) I[2];
    ERTS_DBG_CHK_REDS(c_p, FCALLS);
    c_p->fcalls = FCALLS;
    SWAPOUT;
    PROCESS_MAIN_CHK_LOCKS(c_p);
    ERTS_UNREQ_PROC_MAIN_LOCK(c_p);
    ERTS_CHK_MBUF_SZ(c_p);
    result = (*bf)(c_p, reg, live);
    ERTS_CHK_MBUF_SZ(c_p);
    ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
    ERTS_REQ_PROC_MAIN_LOCK(c_p);
    PROCESS_MAIN_CHK_LOCKS(c_p);
    SWAPIN;
    ERTS_HOLE_CHECK(c_p);
    FCALLS = c_p->fcalls;
    ERTS_DBG_CHK_REDS(c_p, FCALLS);
    if (ERTS_LIKELY(is_value(result))) {
      dst_ptr = REG_TARGET_PTR(dst);
      *dst_ptr = result;
      SET_I((BeamInstr *) I+6);
      Goto(*I);;
    }

    if (ERTS_LIKELY(I[1] != 0)) { /* Handle error in guard. */
      ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
      I += I[1] + 0;;
      Goto(*I);;
    }

    /* Handle error in body. */
    live--;
    x(0) = x(live);
    x(1) = x(live+1);
    I = handle_error(c_p, I, reg, gcbif2mfa((void *) bf));
    goto post_error_handling;
  }
}

OpCase(i_gc_bif3_jWtssd):
{
  Eterm tmp_packed1 = I[3];
  Eterm targ1;
  Eterm targ2;
  Eterm dst = db((tmp_packed1>>BEAM_LOOSE_SHIFT));
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  GetR(3, targ1);
  GetR(4, targ2);
  {
    typedef Eterm (*GcBifFunction)(Process*, Eterm*, Uint);
    GcBifFunction bf;
    Eterm result;
    Uint live = (Uint) tb(tmp_packed1&BEAM_LOOSE_MASK);

    /*
    * XXX This calling convention does not make sense. 'live'
    * should point out the first argument, not the third
    * (i.e. 'live' should not be incremented below).
    */
    x(live) = x(SCRATCH_X_REG);
    x(live+1) = targ1;
    x(live+2) = targ2;
    live += 2;

    bf = (GcBifFunction) I[2];
    ERTS_DBG_CHK_REDS(c_p, FCALLS);
    c_p->fcalls = FCALLS;
    SWAPOUT;
    PROCESS_MAIN_CHK_LOCKS(c_p);
    ERTS_UNREQ_PROC_MAIN_LOCK(c_p);
    ERTS_CHK_MBUF_SZ(c_p);
    result = (*bf)(c_p, reg, live);
    ERTS_CHK_MBUF_SZ(c_p);
    ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
    ERTS_REQ_PROC_MAIN_LOCK(c_p);
    PROCESS_MAIN_CHK_LOCKS(c_p);
    SWAPIN;
    ERTS_HOLE_CHECK(c_p);
    FCALLS = c_p->fcalls;
    ERTS_DBG_CHK_REDS(c_p, FCALLS);
    if (ERTS_LIKELY(is_value(result))) {
      dst_ptr = REG_TARGET_PTR(dst);
      *dst_ptr = result;
      SET_I((BeamInstr *) I+6);
      Goto(*I);;
    }

    /* Handle error in guard. */
    if (ERTS_LIKELY(I[1] != 0)) {
      ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
      I += I[1] + 0;;
      Goto(*I);;
    }

    /* Handle error in body. */
    live -= 2;
    x(0) = x(live);
    x(1) = x(live+1);
    x(2) = x(live+2);
    I = handle_error(c_p, I, reg, gcbif2mfa((void *) bf));
    goto post_error_handling;
  }
}

OpCase(i_get_hash_cId):
{
  Eterm tmp_packed1 = I[2];
  Eterm dst = db((tmp_packed1>>BEAM_WIDE_SHIFT));
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  *dst_ptr = erts_pd_hash_get_with_hx(c_p, Ib(tmp_packed1&BEAM_WIDE_MASK), I[1]);
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(i_get_map_element_fxxx):
{
  Eterm tmp_packed1 = I[2];
  Eterm res = get_map_element(xb(tmp_packed1&BEAM_TIGHT_MASK), xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK));
  if (is_non_value(res)) {
    ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
    I += I[1] + 0;;
    Goto(*I);;
  }
  xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = res;
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_get_map_element_fxxy):
{
  Eterm tmp_packed1 = I[2];
  Eterm res = get_map_element(xb(tmp_packed1&BEAM_TIGHT_MASK), xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK));
  if (is_non_value(res)) {
    ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
    I += I[1] + 0;;
    Goto(*I);;
  }
  yb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = res;
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_get_map_element_fyxx):
{
  Eterm tmp_packed1 = I[2];
  Eterm res = get_map_element(yb(tmp_packed1&BEAM_TIGHT_MASK), xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK));
  if (is_non_value(res)) {
    ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
    I += I[1] + 0;;
    Goto(*I);;
  }
  xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = res;
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_get_map_element_fyxy):
{
  Eterm tmp_packed1 = I[2];
  Eterm res = get_map_element(yb(tmp_packed1&BEAM_TIGHT_MASK), xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK));
  if (is_non_value(res)) {
    ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
    I += I[1] + 0;;
    Goto(*I);;
  }
  yb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = res;
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_get_map_element_hash_fxcIx):
{
  Eterm tmp_packed1 = I[1];
  Eterm tmp_packed2 = I[3];
  Eterm res = get_map_element_hash(xb((tmp_packed1>>BEAM_WIDE_SHIFT)), I[2], Ib(tmp_packed2&BEAM_WIDE_MASK));
  if (is_non_value(res)) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  xb((tmp_packed2>>BEAM_WIDE_SHIFT)) = res;
  I += 4;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_get_map_element_hash_fxcIy):
{
  Eterm tmp_packed1 = I[1];
  Eterm tmp_packed2 = I[3];
  Eterm res = get_map_element_hash(xb((tmp_packed1>>BEAM_WIDE_SHIFT)), I[2], Ib(tmp_packed2&BEAM_WIDE_MASK));
  if (is_non_value(res)) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  yb((tmp_packed2>>BEAM_WIDE_SHIFT)) = res;
  I += 4;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_get_map_element_hash_fycIx):
{
  Eterm tmp_packed1 = I[1];
  Eterm tmp_packed2 = I[3];
  Eterm res = get_map_element_hash(yb((tmp_packed1>>BEAM_WIDE_SHIFT)), I[2], Ib(tmp_packed2&BEAM_WIDE_MASK));
  if (is_non_value(res)) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  xb((tmp_packed2>>BEAM_WIDE_SHIFT)) = res;
  I += 4;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_get_map_element_hash_fycIy):
{
  Eterm tmp_packed1 = I[1];
  Eterm tmp_packed2 = I[3];
  Eterm res = get_map_element_hash(yb((tmp_packed1>>BEAM_WIDE_SHIFT)), I[2], Ib(tmp_packed2&BEAM_WIDE_MASK));
  if (is_non_value(res)) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  yb((tmp_packed2>>BEAM_WIDE_SHIFT)) = res;
  I += 4;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_get_map_elements_fsI):
{
  Eterm tmp_packed1 = I[1];
  Eterm targ1;
  GetR(1, targ1);
  {
    Eterm map;
    BeamInstr *fs;
    Uint sz, n;

    map = targ1;

    /* This instruction assumes Arg1 is a map,
    * i.e. that it follows a test is_map if needed.
    */

    n  = (Uint)Ib((tmp_packed1>>BEAM_WIDE_SHIFT)) / 3;
    fs = I+3;

    if (is_flatmap(map)) {
      flatmap_t *mp;
      Eterm *ks;
      Eterm *vs;

      mp = (flatmap_t *)flatmap_val(map);
      sz = flatmap_get_size(mp);

      if (sz == 0) {
        ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
        I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
        Goto(*I);;
      }

      ks = flatmap_get_keys(mp);
      vs = flatmap_get_values(mp);

      while(sz) {
        if (EQ((Eterm) fs[0], *ks)) {
          PUT_TERM_REG(*vs, fs[1]);
          n--;
          fs += 3;
          /* no more values to fetch, we are done */
          if (n == 0) {
            SET_I((BeamInstr *) fs);
            Goto(*I);;
          }
        }
        ks++, sz--, vs++;
      }
      ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
      I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
      Goto(*I);;
    } else {
      const Eterm *v;
      Uint32 hx;
      ASSERT(is_hashmap(map));
      while(n--) {
        hx = fs[2];
        ASSERT(hx == hashmap_make_hash((Eterm)fs[0]));
        if ((v = erts_hashmap_get(hx, (Eterm)fs[0], map)) == NULL) {
          ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
          I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
          Goto(*I);;
        }
        PUT_TERM_REG(*v, fs[1]);
        fs += 3;
      }
      SET_I((BeamInstr *) fs);
      Goto(*I);;
    }
  }
}

OpCase(i_get_sd):
{
  Eterm targ1;
  Eterm dst = I[2];
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  GetR(0, targ1);
  {
    *dst_ptr = erts_pd_hash_get(c_p, targ1);
    I += 3;
    ASSERT(VALID_INSTR(next_pf));
    GotoPF(next_pf);
  }
}

OpCase(i_get_tuple_element2_xPx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  Eterm* src;
  Eterm* dst;
  Eterm E1, E2;
  src = ADD_BYTE_OFFSET(tuple_val(xb(tmp_packed1&BEAM_LOOSE_MASK)), I[2]);
  dst = &(xb((tmp_packed1>>BEAM_LOOSE_SHIFT)));
  E1 = src[0];
  E2 = src[1];
  dst[0] = E1;
  dst[1] = E2;
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(i_get_tuple_element2y_xPyy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  Eterm* src;
  Eterm E1, E2;
  src = ADD_BYTE_OFFSET(tuple_val(xb(tmp_packed1&BEAM_TIGHT_MASK)), I[2]);
  E1 = src[0];
  E2 = src[1];
  yb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = E1;
  yb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = E2;
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(i_get_tuple_element3_xPx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  Eterm* src;
  Eterm* dst;
  Eterm E1, E2, E3;
  src = ADD_BYTE_OFFSET(tuple_val(xb(tmp_packed1&BEAM_LOOSE_MASK)), I[2]);
  dst = &(xb((tmp_packed1>>BEAM_LOOSE_SHIFT)));
  E1 = src[0];
  E2 = src[1];
  E3 = src[2];
  dst[0] = E1;
  dst[1] = E2;
  dst[2] = E3;
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(i_get_tuple_element_xPx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  Eterm* src = ADD_BYTE_OFFSET(tuple_val(xb(tmp_packed1&BEAM_LOOSE_MASK)), I[2]);
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = *src;
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(i_get_tuple_element_yPx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  Eterm* src = ADD_BYTE_OFFSET(tuple_val(yb(tmp_packed1&BEAM_LOOSE_MASK)), I[2]);
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = *src;
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

{
  Eterm increment_reg_val;
  OpCase(i_increment_rWtd):
  {
    increment_reg_val = r(0);
  }
  goto increment__execute;

  OpCase(i_increment_xWtd):
  {
    increment_reg_val = xb(I[1]);
  }
  I += 1;
  goto increment__execute;

  OpCase(i_increment_yWtd):
  {
    increment_reg_val = yb(I[1]);
  }
  I += 1;
  goto increment__execute;

  increment__execute:
  {
    Eterm tmp_packed1 = I[2];
    Eterm dst = db((tmp_packed1>>BEAM_LOOSE_SHIFT));
    Eterm* dst_ptr = REG_TARGET_PTR(dst);
    Eterm increment_val = I[1];
    Uint live;
    Eterm result;

    if (ERTS_LIKELY(is_small(increment_reg_val))) {
      Sint i = signed_val(increment_reg_val) + increment_val;
      if (ERTS_LIKELY(IS_SSMALL(i))) {
        *dst_ptr = make_small(i);
        SET_I((BeamInstr *) I+3);
        Goto(*I);;
      }
    }
    live = tb(tmp_packed1&BEAM_LOOSE_MASK);
    HEAVY_SWAPOUT;
    reg[live] = increment_reg_val;
    reg[live+1] = make_small(increment_val);
    result = erts_gc_mixed_plus(c_p, reg, live);
    HEAVY_SWAPIN;
    ERTS_HOLE_CHECK(c_p);
    if (ERTS_LIKELY(is_value(result))) {
      dst_ptr = REG_TARGET_PTR(dst);
      *dst_ptr = result;
      SET_I((BeamInstr *) I+3);
      Goto(*I);;
    }
    ASSERT(c_p->freason != BADMATCH || is_value(c_p->fvalue));
    goto find_func_info;
  }

}

OpCase(i_int_bnot_jStd):
{
  Eterm tmp_packed1 = I[2];
  Eterm dst = db((tmp_packed1>>(2*BEAM_TIGHT_SHIFT)));
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  Eterm bnot_val = Sb(tmp_packed1&BEAM_TIGHT_MASK);
  if (ERTS_LIKELY(is_small(bnot_val))) {
    bnot_val = make_small(~signed_val(bnot_val));
  } else {
    Uint live = tb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK);
    HEAVY_SWAPOUT;
    reg[live] = bnot_val;
    bnot_val = erts_gc_bnot(c_p, reg, live);
    HEAVY_SWAPIN;
    ERTS_HOLE_CHECK(c_p);
    if (ERTS_UNLIKELY(is_nil(bnot_val))) {
      if (ERTS_LIKELY(I[1])) {
        ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
        I += I[1] + 0;;
        Goto(*I);;
      }
      reg[0] = reg[live];
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_bnot_1]->info.mfa);
      goto post_error_handling;;
    }
    dst_ptr = REG_TARGET_PTR(dst);
  }
  *dst_ptr = bnot_val;
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_int_div_jtssd):
{
  Eterm tmp_packed1 = I[2];
  Eterm targ1;
  Eterm targ2;
  Eterm dst = db((tmp_packed1>>BEAM_LOOSE_SHIFT));
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  GetR(2, targ1);
  GetR(3, targ2);
  {
    Eterm op1 = targ1;
    Eterm op2 = targ2;
    if (ERTS_UNLIKELY(op2 == SMALL_ZERO)) {
      c_p->freason = BADARITH;
      if (ERTS_LIKELY(I[1])) {
        ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
        I += I[1] + 0;;
        Goto(*I);;
      }
      reg[0] = op1;
      reg[1] = op2;
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_intdiv_2]->info.mfa);
      goto post_error_handling;;
    } else if (ERTS_LIKELY(is_both_small(op1, op2))) {
      Sint ires = signed_val(op1) / signed_val(op2);
      if (ERTS_LIKELY(IS_SSMALL(ires))) {
        *dst_ptr = make_small(ires);
        SET_I((BeamInstr *) I+5);
        Goto(*I);;
      }
    }
    do {
      Eterm result;
      Uint live = tb(tmp_packed1&BEAM_LOOSE_MASK);
      HEAVY_SWAPOUT;
      reg[live] = op1;
      reg[live+1] = op2;
      result = erts_gc_int_div (c_p, reg, live);
      HEAVY_SWAPIN;
      ERTS_HOLE_CHECK(c_p);
      if (ERTS_LIKELY(is_value(result))) {
        dst_ptr = REG_TARGET_PTR(dst);
        *dst_ptr = result;
        SET_I((BeamInstr *) I+5);
        Goto(*I);;
      }
      if (ERTS_LIKELY(I[1])) {
        ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
        I += I[1] + 0;;
        Goto(*I);;
      }
      reg[0] = reg[live];
      reg[1] = reg[live+1];
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_intdiv_2]->info.mfa);
      goto post_error_handling;;
    } while (0);
  }
}

OpCase(i_is_eq_exact_immed_frc):
{
  if (r(0) != I[2]) {
    ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
    I += I[1] + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_is_eq_exact_immed_fxc):
{
  Eterm tmp_packed1 = I[1];
  if (xb((tmp_packed1>>BEAM_WIDE_SHIFT)) != I[2]) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_is_eq_exact_immed_fyc):
{
  Eterm tmp_packed1 = I[1];
  if (yb((tmp_packed1>>BEAM_WIDE_SHIFT)) != I[2]) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_is_eq_exact_literal_fxc):
{
  Eterm tmp_packed1 = I[1];
  Eterm src = xb((tmp_packed1>>BEAM_WIDE_SHIFT));
  if (is_immed(src) || !eq(src, I[2])) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_is_eq_exact_literal_fyc):
{
  Eterm tmp_packed1 = I[1];
  Eterm src = yb((tmp_packed1>>BEAM_WIDE_SHIFT));
  if (is_immed(src) || !eq(src, I[2])) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_is_ne_exact_immed_fxc):
{
  Eterm tmp_packed1 = I[1];
  if (xb((tmp_packed1>>BEAM_WIDE_SHIFT)) == I[2]) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_is_ne_exact_immed_fyc):
{
  Eterm tmp_packed1 = I[1];
  if (yb((tmp_packed1>>BEAM_WIDE_SHIFT)) == I[2]) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_is_ne_exact_literal_fxc):
{
  Eterm tmp_packed1 = I[1];
  Eterm src = xb((tmp_packed1>>BEAM_WIDE_SHIFT));
  if (!is_immed(src) && eq(src, I[2])) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_is_ne_exact_literal_fyc):
{
  Eterm tmp_packed1 = I[1];
  Eterm src = yb((tmp_packed1>>BEAM_WIDE_SHIFT));
  if (!is_immed(src) && eq(src, I[2])) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

{
  Eterm index;
  OpCase(i_jump_on_val_xfIW):
  {
    index = xb(I[1]);
  }
  goto jump_on_val__execute;

  OpCase(i_jump_on_val_yfIW):
  {
    index = yb(I[1]);
  }
  goto jump_on_val__execute;

  jump_on_val__execute:
  {
    Eterm tmp_packed1 = I[2];
    if (is_small(index)) {
      index = (Uint) (signed_val(index) - I[3]);
      if (index < Ib((tmp_packed1>>BEAM_WIDE_SHIFT))) {
        Sint32* jump_tab = (Sint32 *) (I+4);
        ASSERT(VALID_INSTR(*(I + (jump_tab[index]) + 0)));
        I += jump_tab[index] + 0;;
        Goto(*I);;
      }
    }
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;;
  }

}

{
  Eterm index;
  OpCase(i_jump_on_val_zero_xfI):
  {
    index = xb(I[1]);
  }
  goto jump_on_val_zero__execute;

  OpCase(i_jump_on_val_zero_yfI):
  {
    index = yb(I[1]);
  }
  goto jump_on_val_zero__execute;

  jump_on_val_zero__execute:
  {
    Eterm tmp_packed1 = I[2];
    if (is_small(index)) {
      index = (Uint) (signed_val(index) - 0);
      if (index < Ib((tmp_packed1>>BEAM_WIDE_SHIFT))) {
        Sint32* jump_tab = (Sint32 *) (I+3);
        ASSERT(VALID_INSTR(*(I + (jump_tab[index]) + 0)));
        I += jump_tab[index] + 0;;
        Goto(*I);;
      }
    }
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;;
  }

}

OpCase(i_loop_rec_f):
{

  /*
  * Pick up the next message and place it in x(0).
  * If no message, jump to a wait or wait_timeout instruction.
  */

  ErtsMessage* msgp;

  /* Entry point from recv_set */
  loop_rec_top__:

  /*
  * We need to disable GC while matching messages
  * in the queue. This since messages with data outside
  * the heap will be corrupted by a GC.
  */
  ASSERT(!(c_p->flags & F_DELAY_GC));
  c_p->flags |= F_DELAY_GC;

  /* Entry point from loop_rec_end (and locally) */
  loop_rec__:

  if (FCALLS <= 0 && FCALLS <= neg_o_reds) {
    c_p->i = I;
    ASSERT(VALID_INSTR(*c_p->i));;
    c_p->flags &= ~F_DELAY_GC;
    SWAPOUT;
    c_p->arity = 0;
    c_p->current = NULL;
    goto do_schedule;
  }

  ASSERT(!ERTS_PROC_IS_EXITING(c_p));

  PROCESS_MAIN_CHK_LOCKS(c_p);

  msgp = PEEK_MESSAGE(c_p);

  if (ERTS_UNLIKELY(msgp == NULL)) {
    int get_out;
    SWAPOUT;
    c_p->i = I;
    ASSERT(VALID_INSTR(*c_p->i));;
    c_p->arity = 0;
    c_p->current = NULL;
    FCALLS -= erts_proc_sig_receive_helper(c_p, FCALLS, neg_o_reds,
    &msgp, &get_out);
    SWAPIN;
    if (ERTS_UNLIKELY(msgp == NULL)) {
      if (get_out) {
        if (get_out < 0) {
          ASSERT(FCALLS <= 0 && FCALLS <= neg_o_reds);
          goto loop_rec__; /* yield */
        }
        else {
          ASSERT(ERTS_PROC_IS_EXITING(c_p));
          goto do_schedule; /* exit */
        }
      }

      /*
      * If there are no more messages in queue
      * (and we are not yielding or exiting)
      * erts_proc_sig_receive_helper()
      * returns with message queue lock locked...
      */
      c_p->flags &= ~F_DELAY_GC;
      ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
      I += I[1] + 0;;
      Goto(*I);		/* Jump to a wait or wait_timeout instruction */
    }
  }

  ASSERT(msgp == PEEK_MESSAGE(c_p));
  ASSERT(msgp && ERTS_SIG_IS_MSG(msgp));

  if (ERTS_UNLIKELY(ERTS_SIG_IS_EXTERNAL_MSG(msgp))) {
    FCALLS -= 10; /* FIXME: bump appropriate amount... */
    SWAPOUT; /* erts_decode_dist_message() may write to heap... */
    if (!erts_decode_dist_message(c_p, ERTS_PROC_LOCK_MAIN, msgp, 0)) {
      /*
      * A corrupt distribution message that we weren't able to decode;
      * remove it...
      */
      /* No swapin should be needed */
      ASSERT(HTOP == c_p->htop && E == c_p->stop);
      /* TODO: Add DTrace probe for this bad message situation? */
      UNLINK_MESSAGE(c_p, msgp);
      msgp->next = NULL;
      erts_cleanup_messages(msgp);
      goto loop_rec__;
    }
    SWAPIN;
  }

  ASSERT(msgp == PEEK_MESSAGE(c_p));
  ASSERT(ERTS_SIG_IS_INTERNAL_MSG(msgp));

  r(0) = ERL_MESSAGE_TERM(msgp);
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_m_div_jtssd):
{
  Eterm tmp_packed1 = I[2];
  Eterm targ1;
  Eterm targ2;
  Eterm dst = db((tmp_packed1>>BEAM_LOOSE_SHIFT));
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  GetR(2, targ1);
  GetR(3, targ2);
  {
    Eterm op1 = targ1;
    Eterm op2 = targ2;
    do {
      Eterm result;
      Uint live = tb(tmp_packed1&BEAM_LOOSE_MASK);
      HEAVY_SWAPOUT;
      reg[live] = op1;
      reg[live+1] = op2;
      result = erts_gc_mixed_div (c_p, reg, live);
      HEAVY_SWAPIN;
      ERTS_HOLE_CHECK(c_p);
      if (ERTS_LIKELY(is_value(result))) {
        dst_ptr = REG_TARGET_PTR(dst);
        *dst_ptr = result;
        SET_I((BeamInstr *) I+5);
        Goto(*I);;
      }
      if (ERTS_LIKELY(I[1])) {
        ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
        I += I[1] + 0;;
        Goto(*I);;
      }
      reg[0] = reg[live];
      reg[1] = reg[live+1];
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_div_2]->info.mfa);
      goto post_error_handling;;
    } while (0);
  }
}

{
  Eterm MinusOp1, MinusOp2;
  OpCase(i_minus_ssjtd):
  {
    Eterm targ1;
    Eterm targ2;
    GetR(0, targ1);
    GetR(1, targ2);
    {
      MinusOp1 = targ1;
      MinusOp2 = targ2;
    }
  }
  I += 1;
  goto minus__execute;

  OpCase(i_minus_xxjtd):
  {
    Eterm tmp_packed1 = I[1];
    MinusOp1 = xb(tmp_packed1&BEAM_LOOSE_MASK);
    MinusOp2 = xb((tmp_packed1>>BEAM_LOOSE_SHIFT));
  }
  goto minus__execute;

  minus__execute:
  {
    Eterm tmp_packed1 = I[3];
    Eterm dst = db((tmp_packed1>>BEAM_LOOSE_SHIFT));
    Eterm* dst_ptr = REG_TARGET_PTR(dst);
    if (ERTS_LIKELY(is_both_small(MinusOp1, MinusOp2))) {
      Sint i = signed_val(MinusOp1) - signed_val(MinusOp2);
      if (ERTS_LIKELY(IS_SSMALL(i))) {
        *dst_ptr = make_small(i);
        SET_I((BeamInstr *) I+4);
        Goto(*I);;
      }
    }
    do {
      Eterm result;
      Uint live = tb(tmp_packed1&BEAM_LOOSE_MASK);
      HEAVY_SWAPOUT;
      reg[live] = MinusOp1;
      reg[live+1] = MinusOp2;
      result = erts_gc_mixed_minus (c_p, reg, live);
      HEAVY_SWAPIN;
      ERTS_HOLE_CHECK(c_p);
      if (ERTS_LIKELY(is_value(result))) {
        dst_ptr = REG_TARGET_PTR(dst);
        *dst_ptr = result;
        SET_I((BeamInstr *) I+4);
        Goto(*I);;
      }
      if (ERTS_LIKELY(I[2])) {
        ASSERT(VALID_INSTR(*(I + (I[2]) + 0)));
        I += I[2] + 0;;
        Goto(*I);;
      }
      reg[0] = reg[live];
      reg[1] = reg[live+1];
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_sminus_2]->info.mfa);
      goto post_error_handling;;
    } while (0);
  }

}

OpCase(i_move_call_ext_ce):
{
  x(0) = I[1];
  SET_CP(c_p, I+3);
  DTRACE_GLOBAL_CALL_FROM_EXPORT(c_p, I[2]);
  // Dispatchx assumes the Export* is in Arg(0)
  I = (&I[2]) - 1;
  Dispatchx();;;
}

OpCase(i_move_call_ext_last_eQc):
{
  x(0) = I[3];
  SET_CP(c_p, (BeamInstr *) cp_val(*E));
  E = ADD_BYTE_OFFSET(E, I[2]);;
  DTRACE_GLOBAL_CALL_FROM_EXPORT(c_p, I[1]);
  // Dispatchx assumes the Export* is in Arg(0)
  I = (&I[1]) - 1;
  Dispatchx();;;
}

OpCase(i_move_call_ext_only_ec):
{
  x(0) = I[2];
  DTRACE_GLOBAL_CALL_FROM_EXPORT(c_p, I[1]);
  // Dispatchx assumes the Export* is in Arg(0)
  I = (&I[1]) - 1;
  Dispatchx();;;
}

OpCase(i_new_small_map_lit_dtq):
{
  Eterm tmp_packed1 = I[1];
  Eterm dst = db(tmp_packed1&BEAM_LOOSE_MASK);
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  Eterm res;
  Uint n;
  Eterm keys = I[2];

  HEAVY_SWAPOUT;
  res = erts_gc_new_small_map_lit(c_p, reg, keys, tb((tmp_packed1>>BEAM_LOOSE_SHIFT)), I+3);
  HEAVY_SWAPIN;
  dst_ptr = REG_TARGET_PTR(dst);
  *dst_ptr = res;
  n = arityval(*tuple_val(keys));
  SET_I((BeamInstr *) I+3+n);
  Goto(*I);;
}

{
  Eterm PlusOp1, PlusOp2;
  OpCase(i_plus_ssjtd):
  {
    Eterm targ1;
    Eterm targ2;
    GetR(0, targ1);
    GetR(1, targ2);
    {
      PlusOp1 = targ1;
      PlusOp2 = targ2;
    }
  }
  I += 1;
  goto plus__execute;

  OpCase(i_plus_xxjtd):
  {
    Eterm tmp_packed1 = I[1];
    PlusOp1 = xb(tmp_packed1&BEAM_LOOSE_MASK);
    PlusOp2 = xb((tmp_packed1>>BEAM_LOOSE_SHIFT));
  }
  goto plus__execute;

  OpCase(i_plus_xyjtd):
  {
    Eterm tmp_packed1 = I[1];
    PlusOp1 = xb(tmp_packed1&BEAM_LOOSE_MASK);
    PlusOp2 = yb((tmp_packed1>>BEAM_LOOSE_SHIFT));
  }
  goto plus__execute;

  plus__execute:
  {
    Eterm tmp_packed1 = I[3];
    Eterm dst = db((tmp_packed1>>BEAM_LOOSE_SHIFT));
    Eterm* dst_ptr = REG_TARGET_PTR(dst);
    if (ERTS_LIKELY(is_both_small(PlusOp1, PlusOp2))) {
      Sint i = signed_val(PlusOp1) + signed_val(PlusOp2);
      if (ERTS_LIKELY(IS_SSMALL(i))) {
        *dst_ptr = make_small(i);
        SET_I((BeamInstr *) I+4);
        Goto(*I);;
      }
    }
    do {
      Eterm result;
      Uint live = tb(tmp_packed1&BEAM_LOOSE_MASK);
      HEAVY_SWAPOUT;
      reg[live] = PlusOp1;
      reg[live+1] = PlusOp2;
      result = erts_gc_mixed_plus (c_p, reg, live);
      HEAVY_SWAPIN;
      ERTS_HOLE_CHECK(c_p);
      if (ERTS_LIKELY(is_value(result))) {
        dst_ptr = REG_TARGET_PTR(dst);
        *dst_ptr = result;
        SET_I((BeamInstr *) I+4);
        Goto(*I);;
      }
      if (ERTS_LIKELY(I[2])) {
        ASSERT(VALID_INSTR(*(I + (I[2]) + 0)));
        I += I[2] + 0;;
        Goto(*I);;
      }
      reg[0] = reg[live];
      reg[1] = reg[live+1];
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_splus_2]->info.mfa);
      goto post_error_handling;;
    } while (0);
  }

}

{
  OpCase(i_put_tuple_xI):
  {
    xb(I[1]) = make_tuple(HTOP);
  }
  goto i_put_tuple__fill;

  OpCase(i_put_tuple_yI):
  {
    yb(I[1]) = make_tuple(HTOP);
  }
  goto i_put_tuple__fill;

  i_put_tuple__fill:
  {
    Eterm* hp = HTOP;
    Eterm arity = I[2];

    *hp++ = make_arityval(arity);
    I = I+3;
    do {
      Eterm term = *I++;
      switch (loader_tag(term)) {
        case LOADER_X_REG:
        *hp++ = x(loader_x_reg_index(term));
        break;
        case LOADER_Y_REG:
        *hp++ = y(loader_y_reg_index(term));
        break;
        default:
        *hp++ = term;
        break;
      }
    } while (--arity != 0);
    HTOP = hp;
    ASSERT(VALID_INSTR(* (Eterm *)I));
    Goto(*I);
  }

}

OpCase(i_recv_mark):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  /*
  * Save the current end of message queue
  */
  ERTS_RECV_MARK_SAVE(c_p);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(i_recv_set):
{
  /*
  * If previously saved recv mark, set peek position to it
  */
  ERTS_RECV_MARK_SET(c_p);
  SET_I(I+1);
  goto loop_rec_top__;

}

{
  Eterm RemOp1, RemOp2;
  OpCase(i_rem_ssjtd):
  {
    Eterm targ1;
    Eterm targ2;
    GetR(0, targ1);
    GetR(1, targ2);
    {
      RemOp1 = targ1;
      RemOp2 = targ2;
    }
  }
  I += 1;
  goto rem__execute;

  OpCase(i_rem_xxjtd):
  {
    Eterm tmp_packed1 = I[1];
    RemOp1 = xb(tmp_packed1&BEAM_LOOSE_MASK);
    RemOp2 = xb((tmp_packed1>>BEAM_LOOSE_SHIFT));
  }
  goto rem__execute;

  rem__execute:
  {
    Eterm tmp_packed1 = I[3];
    Eterm dst = db((tmp_packed1>>BEAM_LOOSE_SHIFT));
    Eterm* dst_ptr = REG_TARGET_PTR(dst);
    if (ERTS_UNLIKELY(RemOp2 == SMALL_ZERO)) {
      c_p->freason = BADARITH;
      if (ERTS_LIKELY(I[2])) {
        ASSERT(VALID_INSTR(*(I + (I[2]) + 0)));
        I += I[2] + 0;;
        Goto(*I);;
      }
      reg[0] = RemOp1;
      reg[1] = RemOp2;
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_rem_2]->info.mfa);
      goto post_error_handling;;
    } else if (ERTS_LIKELY(is_both_small(RemOp1, RemOp2))) {
      *dst_ptr = make_small(signed_val(RemOp1) % signed_val(RemOp2));
      SET_I((BeamInstr *) I+4);
      Goto(*I);;
    } else {
      do {
        Eterm result;
        Uint live = tb(tmp_packed1&BEAM_LOOSE_MASK);
        HEAVY_SWAPOUT;
        reg[live] = RemOp1;
        reg[live+1] = RemOp2;
        result = erts_gc_int_rem (c_p, reg, live);
        HEAVY_SWAPIN;
        ERTS_HOLE_CHECK(c_p);
        if (ERTS_LIKELY(is_value(result))) {
          dst_ptr = REG_TARGET_PTR(dst);
          *dst_ptr = result;
          SET_I((BeamInstr *) I+4);
          Goto(*I);;
        }
        if (ERTS_LIKELY(I[2])) {
          ASSERT(VALID_INSTR(*(I + (I[2]) + 0)));
          I += I[2] + 0;;
          Goto(*I);;
        }
        reg[0] = reg[live];
        reg[1] = reg[live+1];
        SWAPOUT;
        I = handle_error(c_p, I, reg, &bif_export[BIF_rem_2]->info.mfa);
        goto post_error_handling;;
      } while (0);
    }
  }

}

{
  Eterm select_val2;
  OpCase(i_select_tuple_arity2_xfAA):
  {
    select_val2 = xb(I[1]);
  }
  goto select_val2__get_arity;

  OpCase(i_select_tuple_arity2_yfAA):
  {
    select_val2 = yb(I[1]);
  }
  goto select_val2__get_arity;

  OpCase(i_select_val2_xfcc):
  {
    select_val2 = xb(I[1]);
  }
  goto select_val2__execute;

  OpCase(i_select_val2_yfcc):
  {
    select_val2 = yb(I[1]);
  }
  goto select_val2__execute;

  select_val2__get_arity:
  {
    if (ERTS_LIKELY(is_tuple(select_val2))) {
      select_val2 = *tuple_val(select_val2);
    } else {
      select_val2 = NIL;
    }
  }
  goto select_val2__execute;

  select_val2__execute:
  {
    Sint32* jump_tab = (Sint32 *) (I+5);

    if (select_val2 == I[3]) {
      ASSERT(VALID_INSTR(*(I + (jump_tab[0]) + 0)));
      I += jump_tab[0] + 0;;
      Goto(*I);;
    } else if (select_val2 == I[4]) {
      ASSERT(VALID_INSTR(*(I + (jump_tab[1]) + 0)));
      I += jump_tab[1] + 0;;
      Goto(*I);;
    } else {
      ASSERT(VALID_INSTR(*(I + (I[2]) + 0)));
      I += I[2] + 0;;
      Goto(*I);;
    }
  }

}

{
  Eterm select_val;
  OpCase(i_select_tuple_arity_xfI):
  {
    select_val = xb(I[1]);
  }
  goto select_val_lin__get_arity;

  OpCase(i_select_tuple_arity_yfI):
  {
    select_val = yb(I[1]);
  }
  goto select_val_lin__get_arity;

  OpCase(i_select_val_lins_xfI):
  {
    select_val = xb(I[1]);
  }
  goto select_val_lin__execute;

  OpCase(i_select_val_lins_yfI):
  {
    select_val = yb(I[1]);
  }
  goto select_val_lin__execute;

  select_val_lin__get_arity:
  {
    if (ERTS_LIKELY(is_tuple(select_val))) {
      select_val = *tuple_val(select_val);
    } else {
      select_val = NIL;
    }
  }
  goto select_val_lin__execute;

  select_val_lin__execute:
  {
    Eterm tmp_packed1 = I[2];
    BeamInstr* vs = I+3;
    int ix = 0;

    for (;;) {
      if (vs[ix+0] >= select_val) {
        ix += 0;
        break;
      }
      if (vs[ix+1] >= select_val) {
        ix += 1;
        break;
      }
      ix += 2;
    }

    if (vs[ix] == select_val) {
      Sint32* jump_tab = (Sint32 *) (I+3 + Ib((tmp_packed1>>BEAM_WIDE_SHIFT)));
      Eterm offset = jump_tab[ix];
      ASSERT(VALID_INSTR(*(I + (offset) + 0)));
      I += offset + 0;;
      Goto(*I);;
    } else {
      ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
      I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
      Goto(*I);;
    }
  }

}

{
  Eterm select_val;
  OpCase(i_select_val_bins_xfI):
  {
    select_val = xb(I[1]);
  }
  goto select_val_bins__select;

  OpCase(i_select_val_bins_yfI):
  {
    select_val = yb(I[1]);
  }
  goto select_val_bins__select;

  select_val_bins__select:
  {
    Eterm tmp_packed1 = I[2];
    struct Singleton {
      BeamInstr val;
    };
    struct Singleton* low;
    struct Singleton* high;
    struct Singleton* mid;
    int bdiff; /* int not long because the arrays aren't that large */

    low = (struct Singleton *) (I+3);
    high = low + Ib((tmp_packed1>>BEAM_WIDE_SHIFT));

    /* The pointer subtraction (high-low) below must produce
    * a signed result, because high could be < low. That
    * requires the compiler to insert quite a bit of code.
    *
    * However, high will be > low so the result will be
    * positive. We can use that knowledge to optimise the
    * entire sequence, from the initial comparison to the
    * computation of mid.
    *
    * -- Mikael Pettersson, Acumem AB
    *
    * Original loop control code:
    *
    * while (low < high) {
      *    mid = low + (high-low) / 2;
      *
      */
      while ((bdiff = (int)((char*)high - (char*)low)) > 0) {
        unsigned int boffset = ((unsigned int)bdiff >> 1) & ~(sizeof(struct Singleton)-1);

        mid = (struct Singleton*)((char*)low + boffset);
        if (select_val < mid->val) {
          high = mid;
        } else if (select_val > mid->val) {
          low = mid + 1;
        } else {
          Sint32* jump_tab = (Sint32 *) (I+3 + Ib((tmp_packed1>>BEAM_WIDE_SHIFT)));
          Sint32 offset = jump_tab[mid - (struct Singleton *)(I+3)];
          ASSERT(VALID_INSTR(*(I + (offset) + 0)));
          I += offset + 0;;
          Goto(*I);;
        }
      }
      ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
      I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
      Goto(*I);;
    }

  }

OpCase(i_times_jtssd):
{
  Eterm tmp_packed1 = I[2];
  Eterm targ1;
  Eterm targ2;
  Eterm dst = db((tmp_packed1>>BEAM_LOOSE_SHIFT));
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  GetR(2, targ1);
  GetR(3, targ2);
  {
    Eterm op1 = targ1;
    Eterm op2 = targ2;
    do {
      Eterm result;
      Uint live = tb(tmp_packed1&BEAM_LOOSE_MASK);
      HEAVY_SWAPOUT;
      reg[live] = op1;
      reg[live+1] = op2;
      result = erts_gc_mixed_times (c_p, reg, live);
      HEAVY_SWAPIN;
      ERTS_HOLE_CHECK(c_p);
      if (ERTS_LIKELY(is_value(result))) {
        dst_ptr = REG_TARGET_PTR(dst);
        *dst_ptr = result;
        SET_I((BeamInstr *) I+5);
        Goto(*I);;
      }
      if (ERTS_LIKELY(I[1])) {
        ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
        I += I[1] + 0;;
        Goto(*I);;
      }
      reg[0] = reg[live];
      reg[1] = reg[live+1];
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_stimes_2]->info.mfa);
      goto post_error_handling;;
    } while (0);
  }
}

OpCase(i_trim_t):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Uint cp = E[0];
  E += I[1];
  E[0] = cp;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(init2_yy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  make_blank(yb(tmp_packed1&BEAM_LOOSE_MASK));
  make_blank(yb((tmp_packed1>>BEAM_LOOSE_SHIFT)));
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(init3_yyy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  make_blank(yb(tmp_packed1&BEAM_TIGHT_MASK));
  make_blank(yb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK));
  make_blank(yb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))));
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(init_y):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  make_blank(yb(I[1]));
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(is_atom_fx):
{
  Eterm tmp_packed1 = I[1];
  if (is_not_atom(xb((tmp_packed1>>BEAM_WIDE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_binary_fx):
{
  Eterm tmp_packed1 = I[1];
  if (is_not_binary(xb((tmp_packed1>>BEAM_WIDE_SHIFT))) || binary_bitsize(xb((tmp_packed1>>BEAM_WIDE_SHIFT))) != 0) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_bitstring_fx):
{
  Eterm tmp_packed1 = I[1];
  if (is_not_binary(xb((tmp_packed1>>BEAM_WIDE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_eq_exact_fxx):
{
  Eterm tmp_packed1 = I[2];
  if (!EQ(xb(tmp_packed1&BEAM_LOOSE_MASK), xb((tmp_packed1>>BEAM_LOOSE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
    I += I[1] + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_eq_exact_fxy):
{
  Eterm tmp_packed1 = I[2];
  if (!EQ(xb(tmp_packed1&BEAM_LOOSE_MASK), yb((tmp_packed1>>BEAM_LOOSE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
    I += I[1] + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_eq_exact_fyy):
{
  Eterm tmp_packed1 = I[2];
  if (!EQ(yb(tmp_packed1&BEAM_LOOSE_MASK), yb((tmp_packed1>>BEAM_LOOSE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
    I += I[1] + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_eq_fss):
{
  Eterm targ1;
  Eterm targ2;
  GetR(1, targ1);
  GetR(2, targ2);
  {
    CMP_EQ_ACTION(targ1, targ2, ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
    I += I[1] + 0;;
    Goto(*I););
    I += 4;
    ASSERT(VALID_INSTR(*I));
    Goto(*I);
  }
}

OpCase(is_float_fx):
{
  Eterm tmp_packed1 = I[1];
  if (is_not_float(xb((tmp_packed1>>BEAM_WIDE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_function2_fSs):
{
  Eterm tmp_packed1 = I[1];
  Eterm targ1;
  GetR(1, targ1);
  {
    if (erl_is_function(c_p, Sb((tmp_packed1>>BEAM_WIDE_SHIFT)), targ1) != am_true ) {
      ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
      I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
      Goto(*I);;
    }
    I += 3;
    ASSERT(VALID_INSTR(*I));
    Goto(*I);
  }
}

OpCase(is_function_fx):
{
  Eterm tmp_packed1 = I[1];
  if ( !(is_any_fun(xb((tmp_packed1>>BEAM_WIDE_SHIFT)))) ) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_function_fy):
{
  Eterm tmp_packed1 = I[1];
  if ( !(is_any_fun(yb((tmp_packed1>>BEAM_WIDE_SHIFT)))) ) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_ge_fcx):
{
  Eterm tmp_packed1 = I[1];
  CMP_GE_ACTION(I[2], xb((tmp_packed1>>BEAM_WIDE_SHIFT)), ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
  I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
  Goto(*I););
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_ge_fxc):
{
  Eterm tmp_packed1 = I[1];
  CMP_GE_ACTION(xb((tmp_packed1>>BEAM_WIDE_SHIFT)), I[2], ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
  I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
  Goto(*I););
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_ge_fxx):
{
  Eterm tmp_packed1 = I[2];
  CMP_GE_ACTION(xb(tmp_packed1&BEAM_LOOSE_MASK), xb((tmp_packed1>>BEAM_LOOSE_SHIFT)), ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
  I += I[1] + 0;;
  Goto(*I););
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_integer_allocate_fxtt):
{
  Eterm tmp_packed1 = I[2];
  if (is_not_integer(xb(tmp_packed1&BEAM_TIGHT_MASK))) {
    ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
    I += I[1] + 0;;
    Goto(*I);;
  };
  do {
    unsigned needed = tb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) + 1;
    do {
      Uint need = 0 + needed;
      if (ERTS_UNLIKELY(E - HTOP < need)) {
        SWAPOUT;
        PROCESS_MAIN_CHK_LOCKS(c_p);
        FCALLS -= erts_garbage_collect_nobump(c_p, need, reg, tb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))), FCALLS);
        ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        SWAPIN;
      }
      HEAP_SPACE_VERIFIED(0);
    } while (0);
    E -= needed;
    *E = make_cp(c_p->cp);
    c_p->cp = 0;
  } while (0);
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_integer_fx):
{
  Eterm tmp_packed1 = I[1];
  if (is_not_integer(xb((tmp_packed1>>BEAM_WIDE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_integer_fy):
{
  Eterm tmp_packed1 = I[1];
  if (is_not_integer(yb((tmp_packed1>>BEAM_WIDE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_list_fx):
{
  Eterm tmp_packed1 = I[1];
  if (is_not_list(xb((tmp_packed1>>BEAM_WIDE_SHIFT))) && is_not_nil(xb((tmp_packed1>>BEAM_WIDE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_lt_fcx):
{
  Eterm tmp_packed1 = I[1];
  CMP_LT_ACTION(I[2], xb((tmp_packed1>>BEAM_WIDE_SHIFT)), ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
  I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
  Goto(*I););
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_lt_fxc):
{
  Eterm tmp_packed1 = I[1];
  CMP_LT_ACTION(xb((tmp_packed1>>BEAM_WIDE_SHIFT)), I[2], ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
  I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
  Goto(*I););
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_lt_fxx):
{
  Eterm tmp_packed1 = I[2];
  CMP_LT_ACTION(xb(tmp_packed1&BEAM_LOOSE_MASK), xb((tmp_packed1>>BEAM_LOOSE_SHIFT)), ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
  I += I[1] + 0;;
  Goto(*I););
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_map_fx):
{
  Eterm tmp_packed1 = I[1];
  if (is_not_map(xb((tmp_packed1>>BEAM_WIDE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_map_fy):
{
  Eterm tmp_packed1 = I[1];
  if (is_not_map(yb((tmp_packed1>>BEAM_WIDE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_ne_exact_fSS):
{
  Eterm tmp_packed1 = I[2];
  if (EQ(Sb(tmp_packed1&BEAM_LOOSE_MASK), Sb((tmp_packed1>>BEAM_LOOSE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
    I += I[1] + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_ne_fss):
{
  Eterm targ1;
  Eterm targ2;
  GetR(1, targ1);
  GetR(2, targ2);
  {
    CMP_NE_ACTION(targ1, targ2, ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
    I += I[1] + 0;;
    Goto(*I););
    I += 4;
    ASSERT(VALID_INSTR(*I));
    Goto(*I);
  }
}

OpCase(is_nil_fx):
{
  Eterm tmp_packed1 = I[1];
  if (is_not_nil(xb((tmp_packed1>>BEAM_WIDE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_nil_fy):
{
  Eterm tmp_packed1 = I[1];
  if (is_not_nil(yb((tmp_packed1>>BEAM_WIDE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_nonempty_list_allocate_frtt):
{
  Eterm tmp_packed1 = I[2];
  if (is_not_list(r(0))) {
    ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
    I += I[1] + 0;;
    Goto(*I);;
  };
  do {
    unsigned needed = tb(tmp_packed1&BEAM_LOOSE_MASK) + 1;
    do {
      Uint need = 0 + needed;
      if (ERTS_UNLIKELY(E - HTOP < need)) {
        SWAPOUT;
        PROCESS_MAIN_CHK_LOCKS(c_p);
        FCALLS -= erts_garbage_collect_nobump(c_p, need, reg, tb((tmp_packed1>>BEAM_LOOSE_SHIFT)), FCALLS);
        ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        SWAPIN;
      }
      HEAP_SPACE_VERIFIED(0);
    } while (0);
    E -= needed;
    *E = make_cp(c_p->cp);
    c_p->cp = 0;
  } while (0);
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_nonempty_list_allocate_fxtt):
{
  Eterm tmp_packed1 = I[2];
  if (is_not_list(xb(tmp_packed1&BEAM_TIGHT_MASK))) {
    ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
    I += I[1] + 0;;
    Goto(*I);;
  };
  do {
    unsigned needed = tb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) + 1;
    do {
      Uint need = 0 + needed;
      if (ERTS_UNLIKELY(E - HTOP < need)) {
        SWAPOUT;
        PROCESS_MAIN_CHK_LOCKS(c_p);
        FCALLS -= erts_garbage_collect_nobump(c_p, need, reg, tb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))), FCALLS);
        ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        SWAPIN;
      }
      HEAP_SPACE_VERIFIED(0);
    } while (0);
    E -= needed;
    *E = make_cp(c_p->cp);
    c_p->cp = 0;
  } while (0);
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_nonempty_list_fx):
{
  Eterm tmp_packed1 = I[1];
  if (is_not_list(xb((tmp_packed1>>BEAM_WIDE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_nonempty_list_fy):
{
  Eterm tmp_packed1 = I[1];
  if (is_not_list(yb((tmp_packed1>>BEAM_WIDE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_nonempty_list_get_list_frxx):
{
  Eterm tmp_packed1 = I[2];
  if (is_not_list(r(0))) {
    ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
    I += I[1] + 0;;
    Goto(*I);;
  };
  do {
    Eterm* tmp_ptr = list_val(r(0));
    Eterm hd, tl;
    hd = CAR(tmp_ptr);
    tl = CDR(tmp_ptr);
    xb(tmp_packed1&BEAM_LOOSE_MASK) = hd;
    xb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = tl;
  } while (0);
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_nonempty_list_get_list_fxxx):
{
  Eterm tmp_packed1 = I[2];
  if (is_not_list(xb(tmp_packed1&BEAM_TIGHT_MASK))) {
    ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
    I += I[1] + 0;;
    Goto(*I);;
  };
  do {
    Eterm* tmp_ptr = list_val(xb(tmp_packed1&BEAM_TIGHT_MASK));
    Eterm hd, tl;
    hd = CAR(tmp_ptr);
    tl = CDR(tmp_ptr);
    xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = hd;
    xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = tl;
  } while (0);
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_nonempty_list_test_heap_fIt):
{
  Eterm tmp_packed1 = I[2];
  if (is_not_list(x(0))) {
    ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
    I += I[1] + 0;;
    Goto(*I);;
  };
  do {
    Uint need = Ib(tmp_packed1&BEAM_WIDE_MASK) + 0;
    if (ERTS_UNLIKELY(E - HTOP < need)) {
      SWAPOUT;
      PROCESS_MAIN_CHK_LOCKS(c_p);
      FCALLS -= erts_garbage_collect_nobump(c_p, need, reg, tb((tmp_packed1>>BEAM_WIDE_SHIFT)), FCALLS);
      ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
      PROCESS_MAIN_CHK_LOCKS(c_p);
      SWAPIN;
    }
    HEAP_SPACE_VERIFIED(Ib(tmp_packed1&BEAM_WIDE_MASK));
  } while (0);;
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_pid_fx):
{
  Eterm tmp_packed1 = I[1];
  if (is_not_pid(xb((tmp_packed1>>BEAM_WIDE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_port_fx):
{
  Eterm tmp_packed1 = I[1];
  if (is_not_port(xb((tmp_packed1>>BEAM_WIDE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_reference_fx):
{
  Eterm tmp_packed1 = I[1];
  if (is_not_ref(xb((tmp_packed1>>BEAM_WIDE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_tagged_tuple_frAa):
{
  Eterm term = r(0);
  if (!(BEAM_IS_TUPLE(term) &&
  (tuple_val(term))[0] == I[2] &&
  (tuple_val(term))[1] == I[3])) {
    ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
    I += I[1] + 0;;
    Goto(*I);;
  }
  I += 4;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_tagged_tuple_fxAa):
{
  Eterm tmp_packed1 = I[1];
  Eterm term = xb((tmp_packed1>>BEAM_WIDE_SHIFT));
  if (!(BEAM_IS_TUPLE(term) &&
  (tuple_val(term))[0] == I[2] &&
  (tuple_val(term))[1] == I[3])) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 4;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_tagged_tuple_fyAa):
{
  Eterm tmp_packed1 = I[1];
  Eterm term = yb((tmp_packed1>>BEAM_WIDE_SHIFT));
  if (!(BEAM_IS_TUPLE(term) &&
  (tuple_val(term))[0] == I[2] &&
  (tuple_val(term))[1] == I[3])) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 4;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_tuple_fr):
{
  if (is_not_tuple(r(0))) {
    ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
    I += I[1] + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_tuple_fx):
{
  Eterm tmp_packed1 = I[1];
  if (is_not_tuple(xb((tmp_packed1>>BEAM_WIDE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_tuple_fy):
{
  Eterm tmp_packed1 = I[1];
  if (is_not_tuple(yb((tmp_packed1>>BEAM_WIDE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_tuple_of_arity_frA):
{
  Eterm term = r(0);
  if (!(BEAM_IS_TUPLE(term) && *tuple_val(term) == I[2])) {
    ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
    I += I[1] + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_tuple_of_arity_fxA):
{
  Eterm tmp_packed1 = I[1];
  Eterm term = xb((tmp_packed1>>BEAM_WIDE_SHIFT));
  if (!(BEAM_IS_TUPLE(term) && *tuple_val(term) == I[2])) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_tuple_of_arity_fyA):
{
  Eterm tmp_packed1 = I[1];
  Eterm term = yb((tmp_packed1>>BEAM_WIDE_SHIFT));
  if (!(BEAM_IS_TUPLE(term) && *tuple_val(term) == I[2])) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(jump_f):
{
  ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
  I += I[1] + 0;;
  Goto(*I);;
}

OpCase(loop_rec_end_f):
{
  /*
  * Advance the save pointer to the next message (the current
  * message didn't match), then jump to the loop_rec instruction.
  */

  ASSERT(c_p->flags & F_DELAY_GC);

  ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
  I += I[1] + 0;;
  SAVE_MESSAGE(c_p);
  FCALLS--;
  goto loop_rec__;
}

OpCase(move2_par_xxxx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm V1, V2;
  V1 = xb(tmp_packed1&BEAM_LOOSE_MASK);
  V2 = xb((tmp_packed1>>(2*BEAM_LOOSE_SHIFT))&BEAM_LOOSE_MASK);
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)&BEAM_LOOSE_MASK) = V1;
  xb((tmp_packed1>>(3*BEAM_LOOSE_SHIFT))) = V2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move2_par_xxxy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm V1, V2;
  V1 = xb(tmp_packed1&BEAM_LOOSE_MASK);
  V2 = xb((tmp_packed1>>(2*BEAM_LOOSE_SHIFT))&BEAM_LOOSE_MASK);
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)&BEAM_LOOSE_MASK) = V1;
  yb((tmp_packed1>>(3*BEAM_LOOSE_SHIFT))) = V2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move2_par_xxyx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm V1, V2;
  V1 = xb(tmp_packed1&BEAM_LOOSE_MASK);
  V2 = yb((tmp_packed1>>(2*BEAM_LOOSE_SHIFT))&BEAM_LOOSE_MASK);
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)&BEAM_LOOSE_MASK) = V1;
  xb((tmp_packed1>>(3*BEAM_LOOSE_SHIFT))) = V2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move2_par_xyxy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm V1, V2;
  V1 = xb(tmp_packed1&BEAM_LOOSE_MASK);
  V2 = xb((tmp_packed1>>(2*BEAM_LOOSE_SHIFT))&BEAM_LOOSE_MASK);
  yb((tmp_packed1>>BEAM_LOOSE_SHIFT)&BEAM_LOOSE_MASK) = V1;
  yb((tmp_packed1>>(3*BEAM_LOOSE_SHIFT))) = V2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move2_par_yxxx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm V1, V2;
  V1 = yb(tmp_packed1&BEAM_LOOSE_MASK);
  V2 = xb((tmp_packed1>>(2*BEAM_LOOSE_SHIFT))&BEAM_LOOSE_MASK);
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)&BEAM_LOOSE_MASK) = V1;
  xb((tmp_packed1>>(3*BEAM_LOOSE_SHIFT))) = V2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move2_par_yxxy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm V1, V2;
  V1 = yb(tmp_packed1&BEAM_LOOSE_MASK);
  V2 = xb((tmp_packed1>>(2*BEAM_LOOSE_SHIFT))&BEAM_LOOSE_MASK);
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)&BEAM_LOOSE_MASK) = V1;
  yb((tmp_packed1>>(3*BEAM_LOOSE_SHIFT))) = V2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move2_par_yxyx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm V1, V2;
  V1 = yb(tmp_packed1&BEAM_LOOSE_MASK);
  V2 = yb((tmp_packed1>>(2*BEAM_LOOSE_SHIFT))&BEAM_LOOSE_MASK);
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)&BEAM_LOOSE_MASK) = V1;
  xb((tmp_packed1>>(3*BEAM_LOOSE_SHIFT))) = V2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move3_xxxxxx):
{
  Eterm tmp_packed1 = I[1];
  Eterm tmp_packed2 = I[2];
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = xb(tmp_packed1&BEAM_TIGHT_MASK);
  xb(tmp_packed2&BEAM_TIGHT_MASK) = xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT)));
  xb((tmp_packed2>>(2*BEAM_TIGHT_SHIFT))) = xb((tmp_packed2>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK);
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move3_xyxyxy):
{
  Eterm tmp_packed1 = I[1];
  Eterm tmp_packed2 = I[2];
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  yb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = xb(tmp_packed1&BEAM_TIGHT_MASK);
  yb(tmp_packed2&BEAM_TIGHT_MASK) = xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT)));
  yb((tmp_packed2>>(2*BEAM_TIGHT_SHIFT))) = xb((tmp_packed2>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK);
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move3_yxyxyx):
{
  Eterm tmp_packed1 = I[1];
  Eterm tmp_packed2 = I[2];
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = yb(tmp_packed1&BEAM_TIGHT_MASK);
  xb(tmp_packed2&BEAM_TIGHT_MASK) = yb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT)));
  xb((tmp_packed2>>(2*BEAM_TIGHT_SHIFT))) = yb((tmp_packed2>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK);
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_call_cf):
{
  x(0) = I[1];
  SET_CP(c_p, I+3);
  ASSERT(VALID_INSTR(*(I + (I[2]) + 0)));
  I += I[2] + 0;;
  DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
  Dispatch();;
}

OpCase(move_call_last_cfQ):
{
  Eterm tmp_packed1 = I[2];
  x(0) = I[1];
  SET_CP(c_p, (BeamInstr *) cp_val(*E));
  E = ADD_BYTE_OFFSET(E, Qb((tmp_packed1>>BEAM_WIDE_SHIFT)));;
  ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
  I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
  DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
  Dispatch();;;
}

OpCase(move_call_last_xfQ):
{
  Eterm tmp_packed1 = I[1];
  x(0) = xb(tmp_packed1&BEAM_LOOSE_MASK);
  SET_CP(c_p, (BeamInstr *) cp_val(*E));
  E = ADD_BYTE_OFFSET(E, Qb((tmp_packed1>>BEAM_LOOSE_SHIFT)));;
  ASSERT(VALID_INSTR(*(I + (I[2]) + 0)));
  I += I[2] + 0;;
  DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
  Dispatch();;;
}

OpCase(move_call_last_yfQ):
{
  Eterm tmp_packed1 = I[1];
  x(0) = yb(tmp_packed1&BEAM_LOOSE_MASK);
  SET_CP(c_p, (BeamInstr *) cp_val(*E));
  E = ADD_BYTE_OFFSET(E, Qb((tmp_packed1>>BEAM_LOOSE_SHIFT)));;
  ASSERT(VALID_INSTR(*(I + (I[2]) + 0)));
  I += I[2] + 0;;
  DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
  Dispatch();;;
}

OpCase(move_call_only_cf):
{
  x(0) = I[1];
  ASSERT(VALID_INSTR(*(I + (I[2]) + 0)));
  I += I[2] + 0;;
  DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
  Dispatch();;;
}

OpCase(move_call_only_xf):
{
  Eterm tmp_packed1 = I[1];
  x(0) = xb(tmp_packed1&BEAM_WIDE_MASK);
  ASSERT(VALID_INSTR(*(I + (fb((tmp_packed1>>BEAM_WIDE_SHIFT))) + 0)));
  I += fb((tmp_packed1>>BEAM_WIDE_SHIFT)) + 0;;
  DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
  Dispatch();;;
}

OpCase(move_call_xf):
{
  Eterm tmp_packed1 = I[1];
  x(0) = xb(tmp_packed1&BEAM_WIDE_MASK);
  SET_CP(c_p, I+2);
  ASSERT(VALID_INSTR(*(I + (fb((tmp_packed1>>BEAM_WIDE_SHIFT))) + 0)));
  I += fb((tmp_packed1>>BEAM_WIDE_SHIFT)) + 0;;
  DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
  Dispatch();;
}

OpCase(move_call_yf):
{
  Eterm tmp_packed1 = I[1];
  x(0) = yb(tmp_packed1&BEAM_WIDE_MASK);
  SET_CP(c_p, I+2);
  ASSERT(VALID_INSTR(*(I + (fb((tmp_packed1>>BEAM_WIDE_SHIFT))) + 0)));
  I += fb((tmp_packed1>>BEAM_WIDE_SHIFT)) + 0;;
  DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
  Dispatch();;
}

OpCase(move_cr):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  r(0) = I[1];
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_cx):
{
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  xb(I[2]) = I[1];
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_deallocate_return_cQ):
{
  x(0) = I[1];
  do {
    int words_to_pop = I[2];
    SET_I((BeamInstr *) cp_val(*E));
    E = ADD_BYTE_OFFSET(E, words_to_pop);
    CHECK_TERM(x(0));
    DispatchReturn;
  } while (0);
}

OpCase(move_deallocate_return_nQ):
{
  x(0) = NIL;
  do {
    int words_to_pop = I[1];
    SET_I((BeamInstr *) cp_val(*E));
    E = ADD_BYTE_OFFSET(E, words_to_pop);
    CHECK_TERM(x(0));
    DispatchReturn;
  } while (0);
}

OpCase(move_deallocate_return_xQ):
{
  Eterm tmp_packed1 = I[1];
  x(0) = xb(tmp_packed1&BEAM_LOOSE_MASK);
  do {
    int words_to_pop = Qb((tmp_packed1>>BEAM_LOOSE_SHIFT));
    SET_I((BeamInstr *) cp_val(*E));
    E = ADD_BYTE_OFFSET(E, words_to_pop);
    CHECK_TERM(x(0));
    DispatchReturn;
  } while (0);
}

OpCase(move_deallocate_return_yQ):
{
  Eterm tmp_packed1 = I[1];
  x(0) = yb(tmp_packed1&BEAM_LOOSE_MASK);
  do {
    int words_to_pop = Qb((tmp_packed1>>BEAM_LOOSE_SHIFT));
    SET_I((BeamInstr *) cp_val(*E));
    E = ADD_BYTE_OFFSET(E, words_to_pop);
    CHECK_TERM(x(0));
    DispatchReturn;
  } while (0);
}

OpCase(move_dup_xxx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = xb(tmp_packed1&BEAM_TIGHT_MASK);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_dup_xxy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = yb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = xb(tmp_packed1&BEAM_TIGHT_MASK);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_dup_yxx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = yb(tmp_packed1&BEAM_TIGHT_MASK);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_dup_yxy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = yb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = yb(tmp_packed1&BEAM_TIGHT_MASK);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_jump_fc):
{
  x(0) = I[2];
  ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
  I += I[1] + 0;;
  Goto(*I);;;
}

OpCase(move_jump_fn):
{
  x(0) = NIL;
  ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
  I += I[1] + 0;;
  Goto(*I);;;
}

OpCase(move_jump_fx):
{
  Eterm tmp_packed1 = I[1];
  x(0) = xb((tmp_packed1>>BEAM_WIDE_SHIFT));
  ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
  I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
  Goto(*I);;;
}

OpCase(move_jump_fy):
{
  Eterm tmp_packed1 = I[1];
  x(0) = yb((tmp_packed1>>BEAM_WIDE_SHIFT));
  ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
  I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
  Goto(*I);;;
}

OpCase(move_nx):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  xb(I[1]) = NIL;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_return_c):
{
  x(0) = I[1];
  SET_I(c_p->cp);
  c_p->cp = 0;
  DispatchReturn;
}

OpCase(move_return_n):
{
  x(0) = NIL;
  SET_I(c_p->cp);
  c_p->cp = 0;
  DispatchReturn;
}

OpCase(move_return_x):
{
  x(0) = xb(I[1]);
  SET_I(c_p->cp);
  c_p->cp = 0;
  DispatchReturn;
}

OpCase(move_rx):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  xb(I[1]) = r(0);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_ry):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  yb(I[1]) = r(0);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_shift_xxx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm V;
  V = xb(tmp_packed1&BEAM_TIGHT_MASK);
  xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK);
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = V;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_shift_xxy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm V;
  V = xb(tmp_packed1&BEAM_TIGHT_MASK);
  yb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK);
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = V;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_shift_xyx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm V;
  V = xb(tmp_packed1&BEAM_TIGHT_MASK);
  xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = yb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK);
  yb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = V;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_shift_yxx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm V;
  V = yb(tmp_packed1&BEAM_TIGHT_MASK);
  xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK);
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = V;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_window3_xxxy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm xt0, xt1, xt2;
  Eterm* y = &yb((tmp_packed1>>(3*BEAM_LOOSE_SHIFT)));
  xt0  = xb(tmp_packed1&BEAM_LOOSE_MASK);
  xt1  = xb((tmp_packed1>>BEAM_LOOSE_SHIFT)&BEAM_LOOSE_MASK);
  xt2  = xb((tmp_packed1>>(2*BEAM_LOOSE_SHIFT))&BEAM_LOOSE_MASK);
  y[0] = xt0;
  y[1] = xt1;
  y[2] = xt2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_window4_xxxxy):
{
  Eterm tmp_packed1 = I[1];
  Eterm tmp_packed2 = I[2];
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  Eterm xt0, xt1, xt2, xt3;
  Eterm* y = &yb((tmp_packed2>>BEAM_LOOSE_SHIFT));
  xt0  = xb(tmp_packed1&BEAM_TIGHT_MASK);
  xt1  = xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK);
  xt2  = xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT)));
  xt3  = xb(tmp_packed2&BEAM_LOOSE_MASK);
  y[0] = xt0;
  y[1] = xt1;
  y[2] = xt2;
  y[3] = xt3;
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_window5_xxxxxy):
{
  Eterm tmp_packed1 = I[1];
  Eterm tmp_packed2 = I[2];
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  Eterm xt0, xt1, xt2, xt3, xt4;
  Eterm *y = &yb((tmp_packed2>>(2*BEAM_TIGHT_SHIFT)));
  xt0  = xb(tmp_packed1&BEAM_TIGHT_MASK);
  xt1  = xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK);
  xt2  = xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT)));
  xt3  = xb(tmp_packed2&BEAM_TIGHT_MASK);
  xt4  = xb((tmp_packed2>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK);
  y[0] = xt0;
  y[1] = xt1;
  y[2] = xt2;
  y[3] = xt3;
  y[4] = xt4;
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_x1_c):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  x(1) = I[1];
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_x2_c):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  x(2) = I[1];
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_xr):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  r(0) = xb(I[1]);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_xx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = xb(tmp_packed1&BEAM_LOOSE_MASK);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_xy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  yb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = xb(tmp_packed1&BEAM_LOOSE_MASK);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_yr):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  r(0) = yb(I[1]);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_yx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = yb(tmp_packed1&BEAM_LOOSE_MASK);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_yy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  yb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = yb(tmp_packed1&BEAM_LOOSE_MASK);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(new_map_dtI):
{
  Eterm tmp_packed1 = I[1];
  Eterm dst = db(tmp_packed1&BEAM_LOOSE_MASK);
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  Eterm res;

  HEAVY_SWAPOUT;
  res = erts_gc_new_map(c_p, reg, tb((tmp_packed1>>BEAM_LOOSE_SHIFT)), I[2], I+3);
  HEAVY_SWAPIN;
  dst_ptr = REG_TARGET_PTR(dst);
  *dst_ptr = res;
  SET_I((BeamInstr *) I+3+I[2]);
  Goto(*I);;
}

OpCase(node_x):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  xb(I[1]) = erts_this_node->sysname;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_cxx):
{
  Eterm tmp_packed1 = I[2];
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  HTOP[0] = I[1];
  HTOP[1] = xb(tmp_packed1&BEAM_LOOSE_MASK);
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = make_list(HTOP);
  HTOP += 2;
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_cyx):
{
  Eterm tmp_packed1 = I[2];
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  HTOP[0] = I[1];
  HTOP[1] = yb(tmp_packed1&BEAM_LOOSE_MASK);
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = make_list(HTOP);
  HTOP += 2;
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_rnr):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  HTOP[0] = r(0);
  HTOP[1] = NIL;
  r(0) = make_list(HTOP);
  HTOP += 2;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_rnx):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  HTOP[0] = r(0);
  HTOP[1] = NIL;
  xb(I[1]) = make_list(HTOP);
  HTOP += 2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_rxr):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  HTOP[0] = r(0);
  HTOP[1] = xb(I[1]);
  r(0) = make_list(HTOP);
  HTOP += 2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_rxx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  HTOP[0] = r(0);
  HTOP[1] = xb(tmp_packed1&BEAM_LOOSE_MASK);
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = make_list(HTOP);
  HTOP += 2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_xcx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  HTOP[0] = xb(tmp_packed1&BEAM_LOOSE_MASK);
  HTOP[1] = I[2];
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = make_list(HTOP);
  HTOP += 2;
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_xcy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  HTOP[0] = xb(tmp_packed1&BEAM_LOOSE_MASK);
  HTOP[1] = I[2];
  yb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = make_list(HTOP);
  HTOP += 2;
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_xnx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  HTOP[0] = xb(tmp_packed1&BEAM_LOOSE_MASK);
  HTOP[1] = NIL;
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = make_list(HTOP);
  HTOP += 2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_xxr):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  HTOP[0] = xb(tmp_packed1&BEAM_LOOSE_MASK);
  HTOP[1] = xb((tmp_packed1>>BEAM_LOOSE_SHIFT));
  r(0) = make_list(HTOP);
  HTOP += 2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_xxx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  HTOP[0] = xb(tmp_packed1&BEAM_TIGHT_MASK);
  HTOP[1] = xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK);
  xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = make_list(HTOP);
  HTOP += 2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_xyx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  HTOP[0] = xb(tmp_packed1&BEAM_TIGHT_MASK);
  HTOP[1] = yb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK);
  xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = make_list(HTOP);
  HTOP += 2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_ycx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  HTOP[0] = yb(tmp_packed1&BEAM_LOOSE_MASK);
  HTOP[1] = I[2];
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = make_list(HTOP);
  HTOP += 2;
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_ynx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  HTOP[0] = yb(tmp_packed1&BEAM_LOOSE_MASK);
  HTOP[1] = NIL;
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = make_list(HTOP);
  HTOP += 2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_yxx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  HTOP[0] = yb(tmp_packed1&BEAM_TIGHT_MASK);
  HTOP[1] = xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK);
  xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = make_list(HTOP);
  HTOP += 2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_yyx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  HTOP[0] = yb(tmp_packed1&BEAM_TIGHT_MASK);
  HTOP[1] = yb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK);
  xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = make_list(HTOP);
  HTOP += 2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(raw_raise):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm class = x(0);
  Eterm value = x(1);
  Eterm stacktrace = x(2);

  if (class == am_error) {
    c_p->freason = EXC_ERROR & ~EXF_SAVETRACE;
    c_p->fvalue = value;
    c_p->ftrace = stacktrace;
    goto find_func_info;
  } else if (class == am_exit) {
    c_p->freason = EXC_EXIT & ~EXF_SAVETRACE;
    c_p->fvalue = value;
    c_p->ftrace = stacktrace;
    goto find_func_info;
  } else if (class == am_throw) {
    c_p->freason = EXC_THROWN & ~EXF_SAVETRACE;
    c_p->fvalue = value;
    c_p->ftrace = stacktrace;
    goto find_func_info;
  } else {
    x(0) = am_badarg;
  }
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(remove_message):
{

  /*
  * Remove a (matched) message from the message queue.
  */

  ErtsMessage* msgp;
  PROCESS_MAIN_CHK_LOCKS(c_p);

  ERTS_CHK_MBUF_SZ(c_p);

  msgp = PEEK_MESSAGE(c_p);

  if (ERTS_PROC_GET_SAVED_CALLS_BUF(c_p)) {
    save_calls(c_p, &exp_receive);
  }
  if (ERL_MESSAGE_TOKEN(msgp) == NIL) {
#ifdef USE_VM_PROBES
    if (DT_UTAG(c_p) != NIL) {
      if (DT_UTAG_FLAGS(c_p) & DT_UTAG_PERMANENT) {
        SEQ_TRACE_TOKEN(c_p) = am_have_dt_utag;
      } else {
        DT_UTAG(c_p) = NIL;
        SEQ_TRACE_TOKEN(c_p) = NIL;
      }
    } else {
#endif
      SEQ_TRACE_TOKEN(c_p) = NIL;
#ifdef USE_VM_PROBES
    }
    DT_UTAG_FLAGS(c_p) &= ~DT_UTAG_SPREADING;
#endif
  } else if (ERL_MESSAGE_TOKEN(msgp) != am_undefined) {
    Eterm msg;
    SEQ_TRACE_TOKEN(c_p) = ERL_MESSAGE_TOKEN(msgp);
#ifdef USE_VM_PROBES
    if (ERL_MESSAGE_TOKEN(msgp) == am_have_dt_utag) {
      if (DT_UTAG(c_p) == NIL) {
        DT_UTAG(c_p) = ERL_MESSAGE_DT_UTAG(msgp);
      }
      DT_UTAG_FLAGS(c_p) |= DT_UTAG_SPREADING;
    } else {
#endif
      ASSERT(is_tuple(SEQ_TRACE_TOKEN(c_p)));
      ASSERT(SEQ_TRACE_TOKEN_ARITY(c_p) == 5);
      ASSERT(is_small(SEQ_TRACE_TOKEN_SERIAL(c_p)));
      ASSERT(is_small(SEQ_TRACE_TOKEN_LASTCNT(c_p)));
      ASSERT(is_small(SEQ_TRACE_TOKEN_FLAGS(c_p)));
      ASSERT(is_pid(SEQ_TRACE_TOKEN_SENDER(c_p)));
      c_p->seq_trace_lastcnt = unsigned_val(SEQ_TRACE_TOKEN_SERIAL(c_p));
      if (c_p->seq_trace_clock < unsigned_val(SEQ_TRACE_TOKEN_SERIAL(c_p))) {
        c_p->seq_trace_clock = unsigned_val(SEQ_TRACE_TOKEN_SERIAL(c_p));
      }
      msg = ERL_MESSAGE_TERM(msgp);
      seq_trace_output(SEQ_TRACE_TOKEN(c_p), msg, SEQ_TRACE_RECEIVE, 
      c_p->common.id, c_p);
#ifdef USE_VM_PROBES
    }
#endif
  }
#ifdef USE_VM_PROBES
  if (DTRACE_ENABLED(message_receive)) {
    Eterm token2 = NIL;
    DTRACE_CHARBUF(receiver_name, DTRACE_TERM_BUF_SIZE);
    Sint tok_label = 0;
    Sint tok_lastcnt = 0;
    Sint tok_serial = 0;
    Sint len = erts_proc_sig_privqs_len(c_p);

    dtrace_proc_str(c_p, receiver_name);
    token2 = SEQ_TRACE_TOKEN(c_p);
    if (have_seqtrace(token2)) {
      tok_label = SEQ_TRACE_T_DTRACE_LABEL(token2);
      tok_lastcnt = signed_val(SEQ_TRACE_T_LASTCNT(token2));
      tok_serial = signed_val(SEQ_TRACE_T_SERIAL(token2));
    }
    DTRACE6(message_receive,
    receiver_name, size_object(ERL_MESSAGE_TERM(msgp)),
    len, /* This is NOT message queue len, but its something... */
    tok_label, tok_lastcnt, tok_serial);
  }
#endif
  UNLINK_MESSAGE(c_p, msgp);
  JOIN_MESSAGE(c_p);
  CANCEL_TIMER(c_p);

  erts_save_message_in_proc(c_p, msgp);
  c_p->flags &= ~F_DELAY_GC;

  if (ERTS_IS_GC_DESIRED_INTERNAL(c_p, HTOP, E)) {
    /*
    * We want to GC soon but we leave a few
    * reductions giving the message some time
    * to turn into garbage.
    */
    ERTS_VBUMP_LEAVE_REDS_INTERNAL(c_p, 5, FCALLS);
  }

  ERTS_DBG_CHK_REDS(c_p, FCALLS);
  ERTS_CHK_MBUF_SZ(c_p);

  ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
  PROCESS_MAIN_CHK_LOCKS(c_p);
  I += 1;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(return):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  SET_I(c_p->cp);
  DTRACE_RETURN_FROM_PC(c_p);

  /*
  * We must clear the CP to make sure that a stale value do not
  * create a false module dependcy preventing code upgrading.
  * It also means that we can use the CP in stack backtraces.
  */
  c_p->cp = 0;
  CHECK_TERM(r(0));
  HEAP_SPACE_VERIFIED(0);
  DispatchReturn;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(self_x):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  xb(I[1]) = c_p->common.id;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(self_y):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  yb(I[1]) = c_p->common.id;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(send):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm result;

  if (!(FCALLS > 0 || FCALLS > neg_o_reds)) {
    /* If we have run out of reductions, we do a context
    switch before calling the bif */
    c_p->arity = 2;
    c_p->current = NULL;
    goto context_switch3;
  }

  PRE_BIF_SWAPOUT(c_p);
  c_p->fcalls = FCALLS - 1;
  result = erl_send(c_p, r(0), x(1));
  ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
  ERTS_REQ_PROC_MAIN_LOCK(c_p);
  PROCESS_MAIN_CHK_LOCKS(c_p);
  HTOP = HEAP_TOP(c_p);
  FCALLS = c_p->fcalls;
  if (ERTS_LIKELY(is_value(result))) {
    r(0) = result;
    CHECK_TERM(r(0));
  } else if (c_p->freason == TRAP) {
    SET_CP(c_p, I+1);
    SET_I(c_p->i);
    SWAPIN;
    Dispatch();
  } else {
    goto find_func_info;
  }
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(set_tuple_element_sSP):
{
  Eterm targ1;
  BeamInstr next_pf = BeamCodeAddr(I[4]);
  GetR(0, targ1);
  {
    Eterm* p;

    ASSERT(is_tuple(Sb(I[2])));
    p = (Eterm *) ((unsigned char *) tuple_val(Sb(I[2])) + I[3]);
    *p = targ1;
    I += 4;
    ASSERT(VALID_INSTR(next_pf));
    GotoPF(next_pf);
  }
}

OpCase(swap_temp_xxx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm V = xb(tmp_packed1&BEAM_TIGHT_MASK);
  xb(tmp_packed1&BEAM_TIGHT_MASK) = xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK);
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = V;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(swap_temp_xyx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm V = xb(tmp_packed1&BEAM_TIGHT_MASK);
  xb(tmp_packed1&BEAM_TIGHT_MASK) = yb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK);
  yb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = xb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))) = V;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(swap_xx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm V = xb(tmp_packed1&BEAM_LOOSE_MASK);
  xb(tmp_packed1&BEAM_LOOSE_MASK) = xb((tmp_packed1>>BEAM_LOOSE_SHIFT));
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = V;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(swap_xy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm V = xb(tmp_packed1&BEAM_LOOSE_MASK);
  xb(tmp_packed1&BEAM_LOOSE_MASK) = yb((tmp_packed1>>BEAM_LOOSE_SHIFT));
  yb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = V;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(test_arity_fxA):
{
  Eterm tmp_packed1 = I[1];
  if (*tuple_val(xb((tmp_packed1>>BEAM_WIDE_SHIFT))) != I[2]) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(test_arity_fyA):
{
  Eterm tmp_packed1 = I[1];
  if (*tuple_val(yb((tmp_packed1>>BEAM_WIDE_SHIFT))) != I[2]) {
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(test_heap_1_put_list_Iy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  do {
    Uint need = Ib(tmp_packed1&BEAM_WIDE_MASK) + 0;
    if (ERTS_UNLIKELY(E - HTOP < need)) {
      SWAPOUT;
      PROCESS_MAIN_CHK_LOCKS(c_p);
      FCALLS -= erts_garbage_collect_nobump(c_p, need, reg, 1, FCALLS);
      ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
      PROCESS_MAIN_CHK_LOCKS(c_p);
      SWAPIN;
    }
    HEAP_SPACE_VERIFIED(Ib(tmp_packed1&BEAM_WIDE_MASK));
  } while (0);;
  do {
    HTOP[0] = yb((tmp_packed1>>BEAM_WIDE_SHIFT));
    HTOP[1] = x(0);
    x(0) = make_list(HTOP);
    HTOP += 2;
  } while (0);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(test_heap_It):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  do {
    Uint need = Ib(tmp_packed1&BEAM_WIDE_MASK) + 0;
    if (ERTS_UNLIKELY(E - HTOP < need)) {
      SWAPOUT;
      PROCESS_MAIN_CHK_LOCKS(c_p);
      FCALLS -= erts_garbage_collect_nobump(c_p, need, reg, tb((tmp_packed1>>BEAM_WIDE_SHIFT)), FCALLS);
      ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
      PROCESS_MAIN_CHK_LOCKS(c_p);
      SWAPIN;
    }
    HEAP_SPACE_VERIFIED(Ib(tmp_packed1&BEAM_WIDE_MASK));
  } while (0);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(timeout):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  if (IS_TRACED_FL(c_p, F_TRACE_RECEIVE)) {
    trace_receive(c_p, am_clock_service, am_timeout, NULL);
  }
  if (ERTS_PROC_GET_SAVED_CALLS_BUF(c_p)) {
    save_calls(c_p, &exp_timeout);
  }
  c_p->flags &= ~F_TIMO;
  JOIN_MESSAGE(c_p);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(timeout_locked):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  /*
  * A timeout has occurred.  Reset the save pointer so that the next
  * receive statement will examine the first message first.
  */

  erts_proc_unlock(c_p, ERTS_PROC_LOCKS_MSG_RECEIVE);
  if (IS_TRACED_FL(c_p, F_TRACE_RECEIVE)) {
    trace_receive(c_p, am_clock_service, am_timeout, NULL);
  }
  if (ERTS_PROC_GET_SAVED_CALLS_BUF(c_p)) {
    save_calls(c_p, &exp_timeout);
  }
  c_p->flags &= ~F_TIMO;
  JOIN_MESSAGE(c_p);;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(try_case_y):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  c_p->catches--;
  make_blank(yb(I[1]));;
  ASSERT(is_non_value(r(0)));
  c_p->fvalue = NIL;
  r(0) = x(1);
  x(1) = x(2);
  x(2) = x(3);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(try_end_y):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  c_p->catches--;
  make_blank(yb(I[1]));
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(update_list_cx):
{
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  HTOP[0] = I[1];
  HTOP[1] = xb(I[2]);
  xb(I[2]) = make_list(HTOP);
  HTOP += 2;
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(update_list_xx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  HTOP[0] = xb(tmp_packed1&BEAM_LOOSE_MASK);
  HTOP[1] = xb((tmp_packed1>>BEAM_LOOSE_SHIFT));
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = make_list(HTOP);
  HTOP += 2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(update_list_yx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  HTOP[0] = yb(tmp_packed1&BEAM_LOOSE_MASK);
  HTOP[1] = xb((tmp_packed1>>BEAM_LOOSE_SHIFT));
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)) = make_list(HTOP);
  HTOP += 2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(update_map_assoc_sdtI):
{
  Eterm tmp_packed1 = I[2];
  Eterm targ1;
  Eterm dst = db(tmp_packed1&BEAM_LOOSE_MASK);
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  GetR(0, targ1);
  {
    Eterm res;
    Uint live = tb((tmp_packed1>>BEAM_LOOSE_SHIFT));

    reg[live] = targ1;
    HEAVY_SWAPOUT;
    res = erts_gc_update_map_assoc(c_p, reg, live, I[3], I+4);
    HEAVY_SWAPIN;
    ASSERT(is_value(res));
    dst_ptr = REG_TARGET_PTR(dst);
    *dst_ptr = res;
    SET_I((BeamInstr *) I+4+I[3]);
    Goto(*I);;
  }
}

OpCase(update_map_exact_jsdtI):
{
  Eterm tmp_packed1 = I[1];
  Eterm tmp_packed2 = I[3];
  Eterm targ1;
  Eterm dst = db((tmp_packed1>>BEAM_WIDE_SHIFT));
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  GetR(1, targ1);
  {
    Eterm res;
    Uint live = tb(tmp_packed2&BEAM_WIDE_MASK);

    reg[live] = targ1;
    HEAVY_SWAPOUT;
    res = erts_gc_update_map_exact(c_p, reg, live, Ib((tmp_packed2>>BEAM_WIDE_SHIFT)), I+4);
    HEAVY_SWAPIN;
    if (is_value(res)) {
      dst_ptr = REG_TARGET_PTR(dst);
      *dst_ptr = res;
      SET_I((BeamInstr *) I+4+Ib((tmp_packed2>>BEAM_WIDE_SHIFT)));
      Goto(*I);;
    } else {

      /*
      * In a correctly working program, we expect failures in
      * guards to be more likely than failures in bodies.
      */

      if (ERTS_LIKELY(jb(tmp_packed1&BEAM_WIDE_MASK))) {
        ASSERT(VALID_INSTR(*(I + (jb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
        I += jb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
        Goto(*I);;
      }
      goto find_func_info;;
    }
  }
}

{
  OpCase(wait_locked_f):
  {

  }
  goto wait__execute;

  OpCase(wait_timeout_unlocked_int_If):
  {
    erts_proc_lock(c_p, ERTS_PROC_LOCKS_MSG_RECEIVE);
  }
  goto wait__int;

  OpCase(wait_timeout_unlocked_sf):
  {
    erts_proc_lock(c_p, ERTS_PROC_LOCKS_MSG_RECEIVE);
  }
  goto wait__src;

  OpCase(wait_unlocked_f):
  {
    erts_proc_lock(c_p, ERTS_PROC_LOCKS_MSG_RECEIVE);
  }
  goto wait__execute;

  OpCase(wait_timeout_locked_int_If):
  wait__int:
  {
    /*
    * If we have already set the timer, we must NOT set it again.  Therefore,
    * we must test the F_INSLPQUEUE flag as well as the F_TIMO flag.
    */
    if ((c_p->flags & (F_INSLPQUEUE | F_TIMO)) == 0) {
      BeamInstr** pi = (BeamInstr **) c_p->def_arg_reg;
      *pi = I+3;
      erts_set_proc_timer_uword(c_p, I[1]);
    }
  }
  I += 1;
  goto wait__execute;

  OpCase(wait_timeout_locked_sf):
  wait__src:
  {
    Eterm targ1;
    GetR(0, targ1);
    {
      /*
      * If we have already set the timer, we must NOT set it again.  Therefore,
      * we must test the F_INSLPQUEUE flag as well as the F_TIMO flag.
      */
      if ((c_p->flags & (F_INSLPQUEUE | F_TIMO)) == 0) {
        Eterm timeout_value = targ1;
        if (timeout_value == make_small(0)) {
          erts_proc_unlock(c_p, ERTS_PROC_LOCKS_MSG_RECEIVE);
          SET_I((BeamInstr *) I+3);
          Goto(*I);;
        } else if (timeout_value == am_infinity) {
          c_p->flags |= F_TIMO;
        } else {
          int tres = erts_set_proc_timer_term(c_p, timeout_value);
          if (tres == 0) {
            /*
            * The timer routiner will set c_p->i to the value in
            * c_p->def_arg_reg[0].  Note that it is safe to use this
            * location because there are no living x registers in
            * a receive statement.
            */
            BeamInstr** pi = (BeamInstr**) c_p->def_arg_reg;
            *pi = I+3;
          } else { /* Wrong time */
            erts_proc_unlock(c_p, ERTS_PROC_LOCKS_MSG_RECEIVE);
            c_p->freason = EXC_TIMEOUT_VALUE;
            goto find_func_info;
          }
        }
      }
    }
  }
  I += 1;
  goto wait__execute;

  wait__execute:
  {
    c_p->i = I + (I[1]);
    ASSERT(VALID_INSTR(*c_p->i));; /* L1 */
    SWAPOUT;
    c_p->arity = 0;

    if (!ERTS_PTMR_IS_TIMED_OUT(c_p)) {
      erts_atomic32_read_band_relb(&c_p->state,
      ~ERTS_PSFLG_ACTIVE);
    }
    ASSERT(!ERTS_PROC_IS_EXITING(c_p));
    erts_proc_unlock(c_p, ERTS_PROC_LOCKS_MSG_RECEIVE);
    c_p->current = NULL;
    goto do_schedule;

  }

}


m4_include([general.m4sh])m4_divert_push([KILL])	-*- Autoconf -*-
# getopt.m4sh -- getopt helper functions
#
#    Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software
#    Foundation, Inc.
#    Written by Gary V. Vaughan, 2004
#
#    This file is part of GNU Libtool.
#
# GNU Libtool is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of
# the License, or (at your option) any later version.
#
# As a special exception to the GNU General Public License, if you
# distribute this file as part of a program or library that contains
# a configuration script generated by Autoconf, you may include this
# file under the same distribution terms that you use for the rest
# of that program.
#
# GNU Libtool is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNES FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GNU Libtool; see the file COPYING.  If not, a copy
# can be downloaded from  http://www.gnu.org/licenses/gpl.html,
# or obtained by writing to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

# This file provides the M4SH_GETOPTS option processing compiler, and
# all necessary support at the m4 and shell-script levels.
#
# An m4sh script can include this file, and an M4SH_GETOPTS invocation
# that expands to a shell script option processing loop with similar
# abilites to a C program the uses getopt_long() to process it's command
# line options - although, unlike the C API, M4SH_GETOPTS also supplies
# the loop to step through and process the options.
#
# See the comment above M4SH_GETOPTS, below, for details.


# All internal macros begin with `m4go_'.
m4_pattern_forbid([^_?m4go_])


## --------------------------- ##
## 1. Backwards compatibility. ##
## --------------------------- ##

# We prefer m4sugar.m4 from Autoconf-2.64, but have fallbacks in this
# section that work back as far as Autoconf-2.62.  This file is used
# at bootstrap time to generate the shell processing loop for ltmain.sh
# and libtoolize.in, so it's okay for the requirement to be tighter
# than the configure time Autoconf prerequisite version.
m4_version_prereq([2.62])

# m4_chomp(STRING)
# ----------------
# m4_chomp was not introduced until Autoconf-2.64.  Currently we
# only use it indirectly via m4go_expand, below.  This implementation
# is taken from Autoconf-2.65.
m4_ifndef([m4_chomp],
[m4_define([m4_chomp],
[m4_format([[%.*s]], m4_index(m4_translit([[$1]], [
/.], [/  ])[./.], [/.]), [$1])])])

# m4go_expand(ARG)
# ----------------
# M4SH_GETOPTS wants to pass unbalanced parentheses to m4_expand to
# build the branches of a shell `case' statement.  That is only
# supported by the implementation of m4_expand in Autoconf-2.64 and
# newer.  Since we want to be compatible back to at least
# Autoconf-2.62, reimplement our own 2.64 based m4_expand in the
# m4go_ namespace so that we can be compatible with Autoconf versions
# supporting either semantic.
m4_define([m4go_expand],
[m4_chomp(_$0([$1
]))])

m4_define([_m4go_expand], [$0_([$1], [(], -=<{($1)}>=-, [}>=-])])

m4_define([_m4go_ignore])

m4_define([_m4go_expand_],
[m4_if([$4], [}>=-],
       [m4_changequote([-=<{$2], [)}>=-])$3m4_changequote([, ])],
       [$0([$1], [($2], -=<{($2$1)}>=-, [}>=-])_m4go_ignore$2])])


## --------------------------------- ##
## 2. Low level string manipulation. ##
## --------------------------------- ##

# m4go_slice(STRING, BEGIN, END)
# ------------------------------
# Just like m4_substr(), except that both the BEGIN and END of the
# substring are given as offsets from the beginning of STRING, as
# returned by m4_index().
m4_define([m4go_slice],
[m4_substr([$1], [$2], m4_eval([$3-$2]))])

# m4go_trimn(STRING)
# -------------------
# Trim all leading and trailing newlines from STRING.
#
# Inspite of careful quoting, this macro is NOT robust to active
# symbols:
#        | m4_define(active, ACTV)
#        | m4go_trimn([[
#        |    start active finish
#        | ]])
#       => start ACTV fini
# The interaction between index counting and macro expansion also
# results in overtrimming in this example by 2 characters (the
# difference between the lengths of `active' and `ACTV'). Translation
# into French is just a coincidence.
#
# The implementation is surprisingly finicky: We use m4go_slice() to
# extract the middle section of the string, while using m4_bregexp() to
# return offset counts for the first and last non-newlines in STRING.
# But there are a number of corner cases:
#  1. Double quoted STRING works, (i.e m4go_trimn([[\nthe string\n]]. We
#     achieve that by transliterating quote characters as well as
#     newlines to the same character before counting off the offsets.
#  2. This needs a slightly different transliteration for each
#     m4_bregexp() invocation, because we need to maintain balanced
#     quotes in the argument and we don't want to swallow leading ']' or
#     trailing '[' characters.  So, we turn the quote we don't want to
#     strip into a harmless ' '.
#  3. Because we're now effectively stripping the quotation with the
#     m4_translit() calls, embedded commas can fool m4_bregexp() into
#     thinking there are more arguments than we intended, so we turn
#     them into spaces too.
#  4. Unbalanced parentheses would also confuse m4_bregexp(), so we also
#     turn them into spaces.  The upshot of that if STRING contains a
#     macro invocation with arguments, it will be expanded in the result
#     as if no arguments had been passed.
#  5. Comments are not ignored after stripping quote marks, so we have
#     to turn them off for the duration.
#  6. Finally, we need to requote the result to account for the quotes
#     we probably stripped.  m4_quote() doesn't handle commas well, so
#     we use m4go_expand() to requote without losing whitespace after
#     any embedded commas.
m4_define([m4go_trimn],
[m4_changecom()m4go_expand([m4go_slice([$1], m4_bregexp(m4_translit([$1],[
[/,()]], [//     ]), [[^/]]), m4_bregexp(m4_translit([$1], [
[/,()]], [/     /]), [/*$]))])[]m4_changecom([#])])

# m4go_untab(STRING)
# ------------------
# Trim leading TABs from each line of STRING.
m4_define([m4go_untab],
[m4_bpatsubst([$1], [^[	]*], [])])

# m4go_unindent(STRING)
# ---------------------
# Completely unindent STRING: Remove the leading TABs from each line of
# STRING; trim leading newlines and trailing whitespace from STRING as
# a whole.
m4_define([m4go_unindent],
[m4_ifval([$1], [m4go_untab([m4go_trimn([$1])])])])


## ------------------------------ ##
## 3. Option processing compiler. ##
## ------------------------------ ##

# Shell fragments are piecemeal added to these macros for each
# invocation of m4go_option; eventually to be expanded into the compiled
# option parsing shell script by M4SH_GETOPTS:

m4_define([m4go_defaults], [])	# initial shell option variable setings
m4_define([m4go_branches], [])	# case branches to process options

# The initial entries in m4go_shortnoargs represent the (non-argument)
# options that are always accepted by the expanded processing loop. We
# also keep a list of short options that accept an option argument in
# the macro `m4go_shortargs', but we use `m4_append([m4go_shortargs],
# OPTION, [|])' to insert the separator pipe symbols - which requires
# that `m4go_shortargs' be undefined if the first option appended is not
# prefixed by a leading `|'.
m4_define([m4go_shortnoargs], [-\?*|-h*])


# M4SH_GETOPTS(SHORT-SPEC1, LONG-MATCH1, DEF1, INIT1,
#              SHORT-SPEC2, LONG-MATCH2, DEF2, INIT2, ... [VALIDATION])
# ---------------------------------------------------------------------
# Declare a series of command line options with one letter (`-m') or
# long form `--message' formats, along with optional default values
# incase a given option is not provided by the user when the script is
# invoked, and validation code, for example to prevent specifying
# mutually exclusive options or omitting required options.
#
# After this macro has been called, the value of each option is
# available in a shell variable named `opt_' followed by the first part
# (i.e. up to the first '|' symbol) of the LONG-MATCHn argument with the
# leading `--` removed, and any further `-' converted to `_', or else if
# no long form option was provided, simple `opt_' followed by the short
# option letter. For example, the value supplied by the user as an
# argument to an option `--gpg-key-id' will be available in the shell
# variable $opt_gpg_key_id, `-c' with no long form option will be
# available as $opt_c and so on. Where an option doesn't take an
# argument, then the shell variable will be set to either `:' or `false'
# depending on whether the user set that option on the script command
# line - with one important exception: If the long form option name
# begins with `--no-', and does not require an option argument, then the
# variable name will be `opt_' followed by the rest of the option name
# with the leading `no_' removed; and it's value will be `false' if
# `--no-foo' was given on the command line, and `:' otherwise.
#
# Each option is declared by a set of 4 arguments as follows:
#
# SHORT-SPECn
#	The short option letter, if any, for the nth option followed by
#	any flags to denote special processing for this option. For
#	example, `f?@'. See below for a list of the supported flags and
#	their meaning. If you specify `h', `v' or `x', then the
#	automatic processing of those short options for `--help',
#	`--version' and `--debug' (resp.) will be overridden.
# LONG-MATCHn
#	The long option list, including leading dashes for the nth
#	option. The value for this option is used directly as a shell
#	`case' branch to match the option, so you can specify multiple
#	matches. For example, `--message|--mes*|--msg'.  If you specify
#	neither this argument nor a short option letter with
#	SHORT-SPECn, then invalid shell code will be generated.
# DEFn	If there is a default value for the nth option to take when it
#	is not given on the command line when the script is executed,
#	specify it here. Double quotes are added in the expanded shell
#	script, so it is safe to use shell variables. For example,
#	`$HOME/.foorc'.
# INITn	Any option specific initialisation for the nth option should be
#	specified in this argument. The shell code it contains is added
#	directly to the case branch that matches the nth option, after
#	the `opt_NAME' variable has been set, with the option argument
#	(if any) still left in `$1'.  This allows neat tricks such as
#	injecting new arguments into the command line before the
#	processing loop terminates.  For example:
#
#		`eval set -- `cat $rcfile` ${1+"$@"}'
#
#	Note that, because we look inside the content of INITn to
#	determine whether there are newlines to be stripped, double
#	quoting the whele thing doesn't work.  Instead, you'll need to
#	quote active symbols yourself.  Generally, you'll only need to
#	worry about $n and $@, although if you use symbols that can be
#	expanded by m4 you'll need to quote those too.
# VALIDATION
#	The final argument, if any, should contain shell code to
#	validate correctness of the processed options.  This code is
#	expanded after the option processing loop has exited, and before
#	the conditional script exit if errors have been found.  Try to
#	show as many errors as possible before exiting the shell rather
#	than bailing out on the first error discovered so that the user
#	can correct all of them at once rather than just one between
#	each reinvocation of the script.
#
# In addition to an option short form letter (e.g. `m'), each
# SHORT-SPECn argument can also list one or more of the following flags
# to place additional constraints on that option (only one of `?', `+'
# and `@' can be given in any SHORT-SPECn):
#
# =STRING
#	The option does not take an argument, but when specified on the
#	command line the `opt_' variable is set to STRING.
# ?	The option takes an optional argument. Unless the next command
#	line argument begins with a `-' it will be the value stored in
#	this option's `opt_' shell variable. Otherwise the `opt_'
#	variable will contain the INITn value.
# !	The option requires an argument. The next command line argument
#	will be stored in this option's `opt_' shell variable, or else
#	the INITn value, if any, will be stored if this option is not
#	given on the command line.
# ;	The same as `!', except that when the argument is given multiple
#	times on the command line, each argument is appended to the
#	`opt_' shell variable, along with a new-line to separate it from
#	the previous argument.
# +	The same as `!', except that each time the argument is supplied
#	on the command line, it's value is stored in an `opt_' variable
#	with `_n' appended to the variable name - where `n' is `1' for
#	the first argument, `2, for the second and so on.
# @	The option argument must point to an existing file. The
#	processing loop will automatically contain an additional check
#	to ensure that the named file exists. `@' can be added to a
#	SHORT-SPECn argument in addition to any other flags.
# ^	The value stored in the `opt_' variable is quoted by passing it
#	through the shell function `func_quote_for_eval'.
#
# The M4SH_GETOPTS macro is implemented by first delegating to
# `_M4SH_GETOPTS', a shift4-loop that repeatedly calls `m4go_options',
# shifts away the 4 processed arguments, checks the number of remaining
# args and loops again until only 1 argument (VALIDATION) or 0 arguments
# (no VALIDATION code) remain. When all the processing is complete, we
# expand 'm4go_printopts' to write out the complete command line
# processing shell loop.
#
# Generally, you can combine the SHORT-SPECn flags in sensible ways,
# but no error checking is done. If you choose a combination that makes
# no sense, you'll probably end up with broken shell code.
m4_define([M4SH_GETOPTS],
[_$0($@)[]m4go_printopts])
m4_define([_M4SH_GETOPTS],
[m4_if([$#], 0, [],
       [$#], 1, [m4_define([m4go_validation],[$1])],
       [$#], 2, [m4_fatal([$0: too few arguments: $#: $2])],
       [$#], 3, [m4_fatal([$0: too few arguments: $#: $3])],
       [m4go_option($@)[]$0(m4_shiftn(4, $@))])])


# m4go_option(SHORT-SPEC, LONG-MATCH, DEFAULT, INIT)
# --------------------------------------------------
# This macro is a wrapper for `_m4go_option', which first extracts the
# short option letter (if any) from SHORT-SPEC, and then calculates the
# full `opt_' shell variable name for this option before delegating
# those results along with all of its own arguments to `_m4go_option'.
#
# Note that when the LONG-MATCH begins with `--no-', we add `~' to the
# list of SHORT-SPEC flags before calling `_m4go_option' to denote that
# the name of the `opt_' variable is reversed in the sense of the option
# name itself.That is, we want to start with the option being true, and
# set it to false if `--no-foo' is given on the command line.
#
# `m4_do' is used here to separate out the pushdef and popdef of the
# temporary `_short' macro used to held the extracted short option
# letter, if any.
m4_define([m4go_option],
[m4_do(
    [m4_pushdef([_short],
        m4_bmatch([$1],
            [[?!;+@^]], m4_bpatsubst([$1], [[?!;+@^]*], []),
            [^=],       [],
            [.],        [[$1]],
                        []))],
    [_$0(opt_[]m4_ifval([$2],
            m4_translit(m4_bpatsubst([$2], [^--\(no-\)?\([^|]+\).*$],
                                     [\2]), -, _),
                _short),
         _short,
         [$1]m4_bmatch([$2], [^--no-], [~]),
         [$2],
         [$3],
         [$4])],
    [m4_popdef([_short])])])


# _m4go_option(OPTION-NAME, SHORT-OPTION, SHORT-SPEC, LONG-MATCH,
#                  DEFAULT, INIT)
#----------------------------------------------------------------
# For this option, append the appropriate shell code fragments to:
# `m4go_defaults'
#	A shell script fragment containing `opt_' variable
#	initialisation according to DEFAULT, if necessary;
# `m4go_branches'
#	The case branch to match any SHORT-OPTION or LONG-MATCH command
#	line option, along with any automatic processing implied by
#	SHORT-SPEC flags, and additional code from INIT;
# `m4go_shortargs'
#	This match string accumulates all of the short options that
#	accept option arguments, so that we can generate some additional
#	code to split apart compacted option strings (`-xfoo' will be
#	treated as if `-x foo' had been passed) in `m4go_printopts'.
# `m4go_shortnoargs'
#	Similarly, accumulate short options that do not take option
#	arguments, so that we can generate the code to split apart
#	compacted options strings in `m4go_printopts' (`-xfoo' will be
#	treated as if `-x -f -o -o' had been passed).
#
# The core of this macro switches the `m4go_branches' processing to an
# appropriate macro depending on what flags are present in SHORT-SPEC.

m4_define([_m4go_option],
[m4_do(
    [m4_append([m4go_defaults],
        m4_bmatch([$3],
            [[?!;+@^]], [m4_ifval([$5], [m4_n([$1="$5"])])],
            [~],        [m4_n([$1=:])],
                        [m4_n([$1=false])]))],
    [m4_append([m4go_branches], [[]dnl (
      m4_join([|], [$4], m4_ifval([$2], [-$2])))
])],
    [m4_append([m4go_branches],
        [m4_bmatch([$3], [[!+@]],
[			test [$]# = 0 && func_missing_arg $opt && break
])m4_n(m4_bmatch([$3],
    [\^],      [			func_quote_for_eval "[$]1"
			optarg="$func_quote_for_eval_result"],
    [[?!;+@]], [			optarg="[$]1"]))[]dnl
m4_n(m4_bmatch([$3],
    [+],       [			$1_num=`expr 1 + ${$1_num-0}`
			eval $1_${$1_num}=\"$optarg\"],
    [?],       [m4_bmatch([$3],
                    [@], [m4go_expand([m4go_optional_file_arg([$1])])],
                         [m4go_expand([m4go_optional_arg([$1])])])],
    [[!@]],    [			$1="$optarg"],
    [;],       [			$1="${$1+[$]$1
}$optarg"],
    [~],       [			$1=false],
    [=.],      [			$1="m4_bpatsubst([$3], [^.*=], [])"],
               [			$1=:]))[]dnl
dnl only write the file_arg fragment when we didn't already write opt_file_arg:
m4_bmatch([$3], [@], [m4_bmatch([$3], [?], [],
                   [m4go_expand([m4go_file_arg([$1])])
])])m4_n(m4go_unindent([$6]))[]dnl
m4_bmatch([$3], [[!+;]], [			shift
])			;;
])],
    [m4_ifval([$2],
        [m4_bmatch([$3],
            [[?!;+@^~]], [m4_append([m4go_shortargs],   [-$2*], [|])],
                       [m4_append([m4go_shortnoargs], [-$2*],
                                  [|])])])])])


# m4go_optional_arg(OPTION-NAME)
# ------------------------------
# Expand to the case branch core code for processing a flag that takes
# an optional argument, and sets the `opt_' variable named by
# OPTION-NAME appropriately.
m4_define([m4go_optional_arg],
[			if test [$]# -gt 0; then
			    case $optarg in # ((
			        -*) ;;
			        *) $1="$optarg"; shift ;;
			    esac
			fi])

# m4go_file_arg(OPTION-NAME)
# --------------------------
# As above, but for flags that require the name of an existing file as
# an argument.
m4_define([m4go_file_arg],
[			test -r "$optarg" || {
			    func_error "$opt: cannot read file \`$optarg'."
			    exit_cmd=exit
			}])

# m4go_optional_file_arg(OPTION-NAME)
# -----------------------------------
# As above, but for options that optionally takes the name of an
# existing file as its argument.
m4_define([m4go_optional_file_arg],
[			if test [$]# -gt 0; then
			    case $optarg in # ((
			        -*) ;;
			        *)  $1="$optarg"
			            test -r "$optarg" || {
			                func_error "$opt: cannot read file \`$optarg'."
			                exit_cmd=exit
			            }
			            shift ;;
			    esac
			fi])


# m4go_printopts
# --------------
# This macro expands to the complete command line option processing
# loop, providing for user declared options from `M4SH_GETOPTS' as well
# as support for `-x|--debug', `-\?|-h|--help' and `--version'.  The
# latter two extract their output from a stylized comment at the start
# of the script, and will not work correctly if the format is not
# followed precisely.
m4_define([m4go_printopts],
[
# Option defaults:
opt_debug=:
m4go_defaults

# Parse options once, thoroughly.  This comes as soon as possible in the
# script to make things like `--version' happen as quickly as we can.
{
  # this just eases exit handling
  while test [$]# -gt 0; do
    opt="[$]1"
    shift
    case $opt in
      --debug|-x)	opt_debug='set -x'
			func_echo "enabling shell trace mode"
			$opt_debug
			;;
m4go_branches
      -\?|-h)		func_usage				;;
      --help)		func_help				;;
      --version)	func_version				;;

      # Separate optargs to long options:
      --*=*)
			func_split_long_opt "$opt"
			set dummy "$func_split_long_opt_name" "$func_split_long_opt_arg" ${1+"[$]@"}
			shift
			;;

m4_ifset([m4go_shortargs], dnl (
[      # Separate optargs to short options:
      ]m4go_shortargs[)
			func_split_short_opt "$opt"
			set dummy "$func_split_short_opt_name" "$func_split_short_opt_arg" ${1+"[$]@"}
			shift
			;;

])m4_ifset([m4go_shortnoargs], dnl (
[      # Separate non-argument short options:
      ]m4go_shortnoargs[)
			func_split_short_opt "$opt"
			set dummy "$func_split_short_opt_name" "-$func_split_short_opt_arg" ${1+"[$]@"}
			shift
			;;

])      --)		break					;;
      -*)		func_fatal_help "unrecognized option \`$opt'" ;;
      *)		set dummy "$opt" ${1+"[$]@"};	shift; break  ;;
    esac
  done
m4_ifset([m4go_validation],
[
  # Validate options:
m4go_validation
])
  # Bail if the options were screwed
  $exit_cmd $EXIT_FAILURE
}
])


## ------------------------- ##
## 4. Supporting Shell Code. ##
## ------------------------- ##

# The shell functions below are expanded verbatim into the shell script
# at `m4_include([getopt.m4sh]', which are necessary for the correct
# operation of the automatic `--version' and `--help' options, among
# others.

m4_divert_pop([KILL])M4SH_VERBATIM([[
# func_version
# Echo version message to standard output and exit.
func_version ()
{
    $opt_debug

    $SED -n '/(C)/!b go
	:more
	/\./!{
	  N
	  s/\n# / /
	  b more
	}
	:go
	/^# '$PROGRAM' (GNU /,/# warranty; / {
        s/^# //
	s/^# *$//
        s/\((C)\)[ 0-9,-]*\( [1-9][0-9]*\)/\1\2/
        p
     }' < "$progpath"
     exit $?
}

# func_usage
# Echo short help message to standard output and exit.
func_usage ()
{
    $opt_debug

    $SED -n '/^# Usage:/,/^#  *.*--help/ {
        s/^# //
	s/^# *$//
	s/\$progname/'$progname'/
	p
    }' < "$progpath"
    echo
    $ECHO "run \`$progname --help | more' for full usage"
    exit $?
}

# func_help [NOEXIT]
# Echo long help message to standard output and exit,
# unless 'noexit' is passed as argument.
func_help ()
{
    $opt_debug

    $SED -n '/^# Usage:/,/# Report bugs to/ {
	:print
        s/^# //
	s/^# *$//
	s*\$progname*'$progname'*
	s*\$host*'"$host"'*
	s*\$SHELL*'"$SHELL"'*
	s*\$LTCC*'"$LTCC"'*
	s*\$LTCFLAGS*'"$LTCFLAGS"'*
	s*\$LD*'"$LD"'*
	s/\$with_gnu_ld/'"$with_gnu_ld"'/
	s/\$automake_version/'"`(automake --version) 2>/dev/null |$SED 1q`"'/
	s/\$autoconf_version/'"`(autoconf --version) 2>/dev/null |$SED 1q`"'/
	p
	d
     }
     /^# .* home page:/b print
     /^# General help using/b print
     ' < "$progpath"
    ret=$?
    if test -z "$1"; then
      exit $ret
    fi
}

# func_missing_arg argname
# Echo program name prefixed message to standard error and set global
# exit_cmd.
func_missing_arg ()
{
    $opt_debug

    func_error "missing argument for $1."
    exit_cmd=exit
}


# func_split_short_opt shortopt
# Set func_split_short_opt_name and func_split_short_opt_arg shell
# variables after splitting SHORTOPT after the 2nd character.
func_split_short_opt ()
{
    my_sed_short_opt='1s/^\(..\).*$/\1/;q'
    my_sed_short_rest='1s/^..\(.*\)$/\1/;q'

    func_split_short_opt_name=`$ECHO "$1" | $SED "$my_sed_short_opt"`
    func_split_short_opt_arg=`$ECHO "$1" | $SED "$my_sed_short_rest"`
} # func_split_short_opt may be replaced by extended shell implementation


# func_split_long_opt longopt
# Set func_split_long_opt_name and func_split_long_opt_arg shell
# variables after splitting LONGOPT at the `=' sign.
func_split_long_opt ()
{
    my_sed_long_opt='1s/^\(--[^=]*\)=.*/\1/;q'
    my_sed_long_arg='1s/^--[^=]*=//'

    func_split_long_opt_name=`$ECHO "$1" | $SED "$my_sed_long_opt"`
    func_split_long_opt_arg=`$ECHO "$1" | $SED "$my_sed_long_arg"`
} # func_split_long_opt may be replaced by extended shell implementation

exit_cmd=:
]])

